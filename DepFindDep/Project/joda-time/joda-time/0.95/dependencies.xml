<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE dependencies SYSTEM "http://depfind.sourceforge.net/dtd/dependencies.dtd">

<dependencies>
    <package confirmed="no">
        <name>java.io</name>
        <class confirmed="no">
            <name>java.io.BufferedReader</name>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
            <feature confirmed="no">
                <name>java.io.BufferedReader.BufferedReader(java.io.Reader)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.io.BufferedReader.close()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.io.BufferedReader.readLine()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.io.DataInput</name>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.readFrom(java.io.DataInput, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.readFrom(java.io.DataInput)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.readFrom(java.io.DataInput, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.readFrom(java.io.DataInput)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.DataInput, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.InputStream, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readMillis(java.io.DataInput)</inbound>
            <feature confirmed="no">
                <name>java.io.DataInput.readBoolean()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.readFrom(java.io.DataInput)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.readFrom(java.io.DataInput, java.lang.String)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.io.DataInput.readByte()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.readFrom(java.io.DataInput)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.io.DataInput.readInt()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.readFrom(java.io.DataInput, java.lang.String)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.io.DataInput.readLong()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readMillis(java.io.DataInput)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.io.DataInput.readUTF()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.readFrom(java.io.DataInput, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.readFrom(java.io.DataInput)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.DataInput, java.lang.String)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.io.DataInput.readUnsignedByte()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.readFrom(java.io.DataInput)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.readFrom(java.io.DataInput, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.DataInput, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readMillis(java.io.DataInput)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.io.DataInput.readUnsignedShort()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.readFrom(java.io.DataInput, java.lang.String)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.io.DataInputStream</name>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.readZoneInfoMap(java.io.DataInputStream, java.util.Map)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneInfoMap(java.io.InputStream)</inbound>
            <feature confirmed="no">
                <name>java.io.DataInputStream.DataInputStream(java.io.InputStream)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.InputStream, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneInfoMap(java.io.InputStream)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.io.DataInputStream.readUTF()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.readZoneInfoMap(java.io.DataInputStream, java.util.Map)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.io.DataInputStream.readUnsignedShort()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.readZoneInfoMap(java.io.DataInputStream, java.util.Map)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.io.DataOutput</name>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.writeTo(java.io.DataOutput)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.writeTo(java.io.DataOutput)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.writeTo(java.io.DataOutput)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.writeTo(java.io.DataOutput)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeMillis(java.io.DataOutput, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeTo(java.io.DataOutput)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeTo(java.io.OutputStream)</inbound>
            <feature confirmed="no">
                <name>java.io.DataOutput.writeBoolean(boolean)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.writeTo(java.io.DataOutput)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.writeTo(java.io.DataOutput)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.io.DataOutput.writeByte(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.writeTo(java.io.DataOutput)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.writeTo(java.io.DataOutput)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeMillis(java.io.DataOutput, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeTo(java.io.DataOutput)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.io.DataOutput.writeInt(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.writeTo(java.io.DataOutput)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeMillis(java.io.DataOutput, long)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.io.DataOutput.writeLong(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeMillis(java.io.DataOutput, long)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.io.DataOutput.writeShort(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.writeTo(java.io.DataOutput)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.io.DataOutput.writeUTF(java.lang.String)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.writeTo(java.io.DataOutput)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.writeTo(java.io.DataOutput)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeTo(java.io.DataOutput)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.io.DataOutputStream</name>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
            <feature confirmed="no">
                <name>java.io.DataOutputStream.DataOutputStream(java.io.OutputStream)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeTo(java.io.OutputStream)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.io.DataOutputStream.writeShort(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.io.DataOutputStream.writeUTF(java.lang.String)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.io.File</name>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.main(java.lang.String[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.io.File)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.iFileDir</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.openResource(java.lang.String)</inbound>
            <feature confirmed="no">
                <name>java.io.File.File(java.io.File, java.lang.String)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.main(java.lang.String[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.openResource(java.lang.String)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.io.File.File(java.lang.String)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.main(java.lang.String[])</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.io.File.exists()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.io.File)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.io.File.getParentFile()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.io.File.isDirectory()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.io.File)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.io.File.mkdirs()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.io.FileInputStream</name>
            <feature confirmed="no">
                <name>java.io.FileInputStream.FileInputStream(java.io.File)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.openResource(java.lang.String)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.io.FileOutputStream</name>
            <feature confirmed="no">
                <name>java.io.FileOutputStream.FileOutputStream(java.io.File)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.io.FileReader</name>
            <feature confirmed="no">
                <name>java.io.FileReader.FileReader(java.io.File)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.io.FilterInputStream</name>
            <feature confirmed="no">
                <name>java.io.FilterInputStream.close()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneInfoMap(java.io.InputStream)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.io.FilterOutputStream</name>
            <feature confirmed="no">
                <name>java.io.FilterOutputStream.close()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.io.IOException</name>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone$Stub.readObject(java.io.ObjectInputStream)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone$Stub.writeObject(java.io.ObjectOutputStream)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.readObject(java.io.ObjectInputStream)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology$Stub.readObject(java.io.ObjectInputStream)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology$Stub.writeObject(java.io.ObjectOutputStream)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.io.Writer, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.io.Writer, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.printTo(java.io.Writer, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.printTo(java.io.Writer, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.io.Writer, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.io.Writer, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.lang.StringBuffer, java.io.Writer, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.io.Writer, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.io.Writer, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.printTo(java.io.Writer, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix.printTo(java.io.Writer, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.printTo(java.io.Writer, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix.printTo(java.io.Writer, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationPrinter.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writePaddedInteger(java.io.Writer, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writePaddedInteger(java.io.Writer, long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writeUnpaddedInteger(java.io.Writer, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writeUnpaddedInteger(java.io.Writer, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.readObject(java.io.ObjectInputStream)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.readFrom(java.io.DataInput, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.writeTo(java.io.DataOutput)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.readFrom(java.io.DataInput)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.writeTo(java.io.DataOutput)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.readFrom(java.io.DataInput, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.writeTo(java.io.DataOutput)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.readFrom(java.io.DataInput)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.writeTo(java.io.DataOutput)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.DataInput, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.InputStream, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readMillis(java.io.DataInput)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeMillis(java.io.DataOutput, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeTo(java.io.DataOutput)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeTo(java.io.OutputStream)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.readZoneInfoMap(java.io.DataInputStream, java.util.Map)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.io.File)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneData(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneInfoMap(java.io.InputStream)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.openResource(java.lang.String)</inbound>
            <feature confirmed="no">
                <name>java.io.IOException.IOException(java.lang.String)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.readFrom(java.io.DataInput, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.DataInput, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.readZoneInfoMap(java.io.DataInputStream, java.util.Map)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.io.File)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.openResource(java.lang.String)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.io.InputStream</name>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.InputStream, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.io.File)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneData(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneInfoMap(java.io.InputStream)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.openResource(java.lang.String)</inbound>
            <feature confirmed="no">
                <name>java.io.InputStream.close()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneData(java.lang.String)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.io.ObjectInputStream</name>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone$Stub.readObject(java.io.ObjectInputStream)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.readObject(java.io.ObjectInputStream)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology$Stub.readObject(java.io.ObjectInputStream)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.readObject(java.io.ObjectInputStream)</inbound>
            <feature confirmed="no">
                <name>java.io.ObjectInputStream.defaultReadObject()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.readObject(java.io.ObjectInputStream)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.readObject(java.io.ObjectInputStream)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.io.ObjectInputStream.readObject()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology$Stub.readObject(java.io.ObjectInputStream)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.io.ObjectInputStream.readUTF()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone$Stub.readObject(java.io.ObjectInputStream)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.io.ObjectOutputStream</name>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone$Stub.writeObject(java.io.ObjectOutputStream)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology$Stub.writeObject(java.io.ObjectOutputStream)</inbound>
            <feature confirmed="no">
                <name>java.io.ObjectOutputStream.writeObject(java.lang.Object)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology$Stub.writeObject(java.io.ObjectOutputStream)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.io.ObjectOutputStream.writeUTF(java.lang.String)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone$Stub.writeObject(java.io.ObjectOutputStream)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.io.ObjectStreamException</name>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone$Stub.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.writeReplace()</inbound>
        </class>
        <class confirmed="no">
            <name>java.io.OutputStream</name>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeTo(java.io.OutputStream)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            <feature confirmed="no">
                <name>java.io.OutputStream.close()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.io.PrintStream</name>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.printUsage()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
            <feature confirmed="no">
                <name>java.io.PrintStream.println(java.lang.String)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.printUsage()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.io.Reader</name>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
        </class>
        <class confirmed="no">
            <name>java.io.Serializable</name>
            <inbound type="class" confirmed="yes">org.joda.time.AbstractDateTime</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.AbstractDuration</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.AbstractPartialInstant</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.DateOnly</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.DateTime</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.DateTimeComparator</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.DateTimeZone</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.DateTimeZone$Stub</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.Duration</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.DurationType</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.Instant</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.Interval</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.MutableDateOnly</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.MutableDateTime</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.MutableDuration</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.MutableInterval</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.MutableTimeOnly</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.TimeOnly</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.AbstractChronology</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology$Stub</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.AbstractDateTimeField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.AbstractDurationField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.DelegatedDateTimeField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.DelegatedDurationField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.MillisDurationField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty</inbound>
        </class>
        <class confirmed="no">
            <name>java.io.Writer</name>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.io.Writer, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.io.Writer, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.printTo(java.io.Writer, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.printTo(java.io.Writer, long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.printTo(java.io.Writer, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.io.Writer, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.io.Writer, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.lang.StringBuffer, java.io.Writer, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.io.Writer, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.io.Writer, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.printTo(java.io.Writer, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix.printTo(java.io.Writer, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.printTo(java.io.Writer, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix.printTo(java.io.Writer, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationPrinter.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writePaddedInteger(java.io.Writer, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writePaddedInteger(java.io.Writer, long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writeUnpaddedInteger(java.io.Writer, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writeUnpaddedInteger(java.io.Writer, long)</inbound>
            <feature confirmed="no">
                <name>java.io.Writer.write(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.lang.StringBuffer, java.io.Writer, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writePaddedInteger(java.io.Writer, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writePaddedInteger(java.io.Writer, long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writeUnpaddedInteger(java.io.Writer, int)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.io.Writer.write(java.lang.String)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.lang.StringBuffer, java.io.Writer, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.printTo(java.io.Writer, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix.printTo(java.io.Writer, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writePaddedInteger(java.io.Writer, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writePaddedInteger(java.io.Writer, long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writeUnpaddedInteger(java.io.Writer, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writeUnpaddedInteger(java.io.Writer, long)</inbound>
            </feature>
        </class>
    </package>
    <package confirmed="no">
        <name>java.lang</name>
        <class confirmed="no">
            <name>java.lang.ArithmeticException</name>
            <feature confirmed="no">
                <name>java.lang.ArithmeticException.ArithmeticException(java.lang.String)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.safeAdd(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.safeMultiply(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.safeToInt(long)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.lang.ArrayIndexOutOfBoundsException</name>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.readFrom(java.io.DataInput, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.readZoneInfoMap(java.io.DataInputStream, java.util.Map)</inbound>
        </class>
        <class confirmed="no">
            <name>java.lang.Character</name>
            <feature confirmed="no">
                <name>java.lang.Character.isLetter(char)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.Character.isWhitespace(char)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.Character.toLowerCase(char)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.Character.toUpperCase(char)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.lang.Class</name>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultNameProvider()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultProvider()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.AbstractGJChronology(org.joda.time.Chronology, java.lang.Object, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.getSupportedType()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.class$(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.class$java$util$Calendar</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getSupportedType()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.Converter.getSupportedType()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getDurationConverter(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstantConverter(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getIntervalConverter(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet$Entry.ConverterSet$Entry(java.lang.Class, org.joda.time.convert.Converter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet$Entry.iType</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.add(org.joda.time.convert.Converter, org.joda.time.convert.Converter[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.select(java.lang.Class)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.selectSlow(org.joda.time.convert.ConverterSet, java.lang.Class)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.DateConverter.class$(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.DateConverter.class$java$util$Date</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.DateConverter.getSupportedType()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.class$(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.class$java$lang$Long</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.getSupportedType()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.class$(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.class$org$joda$time$PartialInstant</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.getSupportedType()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.class$(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.class$org$joda$time$ReadableDuration</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.getSupportedType()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.class$(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.class$org$joda$time$ReadableInstant</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.getSupportedType()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.class$(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.class$org$joda$time$ReadableInterval</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.getSupportedType()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.class$(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.class$java$lang$String</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getSupportedType()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader, boolean)</inbound>
            <feature confirmed="no">
                <name>java.lang.Class.forName(java.lang.String)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultNameProvider()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultProvider()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.class$(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.DateConverter.class$(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.class$(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.class$(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.class$(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.class$(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.class$(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.class$(java.lang.String)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.Class.getClassLoader()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader, boolean)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.Class.getName()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.AbstractGJChronology(org.joda.time.Chronology, java.lang.Object, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getDurationConverter(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstantConverter(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getIntervalConverter(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.selectSlow(org.joda.time.convert.ConverterSet, java.lang.Class)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.Class.isAssignableFrom(java.lang.Class)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.selectSlow(org.joda.time.convert.ConverterSet, java.lang.Class)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.Class.newInstance()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultNameProvider()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultProvider()</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.lang.ClassCastException</name>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDatePattern(char)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDateTimePattern(char, char)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getTimePattern(char)</inbound>
        </class>
        <class confirmed="no">
            <name>java.lang.ClassLoader</name>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.io.File)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.iLoader</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.openResource(java.lang.String)</inbound>
            <feature confirmed="no">
                <name>java.lang.ClassLoader.getResourceAsStream(java.lang.String)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.openResource(java.lang.String)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.ClassLoader.getSystemResourceAsStream(java.lang.String)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.openResource(java.lang.String)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.lang.ClassNotFoundException</name>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.readObject(java.io.ObjectInputStream)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology$Stub.readObject(java.io.ObjectInputStream)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.class$(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.DateConverter.class$(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.class$(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.class$(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.class$(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.class$(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.class$(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.class$(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.readObject(java.io.ObjectInputStream)</inbound>
        </class>
        <class confirmed="no">
            <name>java.lang.CloneNotSupportedException</name>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.clone()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.clone()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.clone()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.clone()</inbound>
        </class>
        <class confirmed="no">
            <name>java.lang.Cloneable</name>
            <inbound type="class" confirmed="yes">org.joda.time.MutableDateOnly</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.MutableDateTime</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.MutableDuration</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.MutableTimeOnly</inbound>
        </class>
        <class confirmed="no">
            <name>java.lang.Comparable</name>
            <inbound type="class" confirmed="yes">org.joda.time.DurationField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.ReadableDuration</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.ReadableInstant</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.compareReverse(java.lang.Comparable, java.lang.Comparable)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.compareTo(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.computeMillis()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.sort(java.lang.Comparable[], int)</inbound>
            <feature confirmed="no">
                <name>java.lang.Comparable.compareTo(java.lang.Object)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.compareReverse(java.lang.Comparable, java.lang.Comparable)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.sort(java.lang.Comparable[], int)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.lang.Exception</name>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultNameProvider()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultProvider()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.addToBuilder(org.joda.time.tz.ZoneInfoCompiler$Zone, org.joda.time.tz.DateTimeZoneBuilder, java.util.Map)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.main(java.lang.String[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneData(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.uncaughtException(java.lang.Exception)</inbound>
        </class>
        <class confirmed="no">
            <name>java.lang.IllegalArgumentException</name>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.toString(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.toString(java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateOnlyMillis(int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeMillis(long, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.getTimeOnlyMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableDateTime.toString(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableDateTime.toString(java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateOnlyMillis(int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateTimeMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateOnlyMillis(int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateTimeMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateOnlyMillis(int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getDateOnlyMillis(int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateOnlyMillis(int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getDateOnlyMillis(int, int, int)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getDateOnlyMillis(int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getDateTimeMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getDateOnlyMillis(int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getDateTimeMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeFormatter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimePrinter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.append(org.joda.time.format.DurationFormatter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.findMatchingRecurrence(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.nextTransition(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.previousTransition(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonthNext(org.joda.time.Chronology, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonthPrevious(org.joda.time.Chronology, long)</inbound>
            <feature confirmed="no">
                <name>java.lang.IllegalArgumentException.IllegalArgumentException()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.ZonedChronology$ZonedDateTimeField(org.joda.time.DateTimeField, org.joda.time.DateTimeZone, org.joda.time.DurationField, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.ZonedChronology$ZonedDurationField(org.joda.time.DurationField, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.add(org.joda.time.convert.Converter, org.joda.time.convert.Converter[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.UnsupportedDateTimeField(java.lang.String, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.DateTimeFormatterBuilder$TimeZoneOffsetFormatter(org.joda.time.Chronology, java.lang.String, boolean, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDecimal(org.joda.time.DateTimeField, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFraction(org.joda.time.DateTimeField, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendSignedDecimal(org.joda.time.DateTimeField, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendPrefix(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendPrefix(java.lang.String, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendPrefix(org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeparator(java.lang.String, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSuffix(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSuffix(java.lang.String, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.DateTimeZoneBuilder$PrecalculatedZone(java.lang.String, java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$DSTZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.ZoneInfoCompiler$Rule(java.util.StringTokenizer)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.add(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.isEqual(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.isLongerThan(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.isShorterThan(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.get(org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.isAfter(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.isBefore(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.isEqual(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableDuration, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInterval)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.contains(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.contains(org.joda.time.ReadableInterval)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.isAfter(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.isBefore(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.overlaps(org.joda.time.ReadableInterval)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setDurationAfterStart(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setDurationBeforeEnd(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.selectChronologyUTC(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.DateTimeZone(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.util.TimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setDefault(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setProvider0(org.joda.time.tz.Provider)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getAverageYearMonthType(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.setEndInstant(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.setStartInstant(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.AbstractGJChronology(org.joda.time.Chronology, java.lang.Object, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearOverflow(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.dayOfWeekTextToValue(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.eraTextToValue(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.halfdayTextToValue(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.monthOfYearTextToValue(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.adjustYearForSet(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.getInstance(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.LimitChronology$LimitException(org.joda.time.chrono.LimitChronology, java.lang.String, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getInstance(org.joda.time.Chronology, org.joda.time.ReadableDateTime, org.joda.time.ReadableDateTime)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.getInstance(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getInstance(org.joda.time.Chronology, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.localToUTC(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getDurationConverter(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstantConverter(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getIntervalConverter(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.AbstractDateTimeField(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.AbstractDurationField(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.DecoratedDateTimeField(org.joda.time.DateTimeField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.DecoratedDurationField(org.joda.time.DurationField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.DelegatedDateTimeField(org.joda.time.DateTimeField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.DelegatedDurationField(org.joda.time.DurationField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.DateTimeField, java.lang.String, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.getWrappedValue(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(java.lang.String, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeField, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.NonZeroDateTimeField(org.joda.time.DateTimeField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(org.joda.time.DateTimeField, java.lang.String, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.PreciseDateTimeField(java.lang.String, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.PreciseDurationDateTimeField(java.lang.String, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(org.joda.time.DateTimeField, java.lang.String, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.ScaledDurationField(org.joda.time.DurationField, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseMillis(java.lang.String, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.parseMutableDuration(org.joda.time.DurationType, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDatePattern(char)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDateTimePattern(char, char)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getPatternForStyle(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getTimePattern(char)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.selectStyle(char)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeFormatter)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeParser)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimePrinter)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDecimal(org.joda.time.DateTimeField, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFraction(org.joda.time.DateTimeField, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendOptional(org.joda.time.format.DateTimeParser)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendSignedDecimal(org.joda.time.DateTimeField, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.computeMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.append(org.joda.time.format.DurationFormatter)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendLiteral(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.compareTo(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getDifference(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getDifferenceAsLong(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.DateTimeZoneBuilder$OfYear(char, int, int, int, boolean, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.DateTimeZoneBuilder$PrecalculatedZone(java.lang.String, java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$DSTZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.addRule(org.joda.time.tz.ZoneInfoCompiler$Rule)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.addToBuilder(org.joda.time.tz.ZoneInfoCompiler$Zone, org.joda.time.tz.DateTimeZoneBuilder, java.util.Map)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseTime(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.io.File)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader, boolean)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.lang.IllegalStateException</name>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.select(java.lang.Class)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.clearPrefix()</inbound>
            <feature confirmed="no">
                <name>java.lang.IllegalStateException.IllegalStateException(java.lang.String)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getTotalMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.selectSlow(org.joda.time.convert.ConverterSet, java.lang.Class)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSuffix(org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.clearPrefix()</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.lang.IndexOutOfBoundsException</name>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.main(java.lang.String[])</inbound>
            <feature confirmed="no">
                <name>java.lang.IndexOutOfBoundsException.IndexOutOfBoundsException()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.remove(int, org.joda.time.convert.Converter[])</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.lang.Integer</name>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.AbstractGJChronology(org.joda.time.Chronology, java.lang.Object, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.static {}</inbound>
            <feature confirmed="no">
                <name>java.lang.Integer.getInteger(java.lang.String)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.AbstractGJChronology(org.joda.time.Chronology, java.lang.Object, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.static {}</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.Integer.intValue()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.AbstractGJChronology(org.joda.time.Chronology, java.lang.Object, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.static {}</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.Integer.parseInt(java.lang.String)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.ZoneInfoCompiler$Zone(java.lang.String, java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseYear(java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.Integer.toString(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getAsText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.lang.StringBuffer, java.io.Writer, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.appendPaddedInteger(java.lang.StringBuffer, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.appendUnpaddedInteger(java.lang.StringBuffer, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writePaddedInteger(java.io.Writer, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writeUnpaddedInteger(java.io.Writer, int)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.lang.InternalError</name>
            <feature confirmed="no">
                <name>java.lang.InternalError.InternalError(java.lang.String)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.clone()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.clone()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.clone()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.clone()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.lang.Long</name>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.getDurationMillis(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.getInstantMillis(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
            <feature confirmed="no">
                <name>java.lang.Long.Long(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.Long.longValue()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.getDurationMillis(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.getInstantMillis(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.Long.toString(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.lang.StringBuffer, java.io.Writer, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.appendPaddedInteger(java.lang.StringBuffer, long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.appendUnpaddedInteger(java.lang.StringBuffer, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writePaddedInteger(java.io.Writer, long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writeUnpaddedInteger(java.io.Writer, long)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.lang.Math</name>
            <feature confirmed="no">
                <name>java.lang.Math.abs(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.Math.abs(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.add(long, long)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.Math.log(double)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.appendPaddedInteger(java.lang.StringBuffer, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.appendPaddedInteger(java.lang.StringBuffer, long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.calculateDigitCount(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writePaddedInteger(java.io.Writer, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writePaddedInteger(java.io.Writer, long, int)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.Math.max(int, int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMaximumShortTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMaximumTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.Math.min(int, int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.digitCount(java.lang.String, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.lang.NoClassDefFoundError</name>
            <feature confirmed="no">
                <name>java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.class$(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.DateConverter.class$(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.class$(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.class$(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.class$(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.class$(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.class$(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.class$(java.lang.String)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.lang.NumberFormatException</name>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear(java.util.StringTokenizer)</inbound>
        </class>
        <class confirmed="no">
            <name>java.lang.Object</name>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.setMillis(java.lang.Object)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.AbstractDuration</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.compareTo(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.equals(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.isEqual(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.isLongerThan(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.isShorterThan(org.joda.time.ReadableDuration)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.AbstractInstant</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.compareTo(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.equals(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateOnly()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateOnly(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toTimeOnly()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toTimeOnly(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toTrustedISODateTime()</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.AbstractInterval</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.equals(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.equals(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.equals(java.lang.Object, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.isMatchingType(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.selectChronologyUTC(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.setMillis(java.lang.Object)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.Chronology</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.DateOnly(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.DateOnly(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.DateTimeComparator</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.compare(java.lang.Object, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.getMillisFromObject(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.readResolve()</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.DateTimeConstants</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.DateTimeField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.DateTimeZone</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.DateTimeZone$Stub</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone$Stub.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.equals(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getConvertedId(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultNameProvider()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultProvider()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.util.TimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setProvider0(org.joda.time.tz.Provider)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.writeReplace()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Duration.Duration(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Duration.Duration(org.joda.time.DurationType, java.lang.Object)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.DurationField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationField.compareTo(java.lang.Object)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.DurationType</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.DurationType$1</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$AverageYearMonthType.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MillisType.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearMonthType.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearWeekType.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearMonthType.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearWeekType.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.equals(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getAverageYearMonthType(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Instant.Instant(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Interval.Interval(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.MutableDateOnly(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.MutableDateOnly(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.add(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.clone()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.copy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setDate(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setMillis(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.add(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.clone()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.copy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDate(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDateTime(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setTime(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.MutableDuration(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.MutableDuration(org.joda.time.DurationType, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.clone()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.copy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.MutableInterval(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.MutableTimeOnly(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.MutableTimeOnly(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.add(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.clone()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.copy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillis(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setTime(java.lang.Object)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.PartialInstant</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.PartialInstant.equals(java.lang.Object)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.ReadWritableDateTime</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadWritableDateTime.setDate(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadWritableDateTime.setDateTime(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadWritableDateTime.setTime(java.lang.Object)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.ReadWritableDuration</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadWritableInstant.add(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadWritableInstant.setMillis(java.lang.Object)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.ReadWritableInterval</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.ReadableDateTime</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.ReadableDuration</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.compareTo(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.equals(java.lang.Object)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.ReadableInstant</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.compareTo(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.equals(java.lang.Object)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.ReadableInterval</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableInterval.equals(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.TimeOnly(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.TimeOnly(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.AbstractChronology</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$YearInfo</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.AbstractGJChronology(org.joda.time.Chronology, java.lang.Object, int)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.AssembledChronology(org.joda.time.Chronology, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getParam()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iParam</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.BuddhistChronology(org.joda.time.Chronology, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.CopticChronology(org.joda.time.Chronology, java.lang.Object, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticDayOfMonthDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.GJChronology(org.joda.time.Chronology, org.joda.time.chrono.JulianChronology, org.joda.time.chrono.GregorianChronology, org.joda.time.Instant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.GJChronology(org.joda.time.chrono.JulianChronology, org.joda.time.chrono.GregorianChronology, org.joda.time.Instant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfMonthDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfYearDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.readResolve()</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.forLocale(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.GregorianChronology(org.joda.time.Chronology, java.lang.Object, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.readResolve()</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology$Stub</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology$Stub.readObject(java.io.ObjectInputStream)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology$Stub.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology$Stub.writeObject(java.io.ObjectOutputStream)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.ISOChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.writeReplace()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoWeekyearZeroField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoYearZeroField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.JulianChronology(org.joda.time.Chronology, java.lang.Object, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.LenientChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.getMessage()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.LimitChronology(org.joda.time.Chronology, org.joda.time.DateTime, org.joda.time.DateTime)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.convertField(org.joda.time.DurationField, java.util.HashMap)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.StrictChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.ZonedChronology(org.joda.time.Chronology, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DurationField, java.util.HashMap)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getDateTimeZone()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.convert.AbstractConverter</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.getChronology(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.getChronology(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.getInstantMillis(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.getInstantMillis(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.getInstantMillis(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getInstantMillis(java.lang.Object)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.convert.Converter</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.convert.ConverterManager</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getDurationConverter(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstantConverter(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getIntervalConverter(java.lang.Object)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.convert.ConverterSet</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.convert.ConverterSet$Entry</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.add(org.joda.time.convert.Converter, org.joda.time.convert.Converter[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.copyInto(org.joda.time.convert.Converter[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.remove(org.joda.time.convert.Converter, org.joda.time.convert.Converter[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.select(java.lang.Class)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.DateConverter.getInstantMillis(java.lang.Object)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.convert.DurationConverter</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.DurationConverter.getDurationMillis(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.DurationConverter.getDurationType(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.DurationConverter.isPrecise(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.DurationConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.convert.InstantConverter</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.InstantConverter.getChronology(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.InstantConverter.getChronology(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.InstantConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.InstantConverter.getInstantMillis(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.InstantConverter.getInstantMillis(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.InstantConverter.getInstantMillis(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.convert.IntervalConverter</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.IntervalConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.getDurationMillis(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.getDurationType(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.getInstantMillis(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.isPrecise(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.getChronology(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.getInstantMillis(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.getInstantMillis(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.getInstantMillis(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.getDurationMillis(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.getDurationType(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.isPrecise(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.getChronology(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.getInstantMillis(java.lang.Object)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.getDurationMillis(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.getDurationType(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.isPrecise(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getDurationMillis(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getDurationType(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getInstantMillis(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getInstantMillis(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.isPrecise(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.AbstractDateTimeField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.AbstractDurationField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.compareTo(java.lang.Object)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.DelegatedDateTimeField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.DelegatedDurationField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.compareTo(java.lang.Object)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.FieldUtils</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.MillisDurationField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.MillisDurationField.compareTo(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.MillisDurationField.readResolve()</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.readResolve()</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.compareTo(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getInstance(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.readResolve()</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.AbstractDurationFormatter</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormat</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forStyle(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDatePattern(char)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDateTimePattern(char, char)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.Chronology, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getTimePattern(char)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.DateTimeFormatterBuilder$Composite(org.joda.time.Chronology, java.util.ArrayList)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$MatchingParser.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeFormatter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append0(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append0(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDecimal(org.joda.time.DateTimeField, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFraction(org.joda.time.DateTimeField, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(char)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendShortText(org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendSignedDecimal(org.joda.time.DateTimeField, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendText(org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneOffset(java.lang.String, boolean, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.canBuildFormatter()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.canBuildParser()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.canBuildPrinter()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.clear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.getFormatter()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iFormatter</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.isFormatter(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.isParser(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.isPrinter(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toParser()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toPrinter()</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeParserBucket</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.compareReverse(java.lang.Comparable, java.lang.Comparable)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.compareTo(java.lang.Object)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.computeMillis()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iSavedState</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.restoreState(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.saveField(org.joda.time.format.DateTimeParserBucket$SavedField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.saveState()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.setDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.setOffset(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.sort(java.lang.Comparable[], int)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DurationFormat</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.DurationFormatterBuilder$AlternateSelector(org.joda.time.format.DurationFormatter, java.util.List, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.DurationFormatterBuilder$Composite(java.util.List)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.append(org.joda.time.format.DurationFormatter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendField(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendLiteral(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeparator(java.lang.String, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSuffix(org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.createComposite(java.util.List)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toFormatter()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toFormatter(java.util.List)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DurationParser</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DurationPrinter</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.FormatUtils</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.ISODateTimeFormat</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance(org.joda.time.Chronology)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.ISODurationFormat</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.equals(java.lang.Object)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.equals(java.lang.Object)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.equals(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.DateTimeZoneBuilder$PrecalculatedZone(java.lang.String, java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$DSTZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.equals(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.writeTo(java.io.DataOutput)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.equals(java.lang.Object)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.addRule(org.joda.time.tz.DateTimeZoneBuilder$Rule)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.buildTailZone(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.firstTransition(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.nextTransition(long, int)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.isTransitionFrom(org.joda.time.tz.DateTimeZoneBuilder$Transition)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addCutover(int, char, int, int, int, boolean, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addTransition(java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$Transition)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.buildFixedZone(java.lang.String, java.lang.String, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.getLastRuleSet()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.DataInput, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(java.lang.String)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.tz.DefaultNameProvider</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DefaultNameProvider.getNameSet(java.util.Locale, java.lang.String, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.FixedDateTimeZone.equals(java.lang.Object)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.tz.NameProvider</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.tz.Provider</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.tz.UTCProvider</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.UTCProvider.getAvailableIDs()</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.toString()</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.ZoneInfoCompiler$RuleSet(org.joda.time.tz.ZoneInfoCompiler$Rule)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.addRule(org.joda.time.tz.ZoneInfoCompiler$Rule)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.addToBuilder(org.joda.time.tz.ZoneInfoCompiler$Zone, org.joda.time.tz.DateTimeZoneBuilder, java.util.Map)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.main(java.lang.String[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseOptional(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseYear(java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.readZoneInfoMap(java.io.DataInputStream, java.util.Map)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.tz.ZoneInfoProvider</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.io.File)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.getDateTimeZone(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneData(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneInfoMap(java.io.InputStream)</inbound>
            <feature confirmed="no">
                <name>java.lang.Object.Object()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.AbstractInstant()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableDuration, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInterval)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.DateTimeComparator(org.joda.time.DateTimeField, org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeConstants.DateTimeConstants()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone$Stub.DateTimeZone$Stub(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.DateTimeZone(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.DurationType()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.AbstractChronology()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$YearInfo.AbstractGJChronology$YearInfo(int, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.AssembledChronology$Fields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology$Stub.ISOChronology$Stub(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.AbstractConverter()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.ConverterManager()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet$Entry.ConverterSet$Entry(java.lang.Class, org.joda.time.convert.Converter)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.ConverterSet(org.joda.time.convert.Converter[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.ReadableIntervalConverter()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.AbstractDateTimeField(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.AbstractDurationField(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.DelegatedDateTimeField(org.joda.time.DateTimeField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.DelegatedDurationField(org.joda.time.DurationField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.FieldUtils()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.MillisDurationField.MillisDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.UnsupportedDateTimeField(java.lang.String, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.UnsupportedDurationField(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.AbstractDateTimeFormatter()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.AbstractDurationFormatter()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.DateTimeFormat$FParser(org.joda.time.format.DateTimeParser)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.DateTimeFormat$FPrinter(org.joda.time.format.DateTimePrinter)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.DateTimeFormat(org.joda.time.Chronology, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.DateTimeParserBucket$SavedField(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.DateTimeParserBucket$SavedField(org.joda.time.DateTimeField, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.DateTimeParserBucket$SavedState(org.joda.time.format.DateTimeParserBucket)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.DateTimeParserBucket(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormat.DurationFormat()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.DurationFormatterBuilder$CompositeAffix(org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.DurationFormatterBuilder$PluralAffix(java.lang.String, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix.DurationFormatterBuilder$SingularAffix(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.DurationFormatterBuilder()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.FormatUtils()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.ISODateTimeFormat(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.ISODurationFormat()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.AbstractReadableInstantFieldProperty()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.CachedDateTimeZone$Info(org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.DateTimeZoneBuilder$OfYear(char, int, int, int, boolean, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.DateTimeZoneBuilder$Recurrence(org.joda.time.tz.DateTimeZoneBuilder$OfYear, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.DateTimeZoneBuilder$Rule(org.joda.time.tz.DateTimeZoneBuilder$Recurrence, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.DateTimeZoneBuilder$RuleSet()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.DateTimeZoneBuilder$RuleSet(org.joda.time.tz.DateTimeZoneBuilder$RuleSet)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.DateTimeZoneBuilder$Transition(long, java.lang.String, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.DateTimeZoneBuilder$Transition(long, org.joda.time.tz.DateTimeZoneBuilder$Rule, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.DateTimeZoneBuilder$Transition(long, org.joda.time.tz.DateTimeZoneBuilder$Transition)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.DateTimeZoneBuilder()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DefaultNameProvider.DefaultNameProvider()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.UTCProvider.UTCProvider()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.ZoneInfoCompiler$Rule(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.ZoneInfoCompiler$RuleSet(org.joda.time.tz.ZoneInfoCompiler$Rule)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.ZoneInfoCompiler$Zone(java.lang.String, java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.ZoneInfoCompiler()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.io.File)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader, boolean)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.Object.clone()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.clone()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.clone()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.clone()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.clone()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.select(java.lang.Class)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.computeMillis()</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.Object.equals(java.lang.Object)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.equals(java.lang.Object, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getAverageYearMonthType(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.add(org.joda.time.convert.Converter, org.joda.time.convert.Converter[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.remove(org.joda.time.convert.Converter, org.joda.time.convert.Converter[])</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.Object.getClass()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.AbstractGJChronology(org.joda.time.Chronology, java.lang.Object, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getDurationConverter(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstantConverter(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getIntervalConverter(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.selectSlow(org.joda.time.convert.ConverterSet, java.lang.Class)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader, boolean)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.Object.hashCode()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.hashCode()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.hashCode()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.hashCode()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.select(java.lang.Class)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.Object.toString()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.openResource(java.lang.String)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.lang.Object[]</name>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
        </class>
        <class confirmed="no">
            <name>java.lang.RuntimeException</name>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.lang.StringBuffer, java.io.Writer, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.estimatePrintedLength()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
        </class>
        <class confirmed="no">
            <name>java.lang.SecurityException</name>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultNameProvider()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultProvider()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setDefault(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setNameProvider(org.joda.time.tz.NameProvider)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setProvider(org.joda.time.tz.Provider)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.AbstractGJChronology(org.joda.time.Chronology, java.lang.Object, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.static {}</inbound>
        </class>
        <class confirmed="no">
            <name>java.lang.SecurityManager</name>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setDefault(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setNameProvider(org.joda.time.tz.NameProvider)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setProvider(org.joda.time.tz.Provider)</inbound>
            <feature confirmed="no">
                <name>java.lang.SecurityManager.checkPermission(java.security.Permission)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setDefault(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setNameProvider(org.joda.time.tz.NameProvider)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setProvider(org.joda.time.tz.Provider)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.lang.Short</name>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
            <feature confirmed="no">
                <name>java.lang.Short.Short(short)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.Short.shortValue()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.lang.String</name>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.toString(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.toString(java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.add(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.checkPrecise(org.joda.time.DurationField, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.checkSupport(org.joda.time.DurationField, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getTotalMillis()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.isEqual(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.isLongerThan(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.isShorterThan(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDays(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setHours(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setMillis(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setMinutes(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setMonths(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setSeconds(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setWeeks(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setYears(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.get(org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.isAfter(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.isBefore(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.isEqual(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toTrustedISODateTime()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableDuration, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInterval)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.contains(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.contains(org.joda.time.ReadableInterval)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.isAfter(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.isBefore(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.overlaps(org.joda.time.ReadableInterval)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setDurationAfterStart(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setDurationBeforeEnd(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.selectChronologyUTC(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getAsShortText(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getAsShortText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getAsText(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getName()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeField.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone$Stub.DateTimeZone$Stub(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone$Stub.iID</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone$Stub.readObject(java.io.ObjectInputStream)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone$Stub.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone$Stub.writeObject(java.io.ObjectOutputStream)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.DateTimeZone(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getConvertedId(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultNameProvider()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultProvider()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getID()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.util.TimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getName(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getName(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getNameKey(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getShortName(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getShortName(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.hashCode()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.iID</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.offsetFormatter()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setDefault(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setNameProvider(org.joda.time.tz.NameProvider)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setProvider(org.joda.time.tz.Provider)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setProvider0(org.joda.time.tz.Provider)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.toTimeZone()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.writeReplace()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationField.getName()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationField.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$AverageYearMonthType.DurationType$AverageYearMonthType(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearMonthType.DurationType$PreciseYearMonthType(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearWeekType.DurationType$PreciseYearWeekType(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getAverageYearMonthType(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Instant.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.clone()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.clone()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.clone()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.setEndInstant(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.setStartInstant(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.clone()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.PartialInstant.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableDateTime.toString(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableDateTime.toString(java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableInterval.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.centuries()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.centuryOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.clockhourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.clockhourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.dayOfMonth()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.dayOfWeek()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.dayOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.days()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.era()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.eras()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.halfdayOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.hourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.hourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.hours()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.millis()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.millisOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.millisOfSecond()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.minuteOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.minuteOfHour()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.minutes()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.monthOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.months()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.secondOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.secondOfMinute()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.seconds()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.weekOfWeekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.weeks()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.weekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.weekyears()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.year()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.yearOfCentury()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.yearOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.years()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$HalfdayField.AbstractGJChronology$HalfdayField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$HalfdayField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$HalfdayField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.AbstractGJChronology(org.joda.time.Chronology, java.lang.Object, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateOnlyMillis(int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateTimeMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearOverflow(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.BuddhistEraDateTimeField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getDateOnlyMillis(int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticDayOfMonthDateTimeField.CopticDayOfMonthDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.CopticEraDateTimeField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.CopticMonthOfYearDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.CopticYearDateTimeField(org.joda.time.chrono.AbstractGJChronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, long, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getAsShortText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$LinkedDurationField.GJChronology$LinkedDurationField(org.joda.time.DurationField, org.joda.time.chrono.GJChronology$ImpreciseCutoverField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfMonthDateTimeField.GJDayOfMonthDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.GJDayOfWeekDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfYearDateTimeField.GJDayOfYearDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.GJEraDateTimeField(org.joda.time.chrono.AbstractGJChronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.dayOfWeekTextToValue(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.dayOfWeekValueToShortText(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.dayOfWeekValueToText(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.eraTextToValue(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.eraValueToText(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.halfdayTextToValue(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.halfdayValueToText(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iDaysOfWeek</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iEras</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iHalfday</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iMonths</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iShortDaysOfWeek</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iShortMonths</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.maxLength(java.lang.String[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.monthOfYearTextToValue(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.monthOfYearValueToShortText(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.monthOfYearValueToText(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.realignDaysOfWeek(java.lang.String[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.realignMonths(java.lang.String[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.GJMonthOfYearDateTimeField(org.joda.time.chrono.AbstractGJChronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.add(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.GJWeekOfWeekyearDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.GJWeekyearDateTimeField(org.joda.time.chrono.AbstractGJChronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.GJYearDateTimeField(org.joda.time.chrono.AbstractGJChronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.GJYearOfEraDateTimeField(org.joda.time.DateTimeField, org.joda.time.chrono.AbstractGJChronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.ISOYearOfEraDateTimeField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.adjustYearForSet(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.getInstance(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.LimitChronology$LimitDateTimeField(org.joda.time.chrono.LimitChronology, org.joda.time.DateTimeField, org.joda.time.DurationField, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.add(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.add(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.addWrapped(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.get(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getDifference(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getDifferenceAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getLeapAmount(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getMaximumValue(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getMinimumValue(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.isLeap(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.remainder(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundCeiling(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundFloor(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundHalfCeiling(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundHalfEven(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundHalfFloor(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.LimitChronology$LimitDurationField(org.joda.time.chrono.LimitChronology, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.add(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.add(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getDifference(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getDifferenceAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getMillis(int, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getMillis(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getValue(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getValueAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.LimitChronology$LimitException(org.joda.time.chrono.LimitChronology, java.lang.String, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.getMessage()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getDateOnlyMillis(int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getDateOnlyMillis(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getDateTimeMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getInstance(org.joda.time.Chronology, org.joda.time.ReadableDateTime, org.joda.time.ReadableDateTime)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getTimeOnlyMillis(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.getInstance(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.ZonedChronology$ZonedDateTimeField(org.joda.time.DateTimeField, org.joda.time.DateTimeZone, org.joda.time.DurationField, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.ZonedChronology$ZonedDurationField(org.joda.time.DurationField, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getInstance(org.joda.time.Chronology, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.localToUTC(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.class$(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getSupportedType()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getDurationConverter(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstantConverter(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getIntervalConverter(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.selectSlow(org.joda.time.convert.ConverterSet, java.lang.Class)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.DateConverter.class$(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.DateConverter.getSupportedType()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.class$(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.getSupportedType()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.class$(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.getSupportedType()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.class$(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.getSupportedType()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.class$(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.getSupportedType()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.class$(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.getSupportedType()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.class$(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getDurationType(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getInstantMillis(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getInstantMillis(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getSupportedType()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.AbstractDateTimeField(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getAsShortText(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getAsText(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getName()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.iName</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.set(long, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.AbstractDurationField(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.getName()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.iName</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.DecoratedDateTimeField(org.joda.time.DateTimeField, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.DecoratedDurationField(org.joda.time.DurationField, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.DelegatedDateTimeField(org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.DelegatedDateTimeField(org.joda.time.DateTimeField, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getAsShortText(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getAsText(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getName()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iName</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.set(long, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.DelegatedDurationField(org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.DelegatedDurationField(org.joda.time.DurationField, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getName()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.iName</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.DateTimeField, java.lang.String, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.field.RemainderDateTimeField, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.getWrappedValue(int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.safeAdd(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.safeMultiply(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.safeToInt(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(java.lang.String, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeField, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.ImpreciseDateTimeField$LinkedDurationField(org.joda.time.field.ImpreciseDateTimeField, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.ImpreciseDateTimeField(java.lang.String, java.lang.String, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.MillisDurationField.getName()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.MillisDurationField.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.NonZeroDateTimeField(org.joda.time.DateTimeField, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(org.joda.time.DateTimeField, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(org.joda.time.DateTimeField, java.lang.String, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.PreciseDateTimeField(java.lang.String, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.PreciseDurationDateTimeField(java.lang.String, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationField.PreciseDurationField(java.lang.String, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(org.joda.time.DateTimeField, java.lang.String, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(org.joda.time.field.DividedDateTimeField, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.ScaledDurationField(org.joda.time.DurationField, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.UnsupportedDateTimeField(java.lang.String, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getAsShortText(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getAsText(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getName()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.iName</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.set(long, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.unsupported()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.UnsupportedDurationField(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getInstance(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getName()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.iName</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.unsupported()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.createErrorMessage(java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseDateTime(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseMillis(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseMillis(java.lang.String, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseMutableDateTime(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseMutableDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.print(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.print(long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.print(long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.print(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.parseDuration(org.joda.time.DurationType, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.parseMutableDuration(org.joda.time.DurationType, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.print(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseDateTime(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseMillis(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseMillis(java.lang.String, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseMutableDateTime(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseMutableDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.print(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.print(long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.print(long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.print(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.unsupported()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.parseDateTime(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.parseDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.parseMillis(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.parseMillis(java.lang.String, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.parseMutableDateTime(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.parseMutableDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.print(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.print(long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.print(long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.print(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.unsupported()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forStyle(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDatePattern(char)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDateTimePattern(char, char)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getPatternForStyle(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getTimePattern(char)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.isNumericToken(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.parseToken(java.lang.String, int[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.selectStyle(char)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.print(long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.lang.StringBuffer, java.io.Writer, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$MatchingParser.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.DateTimeFormatterBuilder$StringLiteral(org.joda.time.Chronology, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.estimateParsedLength()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.estimatePrintedLength()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.iValue</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.print(long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.print(long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.DateTimeFormatterBuilder$TimeZoneOffsetFormatter(org.joda.time.Chronology, java.lang.String, boolean, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.digitCount(java.lang.String, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.estimatePrintedLength()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.iZeroOffsetText</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.print(long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeFormatter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeParser)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimePrinter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDecimal(org.joda.time.DateTimeField, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFraction(org.joda.time.DateTimeField, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendOptional(org.joda.time.format.DateTimeParser)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendPattern(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendSignedDecimal(org.joda.time.DateTimeField, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneOffset(java.lang.String, boolean, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toParser()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toPrinter()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseDateTime(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseMillis(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseMillis(java.lang.String, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseMutableDateTime(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseMutableDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.DateTimeParserBucket$SavedField(org.joda.time.DateTimeField, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.DateTimeParserBucket$SavedField(org.joda.time.DateTimeField, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.iText</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.set(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.computeMillis()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.saveField(org.joda.time.DateTimeField, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.print(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.print(long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.print(long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.print(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormat.DurationFormat()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.parse(java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.scan(java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix.parse(java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix.scan(java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal.DurationFormatterBuilder$Literal(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal.iText</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.DurationFormatterBuilder$PluralAffix(java.lang.String, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.calculatePrintedLength(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.iPluralText</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.iSingularText</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.parse(java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.printTo(java.io.Writer, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.printTo(java.lang.StringBuffer, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.scan(java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.DurationFormatterBuilder$Separator(java.lang.String, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.DurationFormatterBuilder$Separator(java.lang.String, java.lang.String, org.joda.time.format.DurationFormatter, org.joda.time.format.DurationFormatter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.finish(org.joda.time.format.DurationFormatter, org.joda.time.format.DurationFormatter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.iFinalText</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.iText</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.merge(java.lang.String, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix.DurationFormatterBuilder$SingularAffix(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix.calculatePrintedLength(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix.iText</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix.parse(java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix.printTo(java.io.Writer, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix.printTo(java.lang.StringBuffer, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix.scan(java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.append(org.joda.time.format.DurationFormatter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendLiteral(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendPrefix(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendPrefix(java.lang.String, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeparator(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeparator(java.lang.String, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSuffix(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSuffix(java.lang.String, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSuffix(org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.clearPrefix()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationParser.parseDuration(org.joda.time.DurationType, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationParser.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationParser.parseMutableDuration(org.joda.time.DurationType, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationPrinter.print(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.appendPaddedInteger(java.lang.StringBuffer, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.appendPaddedInteger(java.lang.StringBuffer, long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.appendUnpaddedInteger(java.lang.StringBuffer, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.appendUnpaddedInteger(java.lang.StringBuffer, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.parseTwoDigits(java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writePaddedInteger(java.io.Writer, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writePaddedInteger(java.io.Writer, long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writeUnpaddedInteger(java.io.Writer, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writeUnpaddedInteger(java.io.Writer, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicTime()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.offsetElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternate()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtended()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtendedWithWeeks()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateWithWeeks()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.standard()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.compareTo(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getAsShortText()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getAsShortText(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getAsText()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getAsText(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getDifference(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getDifferenceAsLong(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getName()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.setCopy(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.setCopy(java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.setCopy(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.setCopy(java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.set(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.set(java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.setCopy(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.setCopy(java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.getNameKey(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.iNameKey</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.CachedDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.getNameKey(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.DateTimeZoneBuilder$DSTZone(java.lang.String, int, org.joda.time.tz.DateTimeZoneBuilder$Recurrence, org.joda.time.tz.DateTimeZoneBuilder$Recurrence)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.equals(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.getNameKey(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.readFrom(java.io.DataInput, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.DateTimeZoneBuilder$OfYear(char, int, int, int, boolean, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.DateTimeZoneBuilder$PrecalculatedZone(java.lang.String, java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$DSTZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.DateTimeZoneBuilder$PrecalculatedZone(java.lang.String, long[], int[], int[], java.lang.String[], org.joda.time.tz.DateTimeZoneBuilder$DSTZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.equals(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.getNameKey(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iNameKeys</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.readFrom(java.io.DataInput, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.writeTo(java.io.DataOutput)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.DateTimeZoneBuilder$Recurrence(org.joda.time.tz.DateTimeZoneBuilder$OfYear, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.equals(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.getNameKey()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.iNameKey</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.readFrom(java.io.DataInput)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.writeTo(java.io.DataOutput)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.getNameKey()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.DateTimeZoneBuilder$RuleSet(org.joda.time.tz.DateTimeZoneBuilder$RuleSet)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.buildTailZone(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.firstTransition(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iInitialNameKey</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.setFixedSavings(java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.DateTimeZoneBuilder$Transition(long, java.lang.String, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.DateTimeZoneBuilder$Transition(long, org.joda.time.tz.DateTimeZoneBuilder$Rule, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.DateTimeZoneBuilder$Transition(long, org.joda.time.tz.DateTimeZoneBuilder$Transition)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.getNameKey()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.iNameKey</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.isTransitionFrom(org.joda.time.tz.DateTimeZoneBuilder$Transition)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addRecurringSavings(java.lang.String, int, int, int, char, int, int, int, boolean, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.buildFixedZone(java.lang.String, java.lang.String, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.DataInput, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.InputStream, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.setFixedSavings(java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeTo(java.io.DataOutput)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZonePermission.DateTimeZonePermission(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZonePermission.DateTimeZonePermission(java.lang.String, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DefaultNameProvider.getName(java.util.Locale, java.lang.String, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DefaultNameProvider.getNameSet(java.util.Locale, java.lang.String, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DefaultNameProvider.getShortName(java.util.Locale, java.lang.String, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.FixedDateTimeZone.FixedDateTimeZone(java.lang.String, java.lang.String, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.FixedDateTimeZone.equals(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.FixedDateTimeZone.getNameKey(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.FixedDateTimeZone.iNameKey</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.NameProvider.getName(java.util.Locale, java.lang.String, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.NameProvider.getShortName(java.util.Locale, java.lang.String, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.Provider.getDateTimeZone(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.UTCProvider.getDateTimeZone(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear(java.util.StringTokenizer)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.ZoneInfoCompiler$Rule(java.util.StringTokenizer)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.formatName(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.iLetterS</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.iName</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.iType</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.addRule(org.joda.time.tz.ZoneInfoCompiler$Rule)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.ZoneInfoCompiler$Zone(java.lang.String, java.util.StringTokenizer)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.ZoneInfoCompiler$Zone(java.util.StringTokenizer)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.addToBuilder(org.joda.time.tz.ZoneInfoCompiler$Zone, org.joda.time.tz.DateTimeZoneBuilder, java.util.Map)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.buildDateTimeZone(java.util.Map)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.chain(java.util.StringTokenizer)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.iFormat</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.iName</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.iRules</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.main(java.lang.String[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDayOfWeek(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseMonth(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseOptional(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseTime(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseYear(java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.printUsage()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.readZoneInfoMap(java.io.DataInputStream, java.util.Map)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.io.File)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.getDateTimeZone(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.iResourcePath</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneData(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.openResource(java.lang.String)</inbound>
            <feature confirmed="no">
                <name>java.lang.String.CASE_INSENSITIVE_ORDER</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneInfoMap(java.io.InputStream)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.String.String(java.lang.String)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.String.charAt(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getPatternForStyle(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.isNumericToken(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.parseToken(java.lang.String, int[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.lang.StringBuffer, java.io.Writer, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.digitCount(java.lang.String, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.parseTwoDigits(java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.String.concat(java.lang.String)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.AbstractGJChronology(org.joda.time.Chronology, java.lang.Object, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.createErrorMessage(java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.formatName(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.openResource(java.lang.String)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.String.endsWith(java.lang.String)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader, boolean)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.String.equals(java.lang.Object)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.util.TimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.writeTo(java.io.DataOutput)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.isTransitionFrom(org.joda.time.tz.DateTimeZoneBuilder$Transition)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.buildFixedZone(java.lang.String, java.lang.String, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DefaultNameProvider.getNameSet(java.util.Locale, java.lang.String, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.FixedDateTimeZone.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.addRule(org.joda.time.tz.ZoneInfoCompiler$Rule)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.main(java.lang.String[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseOptional(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseYear(java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.getDateTimeZone(java.lang.String)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.String.equalsIgnoreCase(java.lang.String)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.dayOfWeekTextToValue(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.eraTextToValue(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.halfdayTextToValue(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.monthOfYearTextToValue(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.UTCProvider.getDateTimeZone(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.String.hashCode()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.hashCode()</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.String.indexOf(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getDurationType(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.formatName(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.String.indexOf(java.lang.String)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.formatName(java.lang.String)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.String.intern()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.ZoneInfoCompiler$Rule(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.formatName(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.ZoneInfoCompiler$Zone(java.lang.String, java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.readZoneInfoMap(java.io.DataInputStream, java.util.Map)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.String.lastIndexOf(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.toString()</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.String.length()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.maxLength(java.lang.String[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.createErrorMessage(java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseMillis(java.lang.String, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.parseMutableDuration(org.joda.time.DurationType, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getPatternForStyle(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.isNumericToken(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.parseToken(java.lang.String, int[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.lang.StringBuffer, java.io.Writer, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$MatchingParser.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.estimateParsedLength()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.estimatePrintedLength()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.digitCount(java.lang.String, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.estimatePrintedLength()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.calculatePrintedLength(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.parse(java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.scan(java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix.calculatePrintedLength(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix.parse(java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix.scan(java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.String.regionMatches(boolean, int, java.lang.String, int, int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.parse(java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.scan(java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix.parse(java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix.scan(java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.String.startsWith(java.lang.String)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.util.TimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseTime(java.lang.String)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.String.substring(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.util.TimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.createErrorMessage(java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.formatName(java.lang.String)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.String.substring(int, int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.createErrorMessage(java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.formatName(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.String.toLowerCase()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseYear(java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.String.valueOf(char)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.print(long, org.joda.time.DateTimeZone, long)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.lang.StringBuffer</name>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.checkPrecise(org.joda.time.DurationField, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.checkSupport(org.joda.time.DurationField, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.selectChronologyUTC(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.util.TimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.AbstractGJChronology(org.joda.time.Chronology, java.lang.Object, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearOverflow(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.dayOfWeekTextToValue(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.eraTextToValue(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.halfdayTextToValue(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.monthOfYearTextToValue(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.add(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.adjustYearForSet(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.getMessage()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getDurationConverter(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstantConverter(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getIntervalConverter(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.selectSlow(org.joda.time.convert.ConverterSet, java.lang.Class)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.safeAdd(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.safeMultiply(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.safeToInt(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(java.lang.String, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeField, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.MillisDurationField.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.unsupported()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.unsupported()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.createErrorMessage(java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.print(long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.lang.StringBuffer, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.print(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.printTo(java.lang.StringBuffer, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.lang.StringBuffer, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDatePattern(char)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDateTimePattern(char, char)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getPatternForStyle(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getTimePattern(char)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.parseToken(java.lang.String, int[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.selectStyle(char)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.lang.StringBuffer, java.io.Writer, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.lang.StringBuffer, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.printTo(java.lang.StringBuffer, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix.printTo(java.lang.StringBuffer, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.printTo(java.lang.StringBuffer, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.merge(java.lang.String, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix.printTo(java.lang.StringBuffer, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationPrinter.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.appendPaddedInteger(java.lang.StringBuffer, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.appendPaddedInteger(java.lang.StringBuffer, long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.appendUnpaddedInteger(java.lang.StringBuffer, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.appendUnpaddedInteger(java.lang.StringBuffer, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.DateTimeZoneBuilder$OfYear(char, int, int, int, boolean, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.formatName(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.addToBuilder(org.joda.time.tz.ZoneInfoCompiler$Zone, org.joda.time.tz.DateTimeZoneBuilder, java.util.Map)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.io.File)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.openResource(java.lang.String)</inbound>
            <feature confirmed="no">
                <name>java.lang.StringBuffer.StringBuffer()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.checkPrecise(org.joda.time.DurationField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.checkSupport(org.joda.time.DurationField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.selectChronologyUTC(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.util.TimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.AbstractGJChronology(org.joda.time.Chronology, java.lang.Object, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearOverflow(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.dayOfWeekTextToValue(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.eraTextToValue(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.halfdayTextToValue(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.monthOfYearTextToValue(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.adjustYearForSet(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getDurationConverter(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstantConverter(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getIntervalConverter(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.selectSlow(org.joda.time.convert.ConverterSet, java.lang.Class)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.safeAdd(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.safeMultiply(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.safeToInt(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(java.lang.String, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeField, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.MillisDurationField.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.unsupported()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.unsupported()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.createErrorMessage(java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDatePattern(char)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDateTimePattern(char, char)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getPatternForStyle(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getTimePattern(char)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.parseToken(java.lang.String, int[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.selectStyle(char)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.merge(java.lang.String, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.DateTimeZoneBuilder$OfYear(char, int, int, int, boolean, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.formatName(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.addToBuilder(org.joda.time.tz.ZoneInfoCompiler$Zone, org.joda.time.tz.DateTimeZoneBuilder, java.util.Map)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.io.File)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader, boolean)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.StringBuffer.StringBuffer(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.getMessage()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.print(long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.print(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.openResource(java.lang.String)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.StringBuffer.append(boolean)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.toString()</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.StringBuffer.append(char)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.checkSupport(org.joda.time.DurationField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.getMessage()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.selectSlow(org.joda.time.convert.ConverterSet, java.lang.Class)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(java.lang.String, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeField, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.MillisDurationField.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.createErrorMessage(java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.parseToken(java.lang.String, int[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.selectStyle(char)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.lang.StringBuffer, java.io.Writer, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.appendPaddedInteger(java.lang.StringBuffer, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.appendPaddedInteger(java.lang.StringBuffer, long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.appendUnpaddedInteger(java.lang.StringBuffer, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.DateTimeZoneBuilder$OfYear(char, int, int, int, boolean, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader, boolean)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.StringBuffer.append(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.AbstractGJChronology(org.joda.time.Chronology, java.lang.Object, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.adjustYearForSet(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(java.lang.String, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeField, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.toString()</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.StringBuffer.append(java.lang.Object)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.selectChronologyUTC(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.getMessage()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDatePattern(char)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDateTimePattern(char, char)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getTimePattern(char)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.io.File)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.StringBuffer.append(java.lang.String)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.checkPrecise(org.joda.time.DurationField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.checkSupport(org.joda.time.DurationField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.selectChronologyUTC(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.util.TimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.AbstractGJChronology(org.joda.time.Chronology, java.lang.Object, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearOverflow(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.dayOfWeekTextToValue(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.eraTextToValue(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.halfdayTextToValue(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.monthOfYearTextToValue(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.adjustYearForSet(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.getMessage()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getDurationConverter(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstantConverter(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getIntervalConverter(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.selectSlow(org.joda.time.convert.ConverterSet, java.lang.Class)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.safeAdd(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.safeMultiply(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.safeToInt(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(java.lang.String, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeField, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.MillisDurationField.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.unsupported()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.unsupported()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.createErrorMessage(java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDatePattern(char)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDateTimePattern(char, char)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getPatternForStyle(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getTimePattern(char)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.selectStyle(char)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.lang.StringBuffer, java.io.Writer, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.printTo(java.lang.StringBuffer, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.merge(java.lang.String, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix.printTo(java.lang.StringBuffer, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.appendPaddedInteger(java.lang.StringBuffer, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.appendPaddedInteger(java.lang.StringBuffer, long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.appendUnpaddedInteger(java.lang.StringBuffer, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.appendUnpaddedInteger(java.lang.StringBuffer, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.DateTimeZoneBuilder$OfYear(char, int, int, int, boolean, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.formatName(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.addToBuilder(org.joda.time.tz.ZoneInfoCompiler$Zone, org.joda.time.tz.DateTimeZoneBuilder, java.util.Map)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.io.File)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.openResource(java.lang.String)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.StringBuffer.append(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearOverflow(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.safeAdd(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.safeMultiply(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.safeToInt(long)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.StringBuffer.toString()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.checkPrecise(org.joda.time.DurationField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.checkSupport(org.joda.time.DurationField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.selectChronologyUTC(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.util.TimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.AbstractGJChronology(org.joda.time.Chronology, java.lang.Object, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearOverflow(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.dayOfWeekTextToValue(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.eraTextToValue(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.halfdayTextToValue(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.monthOfYearTextToValue(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.adjustYearForSet(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.getMessage()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getDurationConverter(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstantConverter(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getIntervalConverter(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.selectSlow(org.joda.time.convert.ConverterSet, java.lang.Class)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.safeAdd(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.safeMultiply(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.safeToInt(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(java.lang.String, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeField, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.MillisDurationField.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.unsupported()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.unsupported()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.createErrorMessage(java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.print(long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.print(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDatePattern(char)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDateTimePattern(char, char)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getPatternForStyle(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getTimePattern(char)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.parseToken(java.lang.String, int[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.selectStyle(char)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.merge(java.lang.String, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.DateTimeZoneBuilder$OfYear(char, int, int, int, boolean, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.formatName(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.addToBuilder(org.joda.time.tz.ZoneInfoCompiler$Zone, org.joda.time.tz.DateTimeZoneBuilder, java.util.Map)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.io.File)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.openResource(java.lang.String)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.lang.String[]</name>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DefaultNameProvider.getNameSet(java.util.Locale, java.lang.String, java.lang.String)</inbound>
        </class>
        <class confirmed="no">
            <name>java.lang.System</name>
            <feature confirmed="no">
                <name>java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.add(org.joda.time.convert.Converter, org.joda.time.convert.Converter[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.copyInto(org.joda.time.convert.Converter[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.saveField(org.joda.time.format.DateTimeParserBucket$SavedField)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.System.currentTimeMillis()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Instant.Instant()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.static {}</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.System.getProperty(java.lang.String)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultNameProvider()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultProvider()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.static {}</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.System.getSecurityManager()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setDefault(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setNameProvider(org.joda.time.tz.NameProvider)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setProvider(org.joda.time.tz.Provider)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.System.identityHashCode(java.lang.Object)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.forLocale(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.System.out</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.printUsage()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.lang.Thread</name>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultNameProvider()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultProvider()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.uncaughtException(java.lang.Exception)</inbound>
            <feature confirmed="no">
                <name>java.lang.Thread.currentThread()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultNameProvider()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultProvider()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.uncaughtException(java.lang.Exception)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.Thread.getThreadGroup()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultNameProvider()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultProvider()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.uncaughtException(java.lang.Exception)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.lang.ThreadGroup</name>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultNameProvider()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultProvider()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.uncaughtException(java.lang.Exception)</inbound>
            <feature confirmed="no">
                <name>java.lang.ThreadGroup.uncaughtException(java.lang.Thread, java.lang.Throwable)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultNameProvider()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultProvider()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.uncaughtException(java.lang.Exception)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.lang.Throwable</name>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultNameProvider()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultProvider()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.uncaughtException(java.lang.Exception)</inbound>
            <feature confirmed="no">
                <name>java.lang.Throwable.getMessage()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.getMessage()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.class$(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.DateConverter.class$(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.class$(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.class$(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.class$(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.class$(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.class$(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.class$(java.lang.String)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.lang.UnsupportedOperationException</name>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.addWrapped(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.get(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getAsShortText(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getAsText(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getLeapAmount(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getMaximumShortTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getMaximumValue()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getMaximumValue(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getMinimumValue()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getMinimumValue(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.isLeap(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.remainder(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.roundCeiling(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.roundFloor(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.roundHalfCeiling(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.roundHalfEven(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.roundHalfFloor(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.set(long, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.unsupported()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.add(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.add(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getDifference(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getDifferenceAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getMillis(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getMillis(int, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getMillis(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getMillis(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getValue(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getValue(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getValueAsLong(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getValueAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.unsupported()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.print(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.print(long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.print(long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.print(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.printTo(java.io.Writer, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.printTo(java.io.Writer, long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.printTo(java.io.Writer, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.printTo(java.lang.StringBuffer, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.unsupported()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.parseDateTime(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.parseDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.parseMillis(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.parseMillis(java.lang.String, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.parseMutableDateTime(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.parseMutableDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.unsupported()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toParser()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toPrinter()</inbound>
            <feature confirmed="no">
                <name>java.lang.UnsupportedOperationException.UnsupportedOperationException()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getDurationMillis(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.UnsupportedOperationException.UnsupportedOperationException(java.lang.String)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.checkPrecise(org.joda.time.DurationField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.checkSupport(org.joda.time.DurationField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.unsupported()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.unsupported()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.unsupported()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.unsupported()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toPrinter()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.writeTo(java.io.DataOutput)</inbound>
            </feature>
        </class>
    </package>
    <package confirmed="no">
        <name>java.lang.ref</name>
        <class confirmed="no">
            <name>java.lang.ref.Reference</name>
            <feature confirmed="no">
                <name>java.lang.ref.Reference.get()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.forLocale(java.util.Locale)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.lang.ref.SoftReference</name>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.getDateTimeZone(java.lang.String)</inbound>
            <feature confirmed="no">
                <name>java.lang.ref.SoftReference.SoftReference(java.lang.Object)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneData(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneInfoMap(java.io.InputStream)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.lang.ref.SoftReference.get()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.getDateTimeZone(java.lang.String)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.lang.ref.WeakReference</name>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.forLocale(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iLocale</inbound>
            <feature confirmed="no">
                <name>java.lang.ref.WeakReference.WeakReference(java.lang.Object)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols(java.util.Locale)</inbound>
            </feature>
        </class>
    </package>
    <package confirmed="no">
        <name>java.security</name>
        <class confirmed="no">
            <name>java.security.BasicPermission</name>
            <inbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZonePermission</inbound>
            <feature confirmed="no">
                <name>java.security.BasicPermission.BasicPermission(java.lang.String)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZonePermission.DateTimeZonePermission(java.lang.String)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.security.BasicPermission.BasicPermission(java.lang.String, java.lang.String)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZonePermission.DateTimeZonePermission(java.lang.String, java.lang.String)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.security.Permission</name>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setDefault(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setNameProvider(org.joda.time.tz.NameProvider)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setProvider(org.joda.time.tz.Provider)</inbound>
        </class>
    </package>
    <package confirmed="no">
        <name>java.text</name>
        <class confirmed="no">
            <name>java.text.DateFormat</name>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDatePattern(char)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDateTimePattern(char, char)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getTimePattern(char)</inbound>
            <feature confirmed="no">
                <name>java.text.DateFormat.getDateInstance(int, java.util.Locale)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDatePattern(char)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.text.DateFormat.getDateTimeInstance(int, int, java.util.Locale)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDateTimePattern(char, char)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.text.DateFormat.getTimeInstance(int, java.util.Locale)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getTimePattern(char)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.text.DateFormatSymbols</name>
            <feature confirmed="no">
                <name>java.text.DateFormatSymbols.DateFormatSymbols(java.util.Locale)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DefaultNameProvider.getNameSet(java.util.Locale, java.lang.String, java.lang.String)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.text.DateFormatSymbols.getAmPmStrings()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols(java.util.Locale)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.text.DateFormatSymbols.getEras()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols(java.util.Locale)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.text.DateFormatSymbols.getMonths()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols(java.util.Locale)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.text.DateFormatSymbols.getShortMonths()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols(java.util.Locale)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.text.DateFormatSymbols.getShortWeekdays()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols(java.util.Locale)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.text.DateFormatSymbols.getWeekdays()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols(java.util.Locale)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.text.DateFormatSymbols.getZoneStrings()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DefaultNameProvider.getNameSet(java.util.Locale, java.lang.String, java.lang.String)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.text.SimpleDateFormat</name>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDatePattern(char)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDateTimePattern(char, char)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getTimePattern(char)</inbound>
            <feature confirmed="no">
                <name>java.text.SimpleDateFormat.toPattern()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDatePattern(char)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDateTimePattern(char, char)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getTimePattern(char)</inbound>
            </feature>
        </class>
    </package>
    <package confirmed="no">
        <name>java.util</name>
        <class confirmed="no">
            <name>java.util.AbstractList</name>
            <feature confirmed="no">
                <name>java.util.AbstractList.iterator()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.firstTransition(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.nextTransition(long, int)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.util.ArrayList</name>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.DateTimeFormatterBuilder$Composite(org.joda.time.Chronology, java.util.ArrayList)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append0(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append0(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.clear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.getFormatter()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iElementPairs</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.DateTimeZoneBuilder$PrecalculatedZone(java.lang.String, java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$DSTZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.DateTimeZoneBuilder$RuleSet()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.DateTimeZoneBuilder$RuleSet(org.joda.time.tz.DateTimeZoneBuilder$RuleSet)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.addRule(org.joda.time.tz.DateTimeZoneBuilder$Rule)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.buildTailZone(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.firstTransition(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iRules</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.nextTransition(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.DateTimeZoneBuilder()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addCutover(int, char, int, int, int, boolean, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addTransition(java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$Transition)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.getLastRuleSet()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.iRuleSets</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(java.lang.String)</inbound>
            <feature confirmed="no">
                <name>java.util.ArrayList.ArrayList()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.clear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.ZoneInfoCompiler$RuleSet(org.joda.time.tz.ZoneInfoCompiler$Rule)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.ZoneInfoCompiler()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.ArrayList.ArrayList(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.DateTimeZoneBuilder$RuleSet()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.DateTimeZoneBuilder()</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.ArrayList.ArrayList(java.util.Collection)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.DateTimeZoneBuilder$RuleSet(org.joda.time.tz.DateTimeZoneBuilder$RuleSet)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.firstTransition(long)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.ArrayList.add(java.lang.Object)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append0(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append0(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.addRule(org.joda.time.tz.DateTimeZoneBuilder$Rule)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addCutover(int, char, int, int, int, boolean, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addTransition(java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$Transition)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.ArrayList.clear()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.clear()</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.ArrayList.contains(java.lang.Object)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.addRule(org.joda.time.tz.DateTimeZoneBuilder$Rule)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.ArrayList.get(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.DateTimeFormatterBuilder$Composite(org.joda.time.Chronology, java.util.ArrayList)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.getFormatter()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.DateTimeZoneBuilder$PrecalculatedZone(java.lang.String, java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$DSTZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.buildTailZone(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addCutover(int, char, int, int, int, boolean, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addTransition(java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$Transition)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.getLastRuleSet()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(java.lang.String)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.ArrayList.remove(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addTransition(java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$Transition)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.ArrayList.size()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.DateTimeFormatterBuilder$Composite(org.joda.time.Chronology, java.util.ArrayList)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.getFormatter()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.DateTimeZoneBuilder$PrecalculatedZone(java.lang.String, java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$DSTZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.buildTailZone(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addCutover(int, char, int, int, int, boolean, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addTransition(java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$Transition)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.getLastRuleSet()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(java.lang.String)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.util.Arrays</name>
            <feature confirmed="no">
                <name>java.util.Arrays.binarySearch(long[], long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.getNameKey(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.getOffset(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.getStandardOffset(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.nextTransition(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.previousTransition(long)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.Arrays.equals(int[], int[])</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.equals(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.Arrays.equals(java.lang.Object[], java.lang.Object[])</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.equals(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.Arrays.equals(long[], long[])</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.equals(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.Arrays.sort(java.lang.Object[], int, int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.sort(java.lang.Comparable[], int)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.util.Calendar</name>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toCalendar(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getInstantMillis(java.lang.Object)</inbound>
            <feature confirmed="no">
                <name>java.util.Calendar.getInstance(java.util.Locale)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toCalendar(java.util.Locale)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.Calendar.getTime()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getInstantMillis(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.Calendar.getTimeZone()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.Calendar.setTime(java.util.Date)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toCalendar(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toGregorianCalendar()</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.util.Collection</name>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.DateTimeZoneBuilder$RuleSet(org.joda.time.tz.DateTimeZoneBuilder$RuleSet)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.firstTransition(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
            <feature confirmed="no">
                <name>java.util.Collection.iterator()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.util.Collections</name>
            <feature confirmed="no">
                <name>java.util.Collections.singleton(java.lang.Object)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.UTCProvider.getAvailableIDs()</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.Collections.unmodifiableSet(java.util.Set)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.getAvailableIDs()</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.util.Comparator</name>
            <inbound type="class" confirmed="yes">org.joda.time.DateTimeComparator</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneInfoMap(java.io.InputStream)</inbound>
        </class>
        <class confirmed="no">
            <name>java.util.Date</name>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toCalendar(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDate()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toGregorianCalendar()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getInstantMillis(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.DateConverter.getInstantMillis(java.lang.Object)</inbound>
            <feature confirmed="no">
                <name>java.util.Date.Date(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDate()</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.Date.getTime()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getInstantMillis(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.DateConverter.getInstantMillis(java.lang.Object)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.util.GregorianCalendar</name>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toGregorianCalendar()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <feature confirmed="no">
                <name>java.util.GregorianCalendar.GregorianCalendar()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toGregorianCalendar()</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.GregorianCalendar.getGregorianChange()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.util.HashMap</name>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.convertField(org.joda.time.DurationField, java.util.HashMap)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DurationField, java.util.HashMap)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.cCache</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.cCache</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getInstance(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DefaultNameProvider.DefaultNameProvider()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DefaultNameProvider.createCache()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DefaultNameProvider.getNameSet(java.util.Locale, java.lang.String, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DefaultNameProvider.iByLocaleCache</inbound>
            <feature confirmed="no">
                <name>java.util.HashMap.HashMap()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getConvertedId(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.ZoneInfoCompiler()</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.HashMap.HashMap(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getInstance(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.DateTimeFormat(org.joda.time.Chronology, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.Chronology, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DefaultNameProvider.createCache()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.HashMap.containsKey(java.lang.Object)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.convertField(org.joda.time.DurationField, java.util.HashMap)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DurationField, java.util.HashMap)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.HashMap.get(java.lang.Object)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.convertField(org.joda.time.DurationField, java.util.HashMap)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DurationField, java.util.HashMap)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getInstance(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DefaultNameProvider.getNameSet(java.util.Locale, java.lang.String, java.lang.String)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.HashMap.put(java.lang.Object, java.lang.Object)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.convertField(org.joda.time.DurationField, java.util.HashMap)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DurationField, java.util.HashMap)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getInstance(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DefaultNameProvider.getNameSet(java.util.Locale, java.lang.String, java.lang.String)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.util.HashSet</name>
            <feature confirmed="no">
                <name>java.util.HashSet.HashSet()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.writeTo(java.io.DataOutput)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.util.Iterator</name>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.writeTo(java.io.DataOutput)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.firstTransition(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.nextTransition(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
            <feature confirmed="no">
                <name>java.util.Iterator.hasNext()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.writeTo(java.io.DataOutput)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.firstTransition(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.nextTransition(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.Iterator.next()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.writeTo(java.io.DataOutput)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.firstTransition(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.nextTransition(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.Iterator.remove()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.nextTransition(long, int)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.util.List</name>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.DurationFormatterBuilder$AlternateSelector(org.joda.time.format.DurationFormatter, java.util.List, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.DurationFormatterBuilder$Composite(java.util.List)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.append(org.joda.time.format.DurationFormatter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendField(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendLiteral(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeparator(java.lang.String, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSuffix(org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.clear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.createComposite(java.util.List)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iAlternateFormatters</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iFormatters</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toFormatter()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toFormatter(java.util.List)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.ZoneInfoCompiler$RuleSet(org.joda.time.tz.ZoneInfoCompiler$Rule)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.addRule(org.joda.time.tz.ZoneInfoCompiler$Rule)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.iRules</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.ZoneInfoCompiler()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.iLinks</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.iZones</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
            <feature confirmed="no">
                <name>java.util.List.add(java.lang.Object)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.append(org.joda.time.format.DurationFormatter)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendField(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendLiteral(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeparator(java.lang.String, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.ZoneInfoCompiler$RuleSet(org.joda.time.tz.ZoneInfoCompiler$Rule)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.addRule(org.joda.time.tz.ZoneInfoCompiler$Rule)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.List.clear()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeparator(java.lang.String, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.clear()</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.List.get(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeparator(java.lang.String, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSuffix(org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.createComposite(java.util.List)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toFormatter()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toFormatter(java.util.List)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.addRule(org.joda.time.tz.ZoneInfoCompiler$Rule)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.List.lastIndexOf(java.lang.Object)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSuffix(org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.List.set(int, java.lang.Object)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeparator(java.lang.String, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSuffix(org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.List.size()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.DurationFormatterBuilder$AlternateSelector(org.joda.time.format.DurationFormatter, java.util.List, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.DurationFormatterBuilder$Composite(java.util.List)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeparator(java.lang.String, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSuffix(org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.createComposite(java.util.List)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toFormatter()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toFormatter(java.util.List)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.List.subList(int, int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeparator(java.lang.String, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toFormatter(java.util.List)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.List.toArray(java.lang.Object[])</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.DurationFormatterBuilder$AlternateSelector(org.joda.time.format.DurationFormatter, java.util.List, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.DurationFormatterBuilder$Composite(java.util.List)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.util.Locale</name>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.toString(java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toCalendar(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getAsShortText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMaximumShortTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getName(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getName(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getShortName(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getShortName(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableDateTime.toString(java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$HalfdayField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$HalfdayField.getMaximumTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$HalfdayField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.getMaximumShortTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.getMaximumShortTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getAsShortText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMaximumShortTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMaximumTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.getMaximumShortTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.forLocale(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getMaximumShortTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getMaximumShortTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMaximumShortTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getAsShortText(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getAsText(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getMaximumShortTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.set(long, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getMaximumShortTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getMaximumShortTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.DateTimeFormat(org.joda.time.Chronology, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDatePattern(char)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDateTimePattern(char, char)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.Chronology, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.DateTimeZone, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstanceUTC()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getTimePattern(char)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.iLocale</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.DateTimeFormatterBuilder$TextField(org.joda.time.Chronology, org.joda.time.DateTimeField, java.util.Locale, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.estimatePrintedLength()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.iLocale</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.print(long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.DateTimeFormatterBuilder$TimeZonePrinter(org.joda.time.Chronology, java.util.Locale, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.iLocale</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.print(long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.DateTimeZone, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendShortText(org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendText(org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneName()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneShortName()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.getLocale()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iLocale</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.DateTimeParserBucket$SavedField(org.joda.time.DateTimeField, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.DateTimeParserBucket$SavedField(org.joda.time.DateTimeField, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.iLocale</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.set(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.saveField(org.joda.time.DateTimeField, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormat.getInstance(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getAsShortText()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getAsShortText(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getAsText()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getAsText(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getMaximumShortTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getMaximumTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.setCopy(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.setCopy(java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.setCopy(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.setCopy(java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.set(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.set(java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.setCopy(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.setCopy(java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DefaultNameProvider.getName(java.util.Locale, java.lang.String, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DefaultNameProvider.getNameSet(java.util.Locale, java.lang.String, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DefaultNameProvider.getShortName(java.util.Locale, java.lang.String, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.NameProvider.getName(java.util.Locale, java.lang.String, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.NameProvider.getShortName(java.util.Locale, java.lang.String, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDayOfWeek(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseMonth(java.lang.String)</inbound>
            <feature confirmed="no">
                <name>java.util.Locale.ENGLISH</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDayOfWeek(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseMonth(java.lang.String)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.Locale.getDefault()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toCalendar(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getName(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getShortName(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.Chronology, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstanceUTC()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology, java.util.Locale)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.util.Map</name>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.cZoneIdConversion</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getConvertedId(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.cCache</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.cCache</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.cCache</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.cCache</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.cCache</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.cCache</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.DateTimeFormat(org.joda.time.Chronology, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.cInstanceCache</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forStyle(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.Chronology, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.iPatternedCache</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.iStyledCache</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.cCache</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.addToBuilder(org.joda.time.tz.DateTimeZoneBuilder, java.util.Map)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.addToBuilder(org.joda.time.tz.ZoneInfoCompiler$Zone, org.joda.time.tz.DateTimeZoneBuilder, java.util.Map)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.buildDateTimeZone(java.util.Map)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.ZoneInfoCompiler()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.iRuleSets</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.main(java.lang.String[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.readZoneInfoMap(java.io.DataInputStream, java.util.Map)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.io.File)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.getAvailableIDs()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.getDateTimeZone(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.iZoneInfoMap</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneData(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneInfoMap(java.io.InputStream)</inbound>
            <feature confirmed="no">
                <name>java.util.Map.containsKey(java.lang.Object)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.Map.entrySet()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.Map.get(java.lang.Object)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getConvertedId(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forStyle(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.Chronology, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.addToBuilder(org.joda.time.tz.ZoneInfoCompiler$Zone, org.joda.time.tz.DateTimeZoneBuilder, java.util.Map)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.getDateTimeZone(java.lang.String)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.Map.keySet()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.getAvailableIDs()</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.Map.put(java.lang.Object, java.lang.Object)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getConvertedId(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forStyle(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.Chronology, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.readZoneInfoMap(java.io.DataInputStream, java.util.Map)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneData(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneInfoMap(java.io.InputStream)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.Map.putAll(java.util.Map)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.Map.remove(java.lang.Object)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneData(java.lang.String)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.Map.size()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.util.Map$Entry</name>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
            <feature confirmed="no">
                <name>java.util.Map$Entry.getKey()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.Map$Entry.getValue()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.util.Set</name>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.cAvailableIDs</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getAvailableIDs()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setProvider0(org.joda.time.tz.Provider)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.Provider.getAvailableIDs()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.UTCProvider.getAvailableIDs()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.getAvailableIDs()</inbound>
            <feature confirmed="no">
                <name>java.util.Set.add(java.lang.Object)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.writeTo(java.io.DataOutput)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.Set.contains(java.lang.Object)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setProvider0(org.joda.time.tz.Provider)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.Set.iterator()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.writeTo(java.io.DataOutput)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.Set.size()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setProvider0(org.joda.time.tz.Provider)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.writeTo(java.io.DataOutput)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.util.StringTokenizer</name>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear(java.util.StringTokenizer)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.ZoneInfoCompiler$Rule(java.util.StringTokenizer)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.ZoneInfoCompiler$Zone(java.lang.String, java.util.StringTokenizer)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.ZoneInfoCompiler$Zone(java.util.StringTokenizer)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.chain(java.util.StringTokenizer)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
            <feature confirmed="no">
                <name>java.util.StringTokenizer.StringTokenizer(java.lang.String, java.lang.String)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.StringTokenizer.hasMoreTokens()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.ZoneInfoCompiler$Zone(java.lang.String, java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.StringTokenizer.nextToken()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.ZoneInfoCompiler$Rule(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.ZoneInfoCompiler$Zone(java.lang.String, java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.ZoneInfoCompiler$Zone(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.util.TimeZone</name>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.util.TimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.toTimeZone()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object)</inbound>
            <feature confirmed="no">
                <name>java.util.TimeZone.getDefault()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.static {}</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.TimeZone.getDisplayName()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.util.TimeZone)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.TimeZone.getID()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.util.TimeZone)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.TimeZone.getTimeZone(java.lang.String)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.toTimeZone()</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.util.TreeMap</name>
            <feature confirmed="no">
                <name>java.util.TreeMap.TreeMap()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.TreeMap.TreeMap(java.util.Comparator)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneInfoMap(java.io.InputStream)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.TreeMap.put(java.lang.Object, java.lang.Object)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.TreeMap.size()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.TreeMap.values()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>java.util.WeakHashMap</name>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.cCache</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.forLocale(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.static {}</inbound>
            <feature confirmed="no">
                <name>java.util.WeakHashMap.WeakHashMap()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.static {}</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.WeakHashMap.get(java.lang.Object)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.forLocale(java.util.Locale)</inbound>
            </feature>
            <feature confirmed="no">
                <name>java.util.WeakHashMap.put(java.lang.Object, java.lang.Object)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.forLocale(java.util.Locale)</inbound>
            </feature>
        </class>
    </package>
    <package confirmed="yes">
        <name>org.joda.time</name>
        <class confirmed="yes">
            <name>org.joda.time.AbstractDateTime</name>
            <outbound type="class" confirmed="no">java.io.Serializable</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.AbstractInstant</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.ReadableDateTime</outbound>
            <inbound type="class" confirmed="yes">org.joda.time.DateTime</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.MutableDateTime</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.AbstractDateTime()</name>
                <outbound type="feature" confirmed="no">java.lang.System.currentTimeMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.AbstractInstant()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.AbstractDateTime(int, int, int, int, int, int, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.AbstractInstant()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeMillis(int, int, int, int, int, int, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(int, int, int, int, int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.AbstractDateTime(int, int, int, int, int, int, int, org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.selectChronology(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.AbstractInstant()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeMillis(int, int, int, int, int, int, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(int, int, int, int, int, int, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(int, int, int, int, int, int, int, org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.AbstractDateTime(int, int, int, int, int, int, int, org.joda.time.DateTimeZone)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.AbstractInstant()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeMillis(int, int, int, int, int, int, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(int, int, int, int, int, int, int, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(int, int, int, int, int, int, int, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.AbstractInstant()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterManager</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstance()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstantConverter(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.InstantConverter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.InstantConverter.getChronology(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.InstantConverter.getInstantMillis(java.lang.Object)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object, org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.AbstractInstant()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterManager</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstance()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstantConverter(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.InstantConverter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.InstantConverter.getChronology(java.lang.Object, org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.InstantConverter.getInstantMillis(java.lang.Object, org.joda.time.Chronology)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(java.lang.Object, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(java.lang.Object, org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object, org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.AbstractInstant()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterManager</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstance()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstantConverter(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.InstantConverter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.InstantConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.InstantConverter.getInstantMillis(java.lang.Object, org.joda.time.DateTimeZone)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.AbstractDateTime(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.AbstractInstant()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.AbstractDateTime(long, org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.selectChronology(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.AbstractInstant()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(long, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(long, org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.AbstractDateTime(long, org.joda.time.DateTimeZone)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.AbstractInstant()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(long, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(long, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.AbstractDateTime(org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="no">java.lang.System.currentTimeMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.selectChronology(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.AbstractInstant()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.AbstractDateTime(org.joda.time.DateTimeZone)</name>
                <outbound type="feature" confirmed="no">java.lang.System.currentTimeMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.AbstractInstant()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.getCenturyOfEra()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.centuryOfEra()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.getChronology()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iChronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getCenturyOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getDayOfMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getDayOfWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getDayOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getHourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillisOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillisOfSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMinuteOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMinuteOfHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMonthOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getSecondOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getSecondOfMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getWeekOfWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getYearOfCentury()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getYearOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.toString(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.toString(java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.centuryOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.dayOfMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.dayOfWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.dayOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.era()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.hourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.millisOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.millisOfSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.minuteOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.minuteOfHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.monthOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.secondOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.secondOfMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.weekOfWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.weekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.withMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.year()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.yearOfCentury()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.yearOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addDays(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addHours(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addMillis(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addMinutes(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addMonths(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addSeconds(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addWeeks(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addWeekyears(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addYears(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.centuryOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.dayOfMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.dayOfWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.dayOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.era()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.hourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.millisOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.millisOfSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.minuteOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.minuteOfHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.monthOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.secondOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.secondOfMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDate(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDate(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDateTime(int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDayOfMonth(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDayOfWeek(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDayOfYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setHourOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillisOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillisOfSecond(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMinuteOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMinuteOfHour(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMonthOfYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setSecondOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setSecondOfMinute(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setTime(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setTime(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setWeekOfWeekyear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setWeekyear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.weekOfWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.weekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.withMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.year()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.yearOfCentury()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.yearOfEra()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.getDayOfMonth()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfMonth()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.getDayOfWeek()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfWeek()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.getDayOfYear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfYear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.getEra()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.era()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.getHourOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.hourOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.getMillis()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iMillis</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getCenturyOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getDayOfMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getDayOfWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getDayOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getHourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillisOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillisOfSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMinuteOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMinuteOfHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMonthOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getSecondOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getSecondOfMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getWeekOfWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getYearOfCentury()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getYearOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.withMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.add(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.add(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addDays(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addHours(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addMillis(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addMinutes(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addMonths(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addSeconds(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addWeeks(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addWeekyears(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addWrapped(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addYears(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.set(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDate(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDayOfMonth(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDayOfWeek(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDayOfYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setHourOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillisOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillisOfSecond(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMinuteOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMinuteOfHour(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMonthOfYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setSecondOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setSecondOfMinute(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setTime(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setTime(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setWeekOfWeekyear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setWeekyear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.addToCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.addToCopy(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.addWrappedToCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundCeilingCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundFloorCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundHalfCeilingCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundHalfEvenCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundHalfFloorCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.setCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.setCopy(java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseTime(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.getMillis(org.joda.time.ReadableInstant)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iMillis</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iMillis</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.getMillisOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millisOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.getMillisOfSecond()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millisOfSecond()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.getMinuteOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.minuteOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.getMinuteOfHour()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.minuteOfHour()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.getMonthOfYear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.monthOfYear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.getSecondOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.secondOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.getSecondOfMinute()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.secondOfMinute()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.getWeekOfWeekyear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weekOfWeekyear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.getWeekyear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weekyear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.getYear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.year()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.getYearOfCentury()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.yearOfCentury()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.getYearOfEra()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.yearOfEra()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.iChronology</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(int, int, int, int, int, int, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(int, int, int, int, int, int, int, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(long, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(long, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.moveDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.setChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.setDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.iMillis</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(int, int, int, int, int, int, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(int, int, int, int, int, int, int, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(long, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(long, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.moveDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.setMillis(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.moveDateTimeZone(org.joda.time.DateTimeZone)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.setChronology(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.setMillis(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeZone()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.withDateTimeZone(org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffsetFromLocal(long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.moveDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.selectChronology(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(int, int, int, int, int, int, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(long, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.setChronology(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.setChronology(org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.selectChronology(org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.moveDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.setDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setChronology(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.setDateTimeZone(org.joda.time.DateTimeZone)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.setChronology(org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeZone()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.withDateTimeZone(org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.setMillis(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.setMillis(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterManager</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstance()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstantConverter(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.InstantConverter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.InstantConverter.getInstantMillis(java.lang.Object)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.setMillis(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iMillis</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.moveDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.setMillis(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.print(org.joda.time.ReadableInstant)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.ISODateTimeFormat</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTime()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance(org.joda.time.Chronology)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.toString(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormat</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.print(org.joda.time.ReadableInstant)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.toString(java.lang.String, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormat</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.Chronology, java.util.Locale)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.print(org.joda.time.ReadableInstant)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.withChronology(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDateTime.withMillis(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.AbstractDuration</name>
            <outbound type="class" confirmed="no">java.io.Serializable</outbound>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
            <inbound type="class" confirmed="yes">org.joda.time.Duration</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.MutableDuration</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.AbstractDuration(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.isPrecise()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDuration.MutableDuration(org.joda.time.DurationType, java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getDurationType()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterManager</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getDurationConverter(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstance()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.DurationConverter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.DurationConverter.getDurationMillis(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.DurationConverter.getDurationType(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.DurationConverter.isPrecise(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.DurationConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Duration.Duration(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.MutableDuration(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType)</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Duration.Duration(org.joda.time.DurationType)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.MutableDuration(org.joda.time.DurationType)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Duration.Duration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.MutableDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.isPrecise()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDuration.MutableDuration(org.joda.time.DurationType, java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterManager</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getDurationConverter(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstance()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.DurationConverter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.DurationConverter.getDurationMillis(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.DurationConverter.isPrecise(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.DurationConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Duration.Duration(org.joda.time.DurationType, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.MutableDuration(org.joda.time.DurationType, java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, long)</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Duration.Duration(org.joda.time.DurationType, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.MutableDuration(org.joda.time.DurationType, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, long, long)</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Duration.Duration(org.joda.time.DurationType, long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.MutableDuration(org.joda.time.DurationType, long, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Duration.Duration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.MutableDuration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Duration.Duration(org.joda.time.DurationType, org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.MutableDuration(org.joda.time.DurationType, org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.ReadableDuration)</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getDurationType()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Duration.Duration(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.MutableDuration(org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.add(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getTotalMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.add(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.add(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.add(org.joda.time.ReadableDuration)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.add(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getTotalMillis()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.add(org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.addDays(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getDays()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDays(int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.addDays(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.addHours(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getHours()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setHours(int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.addHours(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.addInto(org.joda.time.ReadWritableInstant, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadWritableInstant.setMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.addMillis(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setMillis(int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.addMillis(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.addMinutes(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getMinutes()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setMinutes(int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.addMinutes(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.addMonths(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getMonths()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setMonths(int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.addMonths(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.addSeconds(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getSeconds()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setSeconds(int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.addSeconds(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.addTo(long, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(long, int, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addInto(org.joda.time.ReadWritableInstant, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(org.joda.time.ReadableInstant, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.addTo(long, int, org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getTotalMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iDays</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iHours</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iMinutes</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iMonths</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iSeconds</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iWeeks</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iYears</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.isPrecise()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.scaleValue(int, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.days()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.hours()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.millis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.minutes()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.months()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.seconds()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.weeks()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.withChronology(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.years()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.addTo(org.joda.time.ReadableInstant, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.withMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.addWeeks(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getWeeks()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setWeeks(int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.addWeeks(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.addYears(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getYears()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setYears(int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.addYears(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.checkPrecise(org.joda.time.DurationField, java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="feature" confirmed="no">java.lang.UnsupportedOperationException.UnsupportedOperationException(java.lang.String)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isPrecise()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.checkSupport(org.joda.time.DurationField, java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="feature" confirmed="no">java.lang.UnsupportedOperationException.UnsupportedOperationException(java.lang.String)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isSupported()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDays(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setHours(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setMillis(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setMinutes(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setMonths(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setSeconds(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setWeeks(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setYears(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.compareTo(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getTotalMillis()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.isEqual(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.isLongerThan(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.isShorterThan(org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.equals(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getDays()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getDurationType()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getHours()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getMinutes()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getMonths()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getSeconds()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getWeeks()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getYears()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.equals(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getDays()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getDurationType()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getHours()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getMinutes()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getMonths()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getSeconds()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getWeeks()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getYears()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.getDays()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iDays</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addDays(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.hashCode()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.getDurationType()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iType</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.hashCode()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.getDurationType(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.getHours()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iHours</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addHours(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.hashCode()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.getMillis()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iMillis</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addMillis(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.hashCode()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.getMinutes()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iMinutes</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addMinutes(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.hashCode()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.getMonths()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iMonths</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addMonths(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.hashCode()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.getSeconds()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iSeconds</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addSeconds(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.hashCode()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.getTotalMillis()</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalStateException.IllegalStateException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iTotalMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iTotalMillisState</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.updateTotalMillis()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.add(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(long, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.normalize()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.getWeeks()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iWeeks</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addWeeks(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.hashCode()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.getYears()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iYears</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addYears(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.hashCode()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.hashCode()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getDays()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getDurationType()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getHours()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getMinutes()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getMonths()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getSeconds()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getWeeks()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getYears()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.hashCode()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.iDays</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(long, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getDays()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDays(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.updateTotalMillis()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.iHours</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(long, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getHours()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setHours(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.updateTotalMillis()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.iMillis</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(long, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setMillis(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.updateTotalMillis()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.iMinutes</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(long, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getMinutes()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setMinutes(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.updateTotalMillis()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.iMonths</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(long, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getMonths()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setMonths(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.updateTotalMillis()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.iSeconds</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(long, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getSeconds()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setSeconds(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.updateTotalMillis()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.iTotalMillis</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getTotalMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.updateTotalMillis()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.iTotalMillisState</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getTotalMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.isPrecise()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDays(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setHours(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setMillis(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setMinutes(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setMonths(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setSeconds(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setWeeks(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setYears(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.updateTotalMillis()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.iType</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(long, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getDurationType()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDays(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(int, int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setHours(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setMillis(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setMinutes(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setMonths(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setSeconds(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setWeeks(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setYears(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.updateTotalMillis()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.iWeeks</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(long, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getWeeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setWeeks(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.updateTotalMillis()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.iYears</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(long, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getYears()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setYears(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.updateTotalMillis()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.isEqual(org.joda.time.ReadableDuration)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.compareTo(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.isLongerThan(org.joda.time.ReadableDuration)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.compareTo(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.isPrecise()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iTotalMillisState</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.updateTotalMillis()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(long, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInterval)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.isShorterThan(org.joda.time.ReadableDuration)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.compareTo(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.normalize()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getTotalMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.normalize()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.scaleValue(int, int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(long, int, org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.setDays(int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.checkSupport(org.joda.time.DurationField, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iDays</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iTotalMillisState</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iType</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.days()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addDays(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.setDays(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.setDuration(int, int, int, int, int, int, int, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.setDuration(int, int, int, int, int, int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.checkSupport(org.joda.time.DurationField, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iDays</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iHours</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iMinutes</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iMonths</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iSeconds</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iTotalMillisState</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iWeeks</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iYears</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.days()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.hours()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.millis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.minutes()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.months()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.seconds()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.weeks()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.years()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(int, int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getDays()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getHours()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getMinutes()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getMonths()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getSeconds()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getWeeks()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getYears()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.setDuration(org.joda.time.ReadableDuration)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.setDuration(org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.setHours(int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.checkSupport(org.joda.time.DurationField, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iHours</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iTotalMillisState</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iType</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.hours()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addHours(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.setHours(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.setMillis(int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.checkSupport(org.joda.time.DurationField, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iTotalMillisState</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iType</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.millis()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addMillis(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.setMillis(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.setMinutes(int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.checkSupport(org.joda.time.DurationField, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iMinutes</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iTotalMillisState</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iType</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.minutes()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addMinutes(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.setMinutes(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.setMonths(int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.checkSupport(org.joda.time.DurationField, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iMonths</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iTotalMillisState</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iType</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.months()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addMonths(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.setMonths(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.setSeconds(int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.checkSupport(org.joda.time.DurationField, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iSeconds</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iTotalMillisState</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iType</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.seconds()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addSeconds(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.setSeconds(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.setTotalMillis(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.add(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.normalize()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.setTotalMillis(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.setTotalMillis(long, long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.setTotalMillis(long, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.checkPrecise(org.joda.time.DurationField, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iDays</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iHours</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iMinutes</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iMonths</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iSeconds</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iTotalMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iTotalMillisState</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iWeeks</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iYears</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getDifference(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isSupported()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.days()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.hours()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.millis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.minutes()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.months()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.seconds()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.weeks()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.years()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long, long)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iDays</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iHours</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iMinutes</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iMonths</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iSeconds</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iTotalMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iTotalMillisState</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iWeeks</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iYears</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getDifference(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isPrecise()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isSupported()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.days()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.hours()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.millis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.minutes()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.months()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.seconds()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.weeks()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.years()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(long, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.setWeeks(int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.checkSupport(org.joda.time.DurationField, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iTotalMillisState</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iWeeks</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.weeks()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addWeeks(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.setWeeks(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.setYears(int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.checkSupport(org.joda.time.DurationField, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iTotalMillisState</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iYears</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.years()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addYears(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.setYears(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.toDuration()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Duration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Duration.Duration(org.joda.time.ReadableDuration)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.parseDuration(org.joda.time.DurationType, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.toMutableDuration()</name>
                <outbound type="class" confirmed="yes">org.joda.time.MutableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDuration.MutableDuration(org.joda.time.ReadableDuration)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationPrinter.print(org.joda.time.ReadableDuration)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.ISODurationFormat</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.getInstance()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.standard()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractDuration.updateTotalMillis()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iDays</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iHours</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iMinutes</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iMonths</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iSeconds</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iTotalMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iTotalMillisState</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iWeeks</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iYears</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getMillis(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isPrecise()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.days()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.hours()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.millis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.minutes()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.months()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.seconds()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.weeks()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.years()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getTotalMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.isPrecise()</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.AbstractInstant</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            <inbound type="class" confirmed="yes">org.joda.time.AbstractDateTime</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.AbstractPartialInstant</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.Instant</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.AbstractInstant()</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(int, int, int, int, int, int, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(int, int, int, int, int, int, int, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(long, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(long, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(long, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Instant.Instant()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Instant.Instant(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Instant.Instant(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Instant.Instant(org.joda.time.ReadableInstant)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.compareTo(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis(org.joda.time.ReadableInstant)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.equals(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.equals(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.get(org.joda.time.DateTimeField)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.getChronology()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.getDateTimeZone()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeZone()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getChronology()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toTrustedISODateTime()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.getMillis()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.getMillis(org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.hashCode()</name>
                <outbound type="feature" confirmed="no">java.lang.Object.hashCode()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.hashCode()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.isAfter(org.joda.time.ReadableInstant)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis(org.joda.time.ReadableInstant)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.isBefore(org.joda.time.ReadableInstant)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis(org.joda.time.ReadableInstant)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.isEqual(org.joda.time.ReadableInstant)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis(org.joda.time.ReadableInstant)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.toCalendar(java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.util.Calendar</outbound>
                <outbound type="feature" confirmed="no">java.util.Calendar.getInstance(java.util.Locale)</outbound>
                <outbound type="feature" confirmed="no">java.util.Calendar.setTime(java.util.Date)</outbound>
                <outbound type="class" confirmed="no">java.util.Date</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="no">java.util.Locale.getDefault()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDate()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.toDate()</name>
                <outbound type="class" confirmed="no">java.util.Date</outbound>
                <outbound type="feature" confirmed="no">java.util.Date.Date(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toCalendar(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toGregorianCalendar()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.toDateOnly()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateOnly</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateOnly.DateOnly(java.lang.Object)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.toDateOnly(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.withUTC()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateOnly</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateOnly.DateOnly(java.lang.Object, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.toDateTime()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(java.lang.Object)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.toDateTime(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(java.lang.Object, org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.toDateTime(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.getDateTimeZone()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(java.lang.Object, org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.withDateTimeZone(org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getDateTimeZone()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis(org.joda.time.ReadableInstant)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant, org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeZone()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(java.lang.Object, org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.withDateTimeZone(org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(java.lang.Object, org.joda.time.DateTimeZone)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.toGregorianCalendar()</name>
                <outbound type="feature" confirmed="no">java.util.Calendar.setTime(java.util.Date)</outbound>
                <outbound type="class" confirmed="no">java.util.Date</outbound>
                <outbound type="class" confirmed="no">java.util.GregorianCalendar</outbound>
                <outbound type="feature" confirmed="no">java.util.GregorianCalendar.GregorianCalendar()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDate()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.toInstant()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Instant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Instant.Instant(org.joda.time.ReadableInstant)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.toInstant(org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Instant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Instant.Instant(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.toMutableDateTime()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.MutableDateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(java.lang.Object)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.MutableDateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(java.lang.Object, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.MutableDateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(java.lang.Object, org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.withDateTimeZone(org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.MutableDateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getDateTimeZone()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis(org.joda.time.ReadableInstant)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant, org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeZone()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.MutableDateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(java.lang.Object, org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.withDateTimeZone(org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.MutableDateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(java.lang.Object, org.joda.time.DateTimeZone)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.toTimeOnly()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.TimeOnly</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.TimeOnly.TimeOnly(java.lang.Object)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.toTimeOnly(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.withUTC()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.TimeOnly</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.TimeOnly.TimeOnly(java.lang.Object, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.toTrustedISODateTime()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.getDateTimeZone()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(java.lang.Object, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getID()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.withChronology(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.withDateTimeZone(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.withDateTimeZone(org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.withChronology(org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInstant.withMillis(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.AbstractInterval</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.ReadableInterval</outbound>
            <inbound type="class" confirmed="yes">org.joda.time.Interval</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.MutableInterval</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.AbstractInterval(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.isPrecise()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getDuration()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getEndMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getStartMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iEndMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iStartMillis</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Duration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableInterval.MutableInterval(long, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInterval</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInterval</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInterval.getDuration()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInterval.getEndMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInterval.getStartMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterManager</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstance()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getIntervalConverter(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.IntervalConverter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.IntervalConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Interval.Interval(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.MutableInterval(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.AbstractInterval(long, long)</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iEndMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iStartMillis</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Interval.Interval(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.MutableInterval(long, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableDuration, org.joda.time.ReadableInstant)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iEndInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iEndMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iStartMillis</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Duration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Instant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.addTo(org.joda.time.ReadableInstant, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.isPrecise()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.toDuration()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Interval.Interval(org.joda.time.ReadableDuration, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.MutableInterval(org.joda.time.ReadableDuration, org.joda.time.ReadableInstant)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableDuration)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iEndMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iStartInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iStartMillis</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Duration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Instant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.addTo(org.joda.time.ReadableInstant, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.isPrecise()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.toDuration()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Interval.Interval(org.joda.time.ReadableInstant, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.MutableInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iEndInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iEndMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iStartInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iStartMillis</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Instant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Interval.Interval(org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.MutableInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInterval)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.isPrecise()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iEndMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iStartMillis</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Duration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInterval</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInterval.getDuration()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInterval.getEndMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInterval.getStartMillis()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Interval.Interval(org.joda.time.ReadableInterval)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.MutableInterval(org.joda.time.ReadableInterval)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.contains(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getEndMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getStartMillis()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.contains(org.joda.time.ReadableInstant)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.contains(org.joda.time.ReadableInstant)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.contains(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.contains(org.joda.time.ReadableInterval)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getEndMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getStartMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInterval</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInterval.getEndMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInterval.getStartMillis()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.equals(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getEndMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getStartMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInterval</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInterval.getEndMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInterval.getStartMillis()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.getDuration()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getEndMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getStartMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Duration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Duration.Duration(org.joda.time.DurationType, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.getPreciseYearMonthType()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.getDurationMillis()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getEndMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getStartMillis()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.getEndInstant()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getEndMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iEndInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Instant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Instant.Instant(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.getEndMillis()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iEndMillis</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.contains(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.contains(org.joda.time.ReadableInterval)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getDuration()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getDurationMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getEndInstant()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.hashCode()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.isAfter(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.isBefore(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.overlaps(org.joda.time.ReadableInterval)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setDurationBeforeEnd(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.setDurationBeforeEnd(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.getStartInstant()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getStartMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iStartInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Instant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Instant.Instant(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.getStartMillis()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iStartMillis</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.contains(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.contains(org.joda.time.ReadableInterval)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getDuration()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getDurationMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getStartInstant()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.hashCode()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.isAfter(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.isBefore(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.overlaps(org.joda.time.ReadableInterval)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setDurationAfterStart(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.setDurationAfterStart(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.hashCode()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getEndMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getStartMillis()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.iDuration</name>
                <outbound type="class" confirmed="yes">org.joda.time.Duration</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableDuration, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInterval)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getDuration()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setDurationAfterStart(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setDurationBeforeEnd(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setEndMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setStartMillis(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.iEndInstant</name>
                <outbound type="class" confirmed="yes">org.joda.time.Instant</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableDuration, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getEndInstant()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setEndMillis(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.iEndMillis</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableDuration, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInterval)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getEndMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setEndMillis(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.iStartInstant</name>
                <outbound type="class" confirmed="yes">org.joda.time.Instant</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getStartInstant()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setStartMillis(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.iStartMillis</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableDuration, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInterval)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getStartMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setStartMillis(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.isAfter(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getEndMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getStartMillis()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.isAfter(org.joda.time.ReadableInstant)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.isAfter(org.joda.time.ReadableInstant)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.isAfter(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.isBefore(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getEndMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getStartMillis()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.isBefore(org.joda.time.ReadableInstant)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.isBefore(org.joda.time.ReadableInstant)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.isBefore(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.overlaps(org.joda.time.ReadableInterval)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getEndMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getStartMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInterval</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInterval.getEndMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInterval.getStartMillis()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.setDurationAfterStart(org.joda.time.ReadableDuration)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getStartMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setEndMillis(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Duration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.addTo(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.isPrecise()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.toDuration()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.setDurationAfterStart(org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.setDurationBeforeEnd(org.joda.time.ReadableDuration)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getEndMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setStartMillis(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Duration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.addTo(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.isPrecise()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.toDuration()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.setDurationBeforeEnd(org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.setEndMillis(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iEndInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iEndMillis</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Duration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Instant</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setDurationAfterStart(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.setDurationAfterStart(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.setEndInstant(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.setEndMillis(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.setStartMillis(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iStartInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iStartMillis</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Duration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Instant</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setDurationBeforeEnd(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.setDurationBeforeEnd(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.setStartInstant(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.setStartMillis(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.toInterval()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Interval</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Interval.Interval(org.joda.time.ReadableInterval)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInterval</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.toMutableInterval()</name>
                <outbound type="class" confirmed="yes">org.joda.time.MutableInterval</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableInterval.MutableInterval(org.joda.time.ReadableInterval)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInterval</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractInterval.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getEndMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getStartMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.lang.StringBuffer, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.ISODateTimeFormat</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinuteSecondFraction()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance(org.joda.time.Chronology)</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.AbstractPartialInstant</name>
            <outbound type="class" confirmed="no">java.io.Serializable</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.AbstractInstant</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.PartialInstant</outbound>
            <inbound type="class" confirmed="yes">org.joda.time.DateOnly</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.MutableDateOnly</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.MutableTimeOnly</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.TimeOnly</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractPartialInstant.AbstractPartialInstant()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.DateOnly()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.MutableDateOnly()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.MutableTimeOnly()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.TimeOnly()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.AbstractInstant()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.iMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.resetUnsupportedFields(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.selectChronologyUTC(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.toLocalTime(long, org.joda.time.Chronology, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterManager</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstance()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstantConverter(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.InstantConverter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.InstantConverter.getChronology(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.InstantConverter.getInstantMillis(java.lang.Object)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.DateOnly(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.MutableDateOnly(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.MutableTimeOnly(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.TimeOnly(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object, org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.AbstractInstant()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.iMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.resetUnsupportedFields(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.selectChronologyUTC(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.toLocalTime(long, org.joda.time.Chronology, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterManager</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstance()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstantConverter(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.InstantConverter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.InstantConverter.getChronology(java.lang.Object, org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.InstantConverter.getInstantMillis(java.lang.Object, org.joda.time.Chronology)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.DateOnly(java.lang.Object, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.MutableDateOnly(java.lang.Object, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.MutableTimeOnly(java.lang.Object, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.TimeOnly(java.lang.Object, org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractPartialInstant.AbstractPartialInstant(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.AbstractInstant()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.iMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.resetUnsupportedFields(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.DateOnly(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.MutableDateOnly(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.MutableTimeOnly(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.TimeOnly(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractPartialInstant.AbstractPartialInstant(long, org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.AbstractInstant()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.iMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.resetUnsupportedFields(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.selectChronologyUTC(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.toLocalTime(long, org.joda.time.Chronology, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.DateOnly(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.DateOnly(int, int, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.DateOnly(long, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.MutableDateOnly(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.MutableDateOnly(int, int, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.MutableDateOnly(long, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.MutableTimeOnly(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.MutableTimeOnly(int, int, int, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.MutableTimeOnly(long, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.TimeOnly(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.TimeOnly(int, int, int, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.TimeOnly(long, org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractPartialInstant.AbstractPartialInstant(org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="no">java.lang.System.currentTimeMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.AbstractInstant()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.iMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.resetUnsupportedFields(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.selectChronologyUTC(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.toLocalTime(long, org.joda.time.Chronology, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.DateOnly(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.MutableDateOnly(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.MutableTimeOnly(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.TimeOnly(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractPartialInstant.AbstractPartialInstant(org.joda.time.DateTimeZone)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.DateOnly(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.MutableDateOnly(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.MutableTimeOnly(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.TimeOnly(org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractPartialInstant.equals(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.equals(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.isMatchingType(java.lang.Object)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractPartialInstant.equals(java.lang.Object, java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.equals(java.lang.Object)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.isMatchingType(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractPartialInstant.getChronology()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.iChronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateOnly(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toTimeOnly(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.centuryOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.dayOfMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.dayOfWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.dayOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.era()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getCenturyOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getDayOfMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getDayOfWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getDayOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getLowerLimit()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getMonthOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getWeekOfWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getYearOfCentury()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getYearOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.monthOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.weekOfWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.weekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.withMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.year()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.yearOfCentury()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.yearOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addDays(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addMonths(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addWeeks(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addWeekyears(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addYears(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.centuryOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.dayOfMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.dayOfWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.dayOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.era()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getCenturyOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getDayOfMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getDayOfWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getDayOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getLowerLimit()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getMonthOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getWeekOfWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getYearOfCentury()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getYearOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.monthOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setDate(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setDayOfMonth(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setDayOfWeek(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setDayOfYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setMonthOfYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setWeekOfWeekyear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setWeekyear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.weekOfWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.weekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.withMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.year()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.yearOfCentury()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.yearOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.addHours(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.addMillis(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.addMinutes(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.addSeconds(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.clockhourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.clockhourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getClockhourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getClockhourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getHalfdayOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getHourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getHourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getMillisOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getMillisOfSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getMinuteOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getMinuteOfHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getSecondOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getSecondOfMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getUpperLimit()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.halfdayOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.hourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.hourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.millisOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.millisOfSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.minuteOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.minuteOfHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.secondOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.secondOfMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setClockhourOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setClockhourOfHalfday(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setHalfdayOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setHourOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setHourOfHalfday(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillisOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillisOfSecond(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMinuteOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMinuteOfHour(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setSecondOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setSecondOfMinute(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setTime(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.withMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.clockhourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.clockhourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getClockhourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getClockhourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getHalfdayOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getHourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getHourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getMillisOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getMillisOfSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getMinuteOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getMinuteOfHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getSecondOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getSecondOfMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getUpperLimit()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.halfdayOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.hourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.hourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.millisOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.millisOfSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.minuteOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.minuteOfHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.secondOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.secondOfMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.withMillis(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractPartialInstant.getLowerLimit()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.hashCode()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.isMatchingType(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.resetSupportedFields(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.resetUnsupportedFields(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractPartialInstant.getMillis()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.iMillis</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getCenturyOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getDayOfMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getDayOfWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getDayOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getMonthOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getWeekOfWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getYearOfCentury()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getYearOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.withMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.add(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.add(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addDays(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addMonths(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addWeeks(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addWeekyears(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addWrapped(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addYears(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getCenturyOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getDayOfMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getDayOfWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getDayOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getMonthOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getWeekOfWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getYearOfCentury()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getYearOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.set(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setDayOfMonth(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setDayOfWeek(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setDayOfYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setMonthOfYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setWeekOfWeekyear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setWeekyear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.add(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.add(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.addHours(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.addMillis(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.addMinutes(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.addSeconds(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.addWrapped(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getClockhourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getClockhourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getHalfdayOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getHourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getHourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getMillisOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getMillisOfSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getMinuteOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getMinuteOfHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getSecondOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getSecondOfMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.set(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setClockhourOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setClockhourOfHalfday(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setHalfdayOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setHourOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setHourOfHalfday(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillisOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillisOfSecond(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMinuteOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMinuteOfHour(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setSecondOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setSecondOfMinute(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getClockhourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getClockhourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getHalfdayOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getHourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getHourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getMillisOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getMillisOfSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getMinuteOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getMinuteOfHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getSecondOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getSecondOfMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.withMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.addToCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.addToCopy(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.addWrappedToCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundCeilingCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundFloorCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundHalfCeilingCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundHalfEvenCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundHalfFloorCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.setCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.setCopy(java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.addToCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.addToCopy(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.addWrappedToCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundCeilingCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundFloorCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundHalfCeilingCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundHalfEvenCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundHalfFloorCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.setCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.setCopy(java.lang.String, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractPartialInstant.getMillis(org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.isMatchingType(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getDateTimeZone()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractPartialInstant.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.isMatchingType(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.resetSupportedFields(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffsetFromLocal(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getDateTimeZone()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis(org.joda.time.ReadableInstant)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractPartialInstant.getUpperLimit()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.hashCode()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.isMatchingType(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.resetSupportedFields(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.resetUnsupportedFields(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractPartialInstant.hashCode()</name>
                <outbound type="feature" confirmed="no">java.lang.Object.hashCode()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.hashCode()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getLowerLimit()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getUpperLimit()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractPartialInstant.iChronology</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(long, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.setChronology(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractPartialInstant.iMillis</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(long, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.setMillis(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractPartialInstant.isMatchingType(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.equals(java.lang.Object, java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getLowerLimit()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getUpperLimit()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.PartialInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.PartialInstant.getLowerLimit()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.PartialInstant.getUpperLimit()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractPartialInstant.resetSupportedFields(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getLowerLimit()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getUpperLimit()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.remainder(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundFloor(long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractPartialInstant.resetUnsupportedFields(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getLowerLimit()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getUpperLimit()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.remainder(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundFloor(long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(long, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.setMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.withMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.withMillis(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractPartialInstant.selectChronologyUTC(org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeZone()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.withUTC()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(long, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.setChronology(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractPartialInstant.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractPartialInstant.setChronology(org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.selectChronologyUTC(org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setChronology(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractPartialInstant.setMillis(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.setMillis(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterManager</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstance()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstantConverter(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.InstantConverter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.InstantConverter.getInstantMillis(java.lang.Object)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setMillis(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillis(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractPartialInstant.setMillis(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.iMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.resetUnsupportedFields(long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.setMillis(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillis(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractPartialInstant.toLocalTime(long, org.joda.time.Chronology, org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeZone()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(long, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.AbstractPartialInstant.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.Chronology</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(int, int, int, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(int, int, int, int, int, int, int, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(int, int, int, int, int, int, int, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(long, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getCenturyOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getDayOfMonth()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getDayOfWeek()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getDayOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getHourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillisOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillisOfSecond()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMinuteOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMinuteOfHour()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMonthOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getSecondOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getSecondOfMinute()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getWeekOfWeekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getWeekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getYearOfCentury()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getYearOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.iChronology</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.moveDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.selectChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.setChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.setDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.toString(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.toString(java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(long, int, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.equals(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.getChronology()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.getDateTimeZone()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.hashCode()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateOnly(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toTimeOnly(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toTrustedISODateTime()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(long, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.iChronology</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.selectChronologyUTC(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.setChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.toLocalTime(long, org.joda.time.Chronology, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.DateOnly(int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.DateOnly(int, int, int, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.DateOnly(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.DateOnly(long, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.DateOnly(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.centuryOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.dayOfMonth()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.dayOfWeek()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.dayOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.era()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getCenturyOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getDayOfMonth()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getDayOfWeek()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getDayOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getLowerLimit()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getMonthOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getWeekOfWeekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getWeekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getYearOfCentury()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getYearOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.monthOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.setChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.weekOfWeekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.weekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.withMillis(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.year()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.yearOfCentury()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.yearOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(int, int, int, int, int, int, int, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(long, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.centuryOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.dayOfMonth()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.dayOfWeek()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.dayOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.era()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.hourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.millisOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.millisOfSecond()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.minuteOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.minuteOfHour()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.monthOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.secondOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.secondOfMinute()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.setChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.weekOfWeekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.weekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.withMillis(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.year()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.yearOfCentury()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.yearOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.getDateOnlyInstance(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.getTimeOnlyInstance(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$AverageYearMonthType.DurationType$AverageYearMonthType(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$AverageYearMonthType.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$AverageYearMonthType.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.DurationType$DayHourType(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.days()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.getChronology()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.hours()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.iChronology</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.millis()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.minutes()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.seconds()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.getChronology()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MillisType.getChronology()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MillisType.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearMonthType.DurationType$PreciseYearMonthType(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearMonthType.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearWeekType.DurationType$PreciseYearWeekType(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearWeekType.weeks()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearWeekType.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearMonthType.DurationType$YearMonthType(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearMonthType.months()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearMonthType.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearMonthType.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearMonthType.years()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearWeekType.DurationType$YearWeekType(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearWeekType.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearWeekType.weeks()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearWeekType.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearWeekType.years()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.equals(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getAverageYearMonthType()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getAverageYearMonthType(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getChronology()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getDayHourType()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getDayHourType(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getPreciseYearMonthType()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getPreciseYearWeekType()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getYearMonthType()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getYearMonthType(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getYearWeekType()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getYearWeekType(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.hashCode()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Instant.getChronology()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Instant.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.MutableDateOnly(int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.MutableDateOnly(int, int, int, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.MutableDateOnly(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.MutableDateOnly(long, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.MutableDateOnly(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addDays(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addMonths(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addWeeks(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addWeekyears(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addYears(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.centuryOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.dayOfMonth()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.dayOfWeek()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.dayOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.era()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getCenturyOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getDayOfMonth()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getDayOfWeek()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getDayOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getLowerLimit()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getMonthOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getWeekOfWeekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getWeekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getYearOfCentury()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getYearOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.monthOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setDate(int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setDayOfMonth(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setDayOfWeek(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setDayOfYear(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setMonthOfYear(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setWeekOfWeekyear(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setWeekyear(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setYear(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.weekOfWeekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.weekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.withMillis(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.year()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.yearOfCentury()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.yearOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(int, int, int, int, int, int, int, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(long, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addDays(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addHours(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addMillis(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addMinutes(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addMonths(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addSeconds(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addWeeks(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addWeekyears(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addYears(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.centuryOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.dayOfMonth()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.dayOfWeek()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.dayOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.era()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.hourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.millisOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.millisOfSecond()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.minuteOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.minuteOfHour()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.monthOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.secondOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.secondOfMinute()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDate(int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDate(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDateTime(int, int, int, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDayOfMonth(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDayOfWeek(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDayOfYear(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setHourOfDay(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillisOfDay(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillisOfSecond(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMinuteOfDay(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMinuteOfHour(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMonthOfYear(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setSecondOfDay(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setSecondOfMinute(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setTime(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setTime(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setWeekOfWeekyear(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setWeekyear(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setYear(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.weekOfWeekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.weekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.withMillis(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.year()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.yearOfCentury()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.yearOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.MutableTimeOnly(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.MutableTimeOnly(int, int, int, int, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.MutableTimeOnly(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.MutableTimeOnly(long, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.MutableTimeOnly(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.addHours(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.addMillis(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.addMinutes(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.addSeconds(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.clockhourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.clockhourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getClockhourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getClockhourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getHalfdayOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getHourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getHourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getMillisOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getMillisOfSecond()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getMinuteOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getMinuteOfHour()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getSecondOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getSecondOfMinute()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getUpperLimit()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.halfdayOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.hourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.hourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.millisOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.millisOfSecond()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.minuteOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.minuteOfHour()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.secondOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.secondOfMinute()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setClockhourOfDay(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setClockhourOfHalfday(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setHalfdayOfDay(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setHourOfDay(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setHourOfHalfday(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillisOfDay(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillisOfSecond(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMinuteOfDay(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMinuteOfHour(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setSecondOfDay(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setSecondOfMinute(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setTime(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.withMillis(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.PartialInstant.getChronology()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadWritableInstant.setChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableDateTime.toDateOnly(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableDateTime.toDateTime(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableDateTime.toMutableDateTime(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableDateTime.toTimeOnly(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.addTo(long, int, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getChronology()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.TimeOnly(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.TimeOnly(int, int, int, int, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.TimeOnly(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.TimeOnly(long, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.TimeOnly(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.clockhourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.clockhourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getClockhourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getClockhourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getHalfdayOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getHourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getHourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getMillisOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getMillisOfSecond()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getMinuteOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getMinuteOfHour()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getSecondOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getSecondOfMinute()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getUpperLimit()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.halfdayOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.hourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.hourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.millisOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.millisOfSecond()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.minuteOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.minuteOfHour()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.secondOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.secondOfMinute()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.setChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.withMillis(long)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.AbstractChronology</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.withUTC()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.AbstractGJChronology(org.joda.time.Chronology, java.lang.Object, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateOnlyMillis(int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateTimeMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateTimeZone()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.AssembledChronology(org.joda.time.Chronology, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateOnlyMillis(int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateOnlyMillis(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeZone()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getTimeOnlyMillis(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iBase</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.BuddhistChronology(org.joda.time.Chronology, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.withUTC()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.CopticChronology(org.joda.time.Chronology, java.lang.Object, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getDateOnlyMillis(int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.withUTC()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.GJChronology(org.joda.time.Chronology, org.joda.time.chrono.JulianChronology, org.joda.time.chrono.GregorianChronology, org.joda.time.Instant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.GJChronology(org.joda.time.chrono.JulianChronology, org.joda.time.chrono.GregorianChronology, org.joda.time.Instant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.convertByWeekyear(long, org.joda.time.Chronology, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.convertByYear(long, org.joda.time.Chronology, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateOnlyMillis(int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeZone()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.gregorianToJulianByWeekyear(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.gregorianToJulianByYear(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.julianToGregorianByWeekyear(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.julianToGregorianByYear(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.withUTC()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.GregorianChronology(org.joda.time.Chronology, java.lang.Object, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.withUTC()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.ISOChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.withUTC()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.JulianChronology(org.joda.time.Chronology, java.lang.Object, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.withUTC()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.LenientChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.getInstance(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.iWithUTC</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.withUTC()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.getMessage()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.LimitChronology(org.joda.time.Chronology, org.joda.time.DateTime, org.joda.time.DateTime)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getDateOnlyMillis(int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getDateOnlyMillis(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getDateTimeMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getInstance(org.joda.time.Chronology, org.joda.time.ReadableDateTime, org.joda.time.ReadableDateTime)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getTimeOnlyMillis(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.withUTC()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.StrictChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.getInstance(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.iWithUTC</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.withUTC()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.ZonedChronology(org.joda.time.Chronology, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getDateOnlyMillis(int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getDateTimeMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getInstance(org.joda.time.Chronology, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.withUTC()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.getChronology(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.getChronology(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.getInstantMillis(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.InstantConverter.getChronology(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.InstantConverter.getChronology(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.InstantConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.InstantConverter.getInstantMillis(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.getChronology(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.getInstantMillis(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.getChronology(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getInstantMillis(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getInstantMillis(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.createBucket(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.getChronology()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.getDateTimeZone()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseDateTime(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseMutableDateTime(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseMutableDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.print(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.io.Writer, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.getChronology()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.getChronology()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.DateTimeFormat(org.joda.time.Chronology, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.Chronology, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.DateTimeZone, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstanceUTC()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.iChrono</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$AbstractFormatter.DateTimeFormatterBuilder$AbstractFormatter(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$AbstractFormatter.getChronology()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$AbstractFormatter.iChrono</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.DateTimeFormatterBuilder$CharacterLiteral(org.joda.time.Chronology, char)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.DateTimeFormatterBuilder$Composite(org.joda.time.Chronology, java.util.ArrayList)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.DateTimeFormatterBuilder$Fraction(org.joda.time.Chronology, org.joda.time.DateTimeField, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$MatchingParser.DateTimeFormatterBuilder$MatchingParser(org.joda.time.Chronology, org.joda.time.format.DateTimeParser[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.DateTimeFormatterBuilder$NumberFormatter(org.joda.time.Chronology, org.joda.time.DateTimeField, int, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.DateTimeFormatterBuilder$PaddedNumber(org.joda.time.Chronology, org.joda.time.DateTimeField, int, boolean, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.DateTimeFormatterBuilder$StringLiteral(org.joda.time.Chronology, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.DateTimeFormatterBuilder$TextField(org.joda.time.Chronology, org.joda.time.DateTimeField, java.util.Locale, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.DateTimeFormatterBuilder$TimeZoneOffsetFormatter(org.joda.time.Chronology, java.lang.String, boolean, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.DateTimeFormatterBuilder$TimeZonePrinter(org.joda.time.Chronology, java.util.Locale, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber.DateTimeFormatterBuilder$UnpaddedNumber(org.joda.time.Chronology, org.joda.time.DateTimeField, int, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.DateTimeZone, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendCenturyOfEra(int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendClockhourOfDay(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendClockhourOfHalfday(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfMonth(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfWeek(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfWeekShortText()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfWeekText()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfYear(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDecimal(org.joda.time.DateTimeField, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendEraText()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFraction(org.joda.time.DateTimeField, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfDay(int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfHour(int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfMinute(int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfSecond(int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendHalfdayOfDayText()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendHourOfDay(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendHourOfHalfday(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(char)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMillisOfDay(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMillisOfSecond(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMinuteOfDay(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMinuteOfHour(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMonthOfYear(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMonthOfYearShortText()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMonthOfYearText()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendOptional(org.joda.time.format.DateTimeParser)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendSecondOfDay(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendSecondOfMinute(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendShortText(org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendSignedDecimal(org.joda.time.DateTimeField, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendText(org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneName()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneOffset(java.lang.String, boolean, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneShortName()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendWeekOfWeekyear(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendWeekyear(int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendYear(int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendYearOfCentury(int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendYearOfEra(int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.getChronology()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.getFormatter()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChrono</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.getChronology()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.getChronology()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.ISODateTimeFormat(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicDate()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicDateTime()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicTime()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicWeekDate()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicWeekDateTime()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateElementParser()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHour()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinute()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinuteSecond()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinuteSecondFraction()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateParser()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTime()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTimeParser()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dayOfMonthElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dayOfWeekElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dayOfYearElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.fractionElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstanceUTC()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinute()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinuteSecond()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinuteSecondFraction()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.minuteElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.monthElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.offsetElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.secondElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.time()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeElementParser()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeParser()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekDateTime()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearWeek()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearWeekDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearMonth()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearMonthDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.next(long, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.previous(long, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonth(org.joda.time.Chronology, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonthNext(org.joda.time.Chronology, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonthPrevious(org.joda.time.Chronology, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfWeek(org.joda.time.Chronology, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setInstant(int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.cLenientISO</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.getLenientISOChronology()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseTime(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.centuries()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.centuryOfEra()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getCenturyOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.centuryOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getCenturyOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.centuryOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.centuryOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getCenturyOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.centuryOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendCenturyOfEra(int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.clockhourOfDay()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.clockhourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getClockhourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setClockhourOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.clockhourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getClockhourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendClockhourOfDay(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.clockhourOfHalfday()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.clockhourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getClockhourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setClockhourOfHalfday(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.clockhourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getClockhourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendClockhourOfHalfday(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.dayOfMonth()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getDayOfMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.dayOfMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getDayOfMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.dayOfMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.dayOfMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getDayOfMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setDayOfMonth(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.dayOfMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDayOfMonth(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.convertByYear(long, org.joda.time.Chronology, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfMonth(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonth(org.joda.time.Chronology, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.dayOfWeek()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getDayOfWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.dayOfWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getDayOfWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.dayOfWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.dayOfWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getDayOfWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setDayOfWeek(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.dayOfWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDayOfWeek(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.convertByWeekyear(long, org.joda.time.Chronology, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfWeek(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfWeekShortText()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfWeekText()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfWeek(org.joda.time.Chronology, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.dayOfYear()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getDayOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.dayOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getDayOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getLowerLimit()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.dayOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.getDateOnlyInstance(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.getTimeOnlyInstance(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.dayOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getDayOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getLowerLimit()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setDayOfYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.dayOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDayOfYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getUpperLimit()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getUpperLimit()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfDay(int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.days()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.days()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearMonthType.DurationType$PreciseYearMonthType(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearWeekType.DurationType$PreciseYearWeekType(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addDays(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addDays(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.era()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.era()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.era()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.era()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.era()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendEraText()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.eras()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.getDateOnlyMillis(int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.DateOnly(int, int, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.MutableDateOnly(int, int, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setDate(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateOnlyMillis(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateOnlyMillis(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getDateOnlyMillis(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateOnlyMillis(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getDateOnlyMillis(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getDateOnlyMillis(int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.getDateOnlyMillis(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDate(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setTime(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateOnlyMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getDateOnlyMillis(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.getDateTimeMillis(int, int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateTimeMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.convertByYear(long, org.joda.time.Chronology, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getDateTimeMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getDateTimeMillis(int, int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.getDateTimeMillis(int, int, int, int, int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(int, int, int, int, int, int, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(int, int, int, int, int, int, int, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDate(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDateTime(int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.getDateTimeMillis(long, int, int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setTime(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.getDateTimeZone()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.moveDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.setDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.getDateTimeZone()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.selectChronologyUTC(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.toLocalTime(long, org.joda.time.Chronology, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateTimeZone()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeZone()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeZone()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.getInstantMillis(java.lang.Object, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.createBucket(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.getDateTimeZone()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.print(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.io.Writer, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.getTimeOnlyMillis(int, int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.MutableTimeOnly(int, int, int, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setTime(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.TimeOnly(int, int, int, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.getTimeOnlyMillis(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDate(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setTime(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getTimeOnlyMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getTimeOnlyMillis(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.halfdayOfDay()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getHalfdayOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.halfdayOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setHalfdayOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getHalfdayOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.halfdayOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendHalfdayOfDayText()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.hourOfDay()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getHourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.hourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.hourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setHourOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getHourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.hourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setHourOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getHourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.hourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfHour(int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendHourOfDay(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.hourOfHalfday()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getHourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.hourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setHourOfHalfday(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getHourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.hourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendHourOfHalfday(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.hours()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.hours()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addHours(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.addHours(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.millis()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.millis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addMillis(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.addMillis(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.millisOfDay()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillisOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.millisOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.millisOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillisOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getMillisOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.millisOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillisOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getMillisOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.millisOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.convertByWeekyear(long, org.joda.time.Chronology, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.convertByYear(long, org.joda.time.Chronology, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMillisOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.next(long, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.previous(long, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setInstant(int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.millisOfSecond()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillisOfSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.millisOfSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.millisOfSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillisOfSecond(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getMillisOfSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.millisOfSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillisOfSecond(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getMillisOfSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.millisOfSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMillisOfSecond(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.minuteOfDay()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMinuteOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.minuteOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.minuteOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMinuteOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getMinuteOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.minuteOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMinuteOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getMinuteOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.minuteOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfMinute(int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMinuteOfDay(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.minuteOfHour()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMinuteOfHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.minuteOfHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.minuteOfHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMinuteOfHour(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getMinuteOfHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.minuteOfHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMinuteOfHour(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getMinuteOfHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.minuteOfHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMinuteOfHour(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.minutes()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.minutes()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addMinutes(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.addMinutes(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.monthOfYear()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMonthOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getMonthOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.monthOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.monthOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getMonthOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.monthOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setMonthOfYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.monthOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMonthOfYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.convertByYear(long, org.joda.time.Chronology, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMonthOfYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMonthOfYearShortText()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMonthOfYearText()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.next(long, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.previous(long, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonth(org.joda.time.Chronology, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setInstant(int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.months()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$AverageYearMonthType.DurationType$AverageYearMonthType(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearMonthType.months()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addMonths(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addMonths(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.secondOfDay()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getSecondOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.secondOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.secondOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setSecondOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getSecondOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.secondOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setSecondOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getSecondOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.secondOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfSecond(int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendSecondOfDay(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.secondOfMinute()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getSecondOfMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.secondOfMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.secondOfMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setSecondOfMinute(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getSecondOfMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.secondOfMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setSecondOfMinute(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getSecondOfMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.secondOfMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendSecondOfMinute(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.seconds()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.seconds()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addSeconds(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.addSeconds(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.weekOfWeekyear()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getWeekOfWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getWeekOfWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.weekOfWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.weekOfWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getWeekOfWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setWeekOfWeekyear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.weekOfWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setWeekOfWeekyear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.weekOfWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.convertByWeekyear(long, org.joda.time.Chronology, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendWeekOfWeekyear(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.weeks()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearWeekType.weeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearWeekType.weeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addWeeks(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addWeeks(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.weekyear()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.weekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.weekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setWeekyear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.weekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setWeekyear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.weekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.convertByWeekyear(long, org.joda.time.Chronology, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendWeekyear(int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.weekyears()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearWeekType.years()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addWeekyears(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addWeekyears(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.withDateTimeZone(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.moveDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.setDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.getChronology(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.withUTC()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateOnly(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toTimeOnly(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.selectChronologyUTC(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.withUTC()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.withUTC()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getInstance(org.joda.time.Chronology, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.year()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.year()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.year()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.year()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.year()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.convertByYear(long, org.joda.time.Chronology, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendYear(int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.next(long, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.previous(long, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonthNext(org.joda.time.Chronology, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonthPrevious(org.joda.time.Chronology, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setInstant(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.next(long, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.nextTransition(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.yearOfCentury()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getYearOfCentury()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getYearOfCentury()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.yearOfCentury()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.yearOfCentury()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getYearOfCentury()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.yearOfCentury()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.yearOfCentury()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendYearOfCentury(int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.yearOfEra()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getYearOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getYearOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.yearOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.yearOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getYearOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.yearOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.yearOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendYearOfEra(int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Chronology.years()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$AverageYearMonthType.DurationType$AverageYearMonthType(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearMonthType.years()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addYears(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addYears(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.DateOnly</name>
            <outbound type="class" confirmed="no">java.io.Serializable</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.AbstractPartialInstant</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateOnly()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateOnly(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableDateTime.toDateOnly()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableDateTime.toDateOnly(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.DateOnlyFieldProperty(org.joda.time.DateOnly, org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.addToCopy(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.addToCopy(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.addWrappedToCopy(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.getDateTime()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.getInstant()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.iInstant</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundCeilingCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundFloorCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundHalfCeilingCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundHalfEvenCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundHalfFloorCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.setCopy(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.setCopy(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.setCopy(java.lang.String, java.util.Locale)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.DateOnly()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.DateOnly(int, int, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateOnlyMillis(int, int, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.DateOnly(int, int, int, org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateOnlyMillis(int, int, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.DateOnly(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateOnly()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.DateOnly(java.lang.Object, org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateOnly(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.DateOnly(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.DateOnly(long, org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.withMillis(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.DateOnly(org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.DateOnly(org.joda.time.DateTimeZone)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.centuryOfEra()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.centuryOfEra()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.DateOnlyFieldProperty(org.joda.time.DateOnly, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.dayOfMonth()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfMonth()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.DateOnlyFieldProperty(org.joda.time.DateOnly, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.dayOfWeek()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfWeek()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.DateOnlyFieldProperty(org.joda.time.DateOnly, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.dayOfYear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfYear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.DateOnlyFieldProperty(org.joda.time.DateOnly, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.era()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.era()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.DateOnlyFieldProperty(org.joda.time.DateOnly, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.getCenturyOfEra()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.centuryOfEra()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.getDayOfMonth()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfMonth()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.getDayOfWeek()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfWeek()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.getDayOfYear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfYear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.getEra()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.era()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.getLowerLimit()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfYear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.getMonthOfYear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.monthOfYear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.getUpperLimit()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.getWeekOfWeekyear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weekOfWeekyear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.getWeekyear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weekyear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.getYear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.year()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.getYearOfCentury()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.yearOfCentury()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.getYearOfEra()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.yearOfEra()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.monthOfYear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.monthOfYear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.DateOnlyFieldProperty(org.joda.time.DateOnly, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.setChronology(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.setMillis(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.print(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.ISODateTimeFormat</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.date()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance(org.joda.time.Chronology)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.weekOfWeekyear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weekOfWeekyear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.DateOnlyFieldProperty(org.joda.time.DateOnly, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.weekyear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weekyear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.DateOnlyFieldProperty(org.joda.time.DateOnly, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.withChronology(org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.withUTC()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateOnly.DateOnly(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.withMillis(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.resetUnsupportedFields(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateOnly.DateOnly(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.addToCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.addToCopy(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.addWrappedToCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundCeilingCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundFloorCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundHalfCeilingCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundHalfEvenCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundHalfFloorCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.setCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.setCopy(java.lang.String, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.year()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.year()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.DateOnlyFieldProperty(org.joda.time.DateOnly, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.yearOfCentury()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.yearOfCentury()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.DateOnlyFieldProperty(org.joda.time.DateOnly, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateOnly.yearOfEra()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.yearOfEra()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.DateOnlyFieldProperty(org.joda.time.DateOnly, org.joda.time.DateTimeField)</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.DateTime</name>
            <outbound type="class" confirmed="no">java.io.Serializable</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.AbstractDateTime</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.ReadableDateTime</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toTrustedISODateTime()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableDateTime.toDateTime()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableDateTime.toDateTime(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableDateTime.toDateTime(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.getMessage()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.LimitChronology(org.joda.time.Chronology, org.joda.time.DateTime, org.joda.time.DateTime)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getInstance(org.joda.time.Chronology, org.joda.time.ReadableDateTime, org.joda.time.ReadableDateTime)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getLowerLimit()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getUpperLimit()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.iLowerLimit</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.iUpperLimit</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseDateTime(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseDateTime(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.parseDateTime(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.parseDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseDateTime(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.DateTimeFieldProperty(org.joda.time.DateTime, org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.addToCopy(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.addToCopy(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.addWrappedToCopy(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.getInstant()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.iInstant</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundCeilingCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundFloorCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundHalfCeilingCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundHalfEvenCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundHalfFloorCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.setCopy(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.setCopy(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.setCopy(java.lang.String, java.util.Locale)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.DateTime()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.DateTime(int, int, int, int, int, int, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(int, int, int, int, int, int, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.DateTime(int, int, int, int, int, int, int, org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(int, int, int, int, int, int, int, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.DateTime(int, int, int, int, int, int, int, org.joda.time.DateTimeZone)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(int, int, int, int, int, int, int, org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.DateTime(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.DateTime(java.lang.Object, org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toTrustedISODateTime()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.DateTime(java.lang.Object, org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object, org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.DateTime(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.DateTime(long, org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.withMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseDateTime(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.DateTime(long, org.joda.time.DateTimeZone)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(long, org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.DateTime(org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.DateTime(org.joda.time.DateTimeZone)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.centuryOfEra()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.centuryOfEra()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.DateTimeFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.DateTimeFieldProperty(org.joda.time.DateTime, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.dayOfMonth()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfMonth()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.DateTimeFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.DateTimeFieldProperty(org.joda.time.DateTime, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.dayOfWeek()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfWeek()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.DateTimeFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.DateTimeFieldProperty(org.joda.time.DateTime, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.dayOfYear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfYear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.DateTimeFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.DateTimeFieldProperty(org.joda.time.DateTime, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.era()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.era()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.DateTimeFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.DateTimeFieldProperty(org.joda.time.DateTime, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.hourOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.hourOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.DateTimeFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.DateTimeFieldProperty(org.joda.time.DateTime, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.millisOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millisOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.DateTimeFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.DateTimeFieldProperty(org.joda.time.DateTime, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.millisOfSecond()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millisOfSecond()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.DateTimeFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.DateTimeFieldProperty(org.joda.time.DateTime, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.minuteOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.minuteOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.DateTimeFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.DateTimeFieldProperty(org.joda.time.DateTime, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.minuteOfHour()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.minuteOfHour()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.DateTimeFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.DateTimeFieldProperty(org.joda.time.DateTime, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.monthOfYear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.monthOfYear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.DateTimeFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.DateTimeFieldProperty(org.joda.time.DateTime, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.secondOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.secondOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.DateTimeFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.DateTimeFieldProperty(org.joda.time.DateTime, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.secondOfMinute()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.secondOfMinute()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.DateTimeFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.DateTimeFieldProperty(org.joda.time.DateTime, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.setChronology(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.setMillis(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.print(org.joda.time.ReadableInstant)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.ISODateTimeFormat</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTime()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance(org.joda.time.Chronology)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.weekOfWeekyear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weekOfWeekyear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.DateTimeFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.DateTimeFieldProperty(org.joda.time.DateTime, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.weekyear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weekyear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.DateTimeFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.DateTimeFieldProperty(org.joda.time.DateTime, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.withChronology(org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.withMillis(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.addToCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.addToCopy(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.addWrappedToCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundCeilingCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundFloorCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundHalfCeilingCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundHalfEvenCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundHalfFloorCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.setCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.setCopy(java.lang.String, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.year()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.year()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.DateTimeFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.DateTimeFieldProperty(org.joda.time.DateTime, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.yearOfCentury()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.yearOfCentury()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.DateTimeFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.DateTimeFieldProperty(org.joda.time.DateTime, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTime.yearOfEra()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.yearOfEra()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.DateTimeFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.DateTimeFieldProperty(org.joda.time.DateTime, org.joda.time.DateTimeField)</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.DateTimeComparator</name>
            <outbound type="class" confirmed="no">java.io.Serializable</outbound>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="no">java.util.Comparator</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeComparator.DateTimeComparator(org.joda.time.DateTimeField, org.joda.time.DateTimeField)</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.iLowerLimit</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.iUpperLimit</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.getInstance(org.joda.time.DateTimeField, org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeComparator.INSTANCE</name>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.getInstance()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.getInstance(org.joda.time.DateTimeField, org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeComparator.compare(java.lang.Object, java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.getMillisFromObject(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.iLowerLimit</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.iUpperLimit</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.remainder(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundFloor(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis(org.joda.time.ReadableInstant)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeComparator.getDateOnlyInstance(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.getInstance(org.joda.time.DateTimeField, org.joda.time.DateTimeField)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeComparator.getInstance()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.INSTANCE</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeComparator.getInstance(org.joda.time.DateTimeField)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.getInstance(org.joda.time.DateTimeField, org.joda.time.DateTimeField)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeComparator.getInstance(org.joda.time.DateTimeField, org.joda.time.DateTimeField)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.DateTimeComparator(org.joda.time.DateTimeField, org.joda.time.DateTimeField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.INSTANCE</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.getDateOnlyInstance(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.getInstance(org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.getTimeOnlyInstance(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.readResolve()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeComparator.getLowerLimit()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.iLowerLimit</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeComparator.getMillisFromObject(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterManager</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstance()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstantConverter(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.InstantConverter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.InstantConverter.getInstantMillis(java.lang.Object)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.compare(java.lang.Object, java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeComparator.getTimeOnlyInstance(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.getInstance(org.joda.time.DateTimeField, org.joda.time.DateTimeField)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeComparator.getUpperLimit()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.iUpperLimit</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeComparator.iLowerLimit</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.DateTimeComparator(org.joda.time.DateTimeField, org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.compare(java.lang.Object, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.getLowerLimit()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeComparator.iUpperLimit</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.DateTimeComparator(org.joda.time.DateTimeField, org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.compare(java.lang.Object, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.getUpperLimit()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeComparator.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.getInstance(org.joda.time.DateTimeField, org.joda.time.DateTimeField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.iLowerLimit</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.iUpperLimit</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeComparator.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeComparator.static {}</name>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.DateTimeComparator(org.joda.time.DateTimeField, org.joda.time.DateTimeField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.INSTANCE</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeComparator.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.iLowerLimit</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.iUpperLimit</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getName()</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.DateTimeConstants</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.AD</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.AM</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.APRIL</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.AUGUST</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.BC</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.BCE</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.CE</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.DAYS_PER_WEEK</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.DECEMBER</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.DateTimeConstants()</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.FEBRUARY</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.FRIDAY</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.HOURS_PER_DAY</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.HOURS_PER_WEEK</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.JANUARY</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.JULY</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.JUNE</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.MARCH</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.MAY</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.MILLIS_PER_DAY</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.MILLIS_PER_HOUR</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.MILLIS_PER_MINUTE</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.MILLIS_PER_SECOND</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.MILLIS_PER_WEEK</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.MINUTES_PER_DAY</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.MINUTES_PER_HOUR</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.MINUTES_PER_WEEK</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.MONDAY</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.NOVEMBER</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.OCTOBER</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.PM</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.SATURDAY</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.SECONDS_PER_DAY</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.SECONDS_PER_HOUR</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.SECONDS_PER_MINUTE</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.SECONDS_PER_WEEK</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.SEPTEMBER</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.SUNDAY</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.THURSDAY</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.TUESDAY</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeConstants.WEDNESDAY</name>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.DateTimeField</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getCenturyOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getDayOfMonth()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getDayOfWeek()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getDayOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getHourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillisOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillisOfSecond()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMinuteOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMinuteOfHour()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMonthOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getSecondOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getSecondOfMinute()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getWeekOfWeekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getWeekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getYearOfCentury()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getYearOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.get(org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getLowerLimit()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getUpperLimit()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.hashCode()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.isMatchingType(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.resetSupportedFields(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.resetUnsupportedFields(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.centuryOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.clockhourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.clockhourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfMonth()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfWeek()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.era()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.halfdayOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.hourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.hourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.millisOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.millisOfSecond()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.minuteOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.minuteOfHour()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.monthOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.secondOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.secondOfMinute()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.weekOfWeekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.weekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.year()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.yearOfCentury()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.yearOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.centuryOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.dayOfMonth()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.dayOfWeek()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.dayOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.era()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getCenturyOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getDayOfMonth()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getDayOfWeek()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getDayOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getLowerLimit()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getMonthOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getUpperLimit()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getWeekOfWeekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getWeekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getYearOfCentury()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getYearOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.monthOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.weekOfWeekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.weekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.year()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.yearOfCentury()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.yearOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.centuryOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.dayOfMonth()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.dayOfWeek()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.dayOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.era()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.hourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.millisOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.millisOfSecond()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.minuteOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.minuteOfHour()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.monthOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.secondOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.secondOfMinute()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.weekOfWeekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.weekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.year()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.yearOfCentury()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.yearOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.DateTimeComparator(org.joda.time.DateTimeField, org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.compare(java.lang.Object, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.getDateOnlyInstance(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.getInstance(org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.getInstance(org.joda.time.DateTimeField, org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.getLowerLimit()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.getTimeOnlyInstance(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.getUpperLimit()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.iLowerLimit</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.iUpperLimit</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.add(org.joda.time.DateTimeField, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addWrapped(org.joda.time.DateTimeField, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.centuryOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.dayOfMonth()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.dayOfWeek()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.dayOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.era()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getCenturyOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getDayOfMonth()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getDayOfWeek()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getDayOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getLowerLimit()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getMonthOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getUpperLimit()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getWeekOfWeekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getWeekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getYearOfCentury()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getYearOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.monthOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.set(org.joda.time.DateTimeField, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setDayOfMonth(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setDayOfWeek(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setDayOfYear(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setMonthOfYear(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setWeekOfWeekyear(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setWeekyear(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setYear(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.weekOfWeekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.weekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.year()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.yearOfCentury()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.yearOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.add(org.joda.time.DateTimeField, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addWrapped(org.joda.time.DateTimeField, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.centuryOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.dayOfMonth()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.dayOfWeek()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.dayOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.era()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.hourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.millisOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.millisOfSecond()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.minuteOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.minuteOfHour()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.monthOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.secondOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.secondOfMinute()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.set(org.joda.time.DateTimeField, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDayOfMonth(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDayOfWeek(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDayOfYear(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setHourOfDay(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillisOfDay(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillisOfSecond(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMinuteOfDay(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMinuteOfHour(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMonthOfYear(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setSecondOfDay(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setSecondOfMinute(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setWeekOfWeekyear(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setWeekyear(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setYear(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.weekOfWeekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.weekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.year()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.yearOfCentury()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.yearOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.add(org.joda.time.DateTimeField, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.addWrapped(org.joda.time.DateTimeField, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.clockhourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.clockhourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getClockhourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getClockhourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getHalfdayOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getHourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getHourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getLowerLimit()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getMillisOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getMillisOfSecond()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getMinuteOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getMinuteOfHour()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getSecondOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getSecondOfMinute()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getUpperLimit()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.halfdayOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.hourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.hourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.millisOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.millisOfSecond()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.minuteOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.minuteOfHour()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.secondOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.secondOfMinute()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.set(org.joda.time.DateTimeField, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setClockhourOfDay(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setClockhourOfHalfday(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setHalfdayOfDay(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setHourOfDay(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setHourOfHalfday(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillisOfDay(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillisOfSecond(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMinuteOfDay(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMinuteOfHour(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setSecondOfDay(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setSecondOfMinute(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.PartialInstant.getLowerLimit()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.PartialInstant.getUpperLimit()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadWritableInstant.add(org.joda.time.DateTimeField, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadWritableInstant.addWrapped(org.joda.time.DateTimeField, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadWritableInstant.set(org.joda.time.DateTimeField, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.get(org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.clockhourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.clockhourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getClockhourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getClockhourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getHalfdayOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getHourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getHourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getLowerLimit()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getMillisOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getMillisOfSecond()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getMinuteOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getMinuteOfHour()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getSecondOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getSecondOfMinute()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getUpperLimit()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.halfdayOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.hourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.hourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.millisOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.millisOfSecond()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.minuteOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.minuteOfHour()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.secondOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.secondOfMinute()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.centuryOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.clockhourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.clockhourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.dayOfMonth()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.dayOfWeek()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.dayOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.era()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateOnlyMillis(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateTimeMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getTimeOnlyMillis(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.halfdayOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.hourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.hourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.millisOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.millisOfSecond()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.minuteOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.minuteOfHour()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.monthOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.secondOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.secondOfMinute()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.weekOfWeekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.weekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.year()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.yearOfCentury()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.yearOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cClockhourOfDayField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cClockhourOfHalfdayField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cHalfdayOfDayField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cHourOfDayField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cHourOfHalfdayField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cMillisOfDayField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cMillisOfSecondField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cMinuteOfDayField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cMinuteOfHourField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cSecondOfDayField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cSecondOfMinuteField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.centuryOfEra</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.clockhourOfDay</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.clockhourOfHalfday</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.dayOfMonth</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.dayOfWeek</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.dayOfYear</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.era</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.halfdayOfDay</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.hourOfDay</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.hourOfHalfday</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.isSupported(org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.millisOfDay</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.millisOfSecond</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.minuteOfDay</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.minuteOfHour</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.monthOfYear</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.secondOfDay</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.secondOfMinute</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weekOfWeekyear</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weekyear</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.year</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.yearOfCentury</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.yearOfEra</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.centuryOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.clockhourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.clockhourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.dayOfMonth()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.dayOfWeek()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.dayOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.era()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.halfdayOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.hourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.hourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iCenturyOfEra</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iClockhourOfDay</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iClockhourOfHalfday</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iDayOfMonth</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iDayOfWeek</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iDayOfYear</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iEra</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iHalfdayOfDay</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iHourOfDay</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iHourOfHalfday</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iMillisOfDay</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iMillisOfSecond</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iMinuteOfDay</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iMinuteOfHour</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iMonthOfYear</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iSecondOfDay</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iSecondOfMinute</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iWeekOfWeekyear</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iWeekyear</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iYear</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iYearOfCentury</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iYearOfEra</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.millisOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.millisOfSecond()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.minuteOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.minuteOfHour()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.monthOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.secondOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.secondOfMinute()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.weekOfWeekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.weekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.year()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.yearOfCentury()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.yearOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.INSTANCE</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticDayOfMonthDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.INSTANCE</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, long, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.add(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.add(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.get(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getAsShortText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getDifference(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getDifferenceAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getLeapAmount(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getLeapDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMaximumShortTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMaximumTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMaximumValue()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMaximumValue(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMinimumValue()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMinimumValue(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iGregorianField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iJulianField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.isLeap(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.roundCeiling(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.roundFloor(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.GJChronology$ImpreciseCutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.GJChronology$ImpreciseCutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.GJChronology$ImpreciseCutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.GJChronology$ImpreciseCutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, org.joda.time.DurationField, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.add(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.add(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.getDifference(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.getDifferenceAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.getMaximumValue(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.getMinimumValue(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.convertByWeekyear(long, org.joda.time.Chronology, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.convertByYear(long, org.joda.time.Chronology, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfMonthDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfYearDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getDifferenceAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.roundFloor(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.GJYearOfEraDateTimeField(org.joda.time.DateTimeField, org.joda.time.chrono.AbstractGJChronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.add(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.add(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.addWrapped(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.get(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.getDifference(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.getDifferenceAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.getMaximumValue()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.remainder(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.roundCeiling(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.roundFloor(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.INSTANCE</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.ISOYearOfEraDateTimeField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.add(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.add(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.addWrapped(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.get(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.getDifference(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.getDifferenceAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.getMaximumValue()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.remainder(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.roundCeiling(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.roundFloor(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoWeekyearZeroField.JulianChronology$NoWeekyearZeroField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoWeekyearZeroField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoYearZeroField.JulianChronology$NoYearZeroField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoYearZeroField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoYearZeroField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.convertField(org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.LimitChronology$LimitDateTimeField(org.joda.time.chrono.LimitChronology, org.joda.time.DateTimeField, org.joda.time.DurationField, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.add(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.add(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.addWrapped(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.get(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getDifference(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getDifferenceAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getLeapAmount(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getMaximumShortTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getMaximumValue(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getMinimumValue(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.isLeap(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.remainder(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundCeiling(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundFloor(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundHalfCeiling(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundHalfEven(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundHalfFloor(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.convertField(org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.ZonedChronology$ZonedDateTimeField(org.joda.time.DateTimeField, org.joda.time.DateTimeZone, org.joda.time.DurationField, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.add(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.add(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.addWrapped(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.get(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getDifference(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getDifferenceAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getLeapAmount(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMaximumShortTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMaximumValue()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMaximumValue(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMinimumValue()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMinimumValue(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.isLeap(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.isLenient()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.remainder(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.roundCeiling(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.roundFloor(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.AbstractDateTimeField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.DecoratedDateTimeField(org.joda.time.DateTimeField, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.get(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getMaximumValue()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getMinimumValue()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.iField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.isLenient()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.roundFloor(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.set(long, int)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.DelegatedDateTimeField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.DelegatedDateTimeField(org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.DelegatedDateTimeField(org.joda.time.DateTimeField, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.add(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.add(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.addWrapped(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.get(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getAsShortText(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getAsText(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getDifference(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getDifferenceAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getLeapAmount(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getLeapDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getMaximumShortTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getMaximumValue()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getMaximumValue(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getMinimumValue()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getMinimumValue(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getName()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getWrappedField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.isLeap(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.isLenient()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.isSupported()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.remainder(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.roundCeiling(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.roundFloor(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.roundHalfCeiling(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.roundHalfEven(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.roundHalfFloor(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.set(long, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.DateTimeField, java.lang.String, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.field.RemainderDateTimeField, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.add(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.add(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.get(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.getDifference(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.getDifferenceAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.remainder(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.roundFloor(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeField, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.LenientDateTimeField.LenientDateTimeField(org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.LenientDateTimeField.getInstance(org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.NonZeroDateTimeField(org.joda.time.DateTimeField, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.add(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.add(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.addWrapped(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.get(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.getDifference(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.getDifferenceAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.getLeapAmount(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.getLeapDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.getMaximumValue()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.getMaximumValue(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.isLeap(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.remainder(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.roundCeiling(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.roundFloor(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.roundHalfCeiling(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.roundHalfEven(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.roundHalfFloor(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(org.joda.time.DateTimeField, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(org.joda.time.DateTimeField, java.lang.String, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.add(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.add(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.getLeapAmount(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.getLeapDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.isLeap(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.remainder(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.roundCeiling(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.roundFloor(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.roundHalfCeiling(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.roundHalfEven(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.roundHalfFloor(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(org.joda.time.DateTimeField, java.lang.String, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(org.joda.time.field.DividedDateTimeField, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.get(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.remainder(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.roundCeiling(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.roundFloor(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.roundHalfCeiling(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.roundHalfEven(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.roundHalfFloor(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.StrictDateTimeField.StrictDateTimeField(org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.StrictDateTimeField.getInstance(org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.StrictDateTimeField.set(long, int)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.DateTimeFormatterBuilder$Fraction(org.joda.time.Chronology, org.joda.time.DateTimeField, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.iField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.iParseField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.lang.StringBuffer, java.io.Writer, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.DateTimeFormatterBuilder$NumberFormatter(org.joda.time.Chronology, org.joda.time.DateTimeField, int, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.iField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.DateTimeFormatterBuilder$PaddedNumber(org.joda.time.Chronology, org.joda.time.DateTimeField, int, boolean, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.DateTimeFormatterBuilder$TextField(org.joda.time.Chronology, org.joda.time.DateTimeField, java.util.Locale, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.estimatePrintedLength()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.iField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.print(long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber.DateTimeFormatterBuilder$UnpaddedNumber(org.joda.time.Chronology, org.joda.time.DateTimeField, int, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendCenturyOfEra(int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendClockhourOfDay(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendClockhourOfHalfday(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfMonth(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfWeek(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfWeekShortText()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfWeekText()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfYear(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDecimal(org.joda.time.DateTimeField, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendEraText()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFraction(org.joda.time.DateTimeField, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfDay(int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfHour(int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfMinute(int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfSecond(int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendHalfdayOfDayText()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendHourOfDay(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendHourOfHalfday(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMillisOfDay(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMillisOfSecond(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMinuteOfDay(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMinuteOfHour(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMonthOfYear(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMonthOfYearShortText()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMonthOfYearText()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendSecondOfDay(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendSecondOfMinute(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendShortText(org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendSignedDecimal(org.joda.time.DateTimeField, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendText(org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendWeekOfWeekyear(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendWeekyear(int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendYear(int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendYearOfCentury(int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendYearOfEra(int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.DateTimeParserBucket$SavedField(org.joda.time.DateTimeField, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.DateTimeParserBucket$SavedField(org.joda.time.DateTimeField, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.compareTo(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.iField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.set(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.saveField(org.joda.time.DateTimeField, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.saveField(org.joda.time.DateTimeField, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.compareTo(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.get()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getAsShortText(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getAsText()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getAsText(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getDifference(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getDifferenceAsLong(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getLeapAmount()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getLeapDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getMaximumShortTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getMaximumTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getMaximumValue()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getMaximumValueOverall()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getMinimumValue()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getMinimumValueOverall()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getName()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.isLeap()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.remainder()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.DateOnlyFieldProperty(org.joda.time.DateOnly, org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.addToCopy(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.addToCopy(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.addWrappedToCopy(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.getField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.iField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundCeilingCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundFloorCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundHalfCeilingCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundHalfEvenCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundHalfFloorCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.setCopy(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.setCopy(java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.DateTimeFieldProperty(org.joda.time.DateTime, org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.addToCopy(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.addToCopy(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.addWrappedToCopy(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.getField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.iField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundCeilingCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundFloorCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundHalfCeilingCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundHalfEvenCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundHalfFloorCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.setCopy(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.setCopy(java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.add(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.add(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.addWrapped(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.getField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.iField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundCeiling()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundFloor()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundHalfCeiling()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundHalfEven()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundHalfFloor()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.set(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.set(java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.TimeOnlyFieldProperty(org.joda.time.TimeOnly, org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.addToCopy(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.addToCopy(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.addWrappedToCopy(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.getField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.iField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundCeilingCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundFloorCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundHalfCeilingCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundHalfEvenCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundHalfFloorCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.setCopy(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.setCopy(java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.next(long, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.previous(long, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonth(org.joda.time.Chronology, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonthNext(org.joda.time.Chronology, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonthPrevious(org.joda.time.Chronology, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfWeek(org.joda.time.Chronology, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setInstant(int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.next(long, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.nextTransition(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDayOfWeek(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseMonth(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.add(long, int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.add(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.add(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.add(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.addToCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.addToCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.add(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.addToCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.next(long, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.previous(long, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonth(org.joda.time.Chronology, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonthNext(org.joda.time.Chronology, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonthPrevious(org.joda.time.Chronology, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfWeek(org.joda.time.Chronology, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.add(long, long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.addToCopy(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.addToCopy(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.add(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.addToCopy(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.addWrapped(long, int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addWrapped(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addWrapped(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.addWrapped(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.addWrappedToCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.addWrappedToCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.addWrapped(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.addWrappedToCopy(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.get(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getCenturyOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getDayOfMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getDayOfWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getDayOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getHourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillisOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillisOfSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMinuteOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMinuteOfHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMonthOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getSecondOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getSecondOfMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getWeekOfWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getYearOfCentury()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getYearOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.get(org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getCenturyOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getDayOfMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getDayOfWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getDayOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getMonthOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getWeekOfWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getYearOfCentury()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.getYearOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getCenturyOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getDayOfMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getDayOfWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getDayOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getMonthOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getWeekOfWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getYearOfCentury()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.getYearOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getClockhourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getClockhourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getHalfdayOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getHourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getHourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getMillisOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getMillisOfSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getMinuteOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getMinuteOfHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getSecondOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.getSecondOfMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getClockhourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getClockhourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getHalfdayOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getHourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getHourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getMillisOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getMillisOfSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getMinuteOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getMinuteOfHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getSecondOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.getSecondOfMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMinimumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.convertByWeekyear(long, org.joda.time.Chronology, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.convertByYear(long, org.joda.time.Chronology, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.get()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfWeek(org.joda.time.Chronology, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.next(long, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.nextTransition(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDayOfWeek(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseMonth(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.getAsShortText(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getAsShortText(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.getAsShortText(long, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getAsShortText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.print(long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getAsShortText(java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.getAsText(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getAsText(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.getAsText(long, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getAsText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getAsText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getAsText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getAsText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.print(long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getAsText()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getAsText(java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.getDifference(long, long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getDifference(org.joda.time.ReadableInstant)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.getDifferenceAsLong(long, long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getDifferenceAsLong(org.joda.time.ReadableInstant)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.getDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, long, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.DateTimeField, java.lang.String, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(org.joda.time.DateTimeField, java.lang.String, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.DateTimeFormatterBuilder$Fraction(org.joda.time.Chronology, org.joda.time.DateTimeField, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFraction(org.joda.time.DateTimeField, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.compareTo(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getDurationField()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.getLeapAmount(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getLeapAmount(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getLeapAmount(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getLeapAmount(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getLeapAmount(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.getLeapAmount(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.getLeapAmount(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getLeapAmount()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.getLeapDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getLeapDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getLeapDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.getLeapDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.getLeapDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getLeapDurationField()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.getMaximumShortTextLength(java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMaximumShortTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getMaximumShortTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMaximumShortTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getMaximumShortTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.estimatePrintedLength()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getMaximumShortTextLength(java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.getMaximumTextLength(java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMaximumTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.estimatePrintedLength()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getMaximumTextLength(java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.getMaximumValue()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMaximumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.getMaximumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.getMaximumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMaximumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getMaximumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getMaximumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.DateTimeField, java.lang.String, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.field.RemainderDateTimeField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.getMaximumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(org.joda.time.DateTimeField, java.lang.String, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getMaximumValueOverall()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.getMaximumValue(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getMaximumValue()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.getMinimumValue()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMinimumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMinimumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getMinimumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getMinimumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.DateTimeField, java.lang.String, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.field.RemainderDateTimeField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.NonZeroDateTimeField(org.joda.time.DateTimeField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(org.joda.time.DateTimeField, java.lang.String, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getMinimumValueOverall()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.getMinimumValue(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMinimumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.getMinimumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getMinimumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMinimumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getMinimumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getMinimumValue()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.getName()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, long, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.LimitChronology$LimitDateTimeField(org.joda.time.chrono.LimitChronology, org.joda.time.DateTimeField, org.joda.time.DurationField, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.ZonedChronology$ZonedDateTimeField(org.joda.time.DateTimeField, org.joda.time.DateTimeZone, org.joda.time.DurationField, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getName()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeField, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getName()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.getRangeDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getRangeDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getRangeDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getRangeDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.compareTo(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getRangeDurationField()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.isLeap(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.isLeap()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonthNext(org.joda.time.Chronology, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonthPrevious(org.joda.time.Chronology, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.isLenient()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.isLenient()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.isLenient()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.isLenient()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.LenientDateTimeField.getInstance(org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.StrictDateTimeField.getInstance(org.joda.time.DateTimeField)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.isSupported()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.isSupported(org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.ZonedChronology$ZonedDateTimeField(org.joda.time.DateTimeField, org.joda.time.DateTimeZone, org.joda.time.DurationField, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.DecoratedDateTimeField(org.joda.time.DateTimeField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.isSupported()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.remainder(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.resetSupportedFields(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.resetUnsupportedFields(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.compare(java.lang.Object, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getTimeOnlyMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.remainder(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.remainder(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.remainder(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.remainder(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.remainder(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.remainder(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.remainder(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.remainder(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.remainder(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.lang.StringBuffer, java.io.Writer, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.remainder()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.roundCeiling(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundCeilingCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundCeilingCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundCeiling()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundCeilingCopy()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.roundFloor(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.resetSupportedFields(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.resetUnsupportedFields(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.compare(java.lang.Object, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateOnlyMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundFloorCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundFloorCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundFloor()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundFloorCopy()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.roundHalfCeiling(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundHalfCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.roundHalfCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.roundHalfCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.roundHalfCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.roundHalfCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundHalfCeilingCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundHalfCeilingCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundHalfCeiling()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundHalfCeilingCopy()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.roundHalfEven(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundHalfEven(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.roundHalfEven(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.roundHalfEven(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.roundHalfEven(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.roundHalfEven(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundHalfEvenCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundHalfEvenCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundHalfEven()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundHalfEvenCopy()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.roundHalfFloor(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundHalfFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.roundHalfFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.roundHalfFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.roundHalfFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.roundHalfFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundHalfFloorCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundHalfFloorCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundHalfFloor()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundHalfFloorCopy()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.set(long, int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.set(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setDayOfMonth(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setDayOfWeek(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setDayOfYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setMonthOfYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setWeekOfWeekyear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setWeekyear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.set(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDayOfMonth(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDayOfWeek(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDayOfYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setHourOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillisOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillisOfSecond(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMinuteOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMinuteOfHour(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMonthOfYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setSecondOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setSecondOfMinute(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setWeekOfWeekyear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setWeekyear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.set(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setClockhourOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setClockhourOfHalfday(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setHalfdayOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setHourOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setHourOfHalfday(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillisOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillisOfSecond(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMinuteOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMinuteOfHour(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setSecondOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setSecondOfMinute(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateTimeMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMinimumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.convertByWeekyear(long, org.joda.time.Chronology, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.set(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.setCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.setCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.set(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.setCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.next(long, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.previous(long, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonth(org.joda.time.Chronology, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setInstant(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.next(long, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.set(long, java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.set(long, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.set(long, java.lang.String, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.set(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.setCopy(java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.setCopy(java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.set(java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.setCopy(java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDayOfWeek(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseMonth(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeField.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.DateTimeZone</name>
            <outbound type="class" confirmed="no">java.io.Serializable</outbound>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(int, int, int, int, int, int, int, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.moveDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.setDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.getDateTimeZone()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toInstant(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toTrustedISODateTime()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.selectChronologyUTC(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.toLocalTime(long, org.joda.time.Chronology, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeZone()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.DateOnly(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(int, int, int, int, int, int, int, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone$Stub.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Instant.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Instant.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.MutableDateOnly(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.moveDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(int, int, int, int, int, int, int, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.moveDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.MutableTimeOnly(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.moveDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.PartialInstant.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadWritableInstant.moveDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadWritableInstant.setDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableDateTime.toDateTime(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableDateTime.toMutableDateTime(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getDateTimeZone()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.TimeOnly(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateTimeZone()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateTimeZone()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeZone()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.getInstance()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeZone()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstanceUTC()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.withUTC()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology$Stub.ISOChronology$Stub(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology$Stub.iZone</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology$Stub.readObject(java.io.ObjectInputStream)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology$Stub.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology$Stub.writeObject(java.io.ObjectOutputStream)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.writeReplace()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.withUTC()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.withUTC()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.withUTC()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.ZonedChronology$ZonedDateTimeField(org.joda.time.DateTimeField, org.joda.time.DateTimeZone, org.joda.time.DurationField, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.add(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.add(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.addWrapped(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.get(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getDifference(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getDifferenceAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getLeapAmount(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMaximumValue(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMinimumValue(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iZone</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.isLeap(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.remainder(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.roundCeiling(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.roundFloor(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.ZonedChronology$ZonedDurationField(org.joda.time.DurationField, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.add(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.add(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getDifference(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getDifferenceAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getMillis(int, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getMillis(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getValue(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getValueAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.iZone</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.isPrecise()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.ZonedChronology(org.joda.time.Chronology, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DurationField, java.util.HashMap)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getDateTimeZone()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getInstance(org.joda.time.Chronology, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.localToUTC(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.getInstantMillis(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.getInstantMillis(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.InstantConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.InstantConverter.getInstantMillis(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.getChronology(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.getInstantMillis(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.getInstantMillis(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.getInstantMillis(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getInstantMillis(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.createBucket(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.getDateTimeZone()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.getInstantLocal(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.print(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.print(long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.print(long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.print(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.io.Writer, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.io.Writer, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.lang.StringBuffer, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.print(long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.print(long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.printTo(java.io.Writer, long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.print(long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.print(long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.DateTimeZone, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.print(long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.print(long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.print(long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.print(long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.DateTimeZone, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.DateTimeParserBucket$SavedState(org.joda.time.format.DateTimeParserBucket)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.iZone</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.restoreState(org.joda.time.format.DateTimeParserBucket)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.computeMillis()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.getDateTimeZone()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iZone</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.setDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.setOffset(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.print(long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.print(long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance(org.joda.time.DateTimeZone)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.tz.CachedDateTimeZone</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.CachedDateTimeZone$Info(org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.getNameKey(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.getOffset(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.getStandardOffset(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.iZoneRef</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.CachedDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.createInfo(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.equals(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.forZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.getUncachedZone()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.hashCode()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.iZone</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.isFixed()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.nextTransition(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.previousTransition(long)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.buildFixedZone(java.lang.String, java.lang.String, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.DataInput, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.InputStream, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeTo(java.io.DataOutput)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.tz.FixedDateTimeZone</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.Provider.getDateTimeZone(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.UTCProvider.getDateTimeZone(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.buildDateTimeZone(java.util.Map)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.getDateTimeZone(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneData(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneInfoMap(java.io.InputStream)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.DateTimeZone(java.lang.String)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.iID</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.CachedDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.DateTimeZoneBuilder$DSTZone(java.lang.String, int, org.joda.time.tz.DateTimeZoneBuilder$Recurrence, org.joda.time.tz.DateTimeZoneBuilder$Recurrence)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.DateTimeZoneBuilder$PrecalculatedZone(java.lang.String, java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$DSTZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.DateTimeZoneBuilder$PrecalculatedZone(java.lang.String, long[], int[], int[], java.lang.String[], org.joda.time.tz.DateTimeZoneBuilder$DSTZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.FixedDateTimeZone.FixedDateTimeZone(java.lang.String, java.lang.String, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.UTC</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.selectChronologyUTC(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.util.TimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.offsetFormatter()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setProvider0(org.joda.time.tz.Provider)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateTimeZone()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeZone()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstanceUTC()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.withUTC()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.withUTC()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.withUTC()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.withUTC()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.getDateTimeZone()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.setDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.buildFixedZone(java.lang.String, java.lang.String, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.DataInput, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.UTCProvider.getDateTimeZone(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneInfoMap(java.io.InputStream)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.cAvailableIDs</name>
                <outbound type="class" confirmed="no">java.util.Set</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getAvailableIDs()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setProvider0(org.joda.time.tz.Provider)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.cDefault</name>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setDefault(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.cNameProvider</name>
                <outbound type="class" confirmed="yes">org.joda.time.tz.NameProvider</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getName(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getNameProvider()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getShortName(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setNameProvider0(org.joda.time.tz.NameProvider)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.cOffsetFormatter</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.offsetFormatter()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.cProvider</name>
                <outbound type="class" confirmed="yes">org.joda.time.tz.Provider</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.util.TimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getProvider()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setProvider0(org.joda.time.tz.Provider)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.cZoneIdConversion</name>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getConvertedId(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.equals(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setProvider0(org.joda.time.tz.Provider)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.DataInput, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.getAvailableIDs()</name>
                <outbound type="class" confirmed="no">java.util.Set</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.cAvailableIDs</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.getConvertedId(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.util.HashMap.HashMap()</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.get(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.put(java.lang.Object, java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.cZoneIdConversion</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.util.TimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.getDefault()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.cDefault</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.moveDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.setDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.getInstance()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.getChronology(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.getInstantMillis(java.lang.Object, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.getInstantMillis(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.getDefaultNameProvider()</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <outbound type="feature" confirmed="no">java.lang.Class.forName(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Class.newInstance()</outbound>
                <outbound type="class" confirmed="no">java.lang.Exception</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.SecurityException</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.System.getProperty(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Thread</outbound>
                <outbound type="feature" confirmed="no">java.lang.Thread.currentThread()</outbound>
                <outbound type="feature" confirmed="no">java.lang.Thread.getThreadGroup()</outbound>
                <outbound type="class" confirmed="no">java.lang.ThreadGroup</outbound>
                <outbound type="feature" confirmed="no">java.lang.ThreadGroup.uncaughtException(java.lang.Thread, java.lang.Throwable)</outbound>
                <outbound type="class" confirmed="no">java.lang.Throwable</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DefaultNameProvider.DefaultNameProvider()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.NameProvider</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setNameProvider0(org.joda.time.tz.NameProvider)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.getDefaultProvider()</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <outbound type="feature" confirmed="no">java.lang.Class.forName(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Class.newInstance()</outbound>
                <outbound type="class" confirmed="no">java.lang.Exception</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.SecurityException</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.System.getProperty(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Thread</outbound>
                <outbound type="feature" confirmed="no">java.lang.Thread.currentThread()</outbound>
                <outbound type="feature" confirmed="no">java.lang.Thread.getThreadGroup()</outbound>
                <outbound type="class" confirmed="no">java.lang.ThreadGroup</outbound>
                <outbound type="feature" confirmed="no">java.lang.ThreadGroup.uncaughtException(java.lang.Thread, java.lang.Throwable)</outbound>
                <outbound type="class" confirmed="no">java.lang.Throwable</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.Provider</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.UTCProvider.UTCProvider()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setProvider0(org.joda.time.tz.Provider)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.getID()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.iID</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toTrustedISODateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.hashCode()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.CachedDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.FixedDateTimeZone.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.getInstance(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.equals(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.startsWith(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.cProvider</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.offsetFormatter()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseMillis(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.print(long, org.joda.time.DateTimeZone, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.FixedDateTimeZone.FixedDateTimeZone(java.lang.String, java.lang.String, int, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.Provider</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.Provider.getDateTimeZone(java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toTrustedISODateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone$Stub.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.getInstance(java.util.TimeZone)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.equals(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.startsWith(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.substring(int)</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="no">java.util.TimeZone</outbound>
                <outbound type="feature" confirmed="no">java.util.TimeZone.getDisplayName()</outbound>
                <outbound type="feature" confirmed="no">java.util.TimeZone.getID()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.cProvider</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getConvertedId(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.offsetFormatter()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseMillis(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.print(long, org.joda.time.DateTimeZone, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.FixedDateTimeZone.FixedDateTimeZone(java.lang.String, java.lang.String, int, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.Provider</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.Provider.getDateTimeZone(java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.getName(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getName(long, java.util.Locale)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.getName(long, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="no">java.util.Locale.getDefault()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.cNameProvider</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getNameKey(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.iID</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.offsetFormatter()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.print(long, org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.NameProvider</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.NameProvider.getName(java.util.Locale, java.lang.String, java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getName(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.print(long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.getNameKey(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getName(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getShortName(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.getNameKey(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeTo(java.io.DataOutput)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.getNameProvider()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.cNameProvider</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.NameProvider</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.getOffset(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.moveDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.toLocalTime(long, org.joda.time.Chronology, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffsetFromLocal(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getAsText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getLeapAmount(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMinimumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.remainder(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getMillis(int, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getMillis(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getValue(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getValueAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.localToUTC(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.getInstantLocal(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.print(long, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.computeMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.getOffset(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeTo(java.io.DataOutput)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.getOffset(org.joda.time.ReadableInstant)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.getOffsetFromLocal(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.moveDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.localToUTC(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.getInstantMillis(java.lang.Object, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.getInstantMillis(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.computeMillis()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.getProvider()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.cProvider</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.Provider</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.getShortName(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getShortName(long, java.util.Locale)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.getShortName(long, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="no">java.util.Locale.getDefault()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.cNameProvider</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getNameKey(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.iID</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.offsetFormatter()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.print(long, org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.NameProvider</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.NameProvider.getShortName(java.util.Locale, java.lang.String, java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getShortName(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.print(long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.getStandardOffset(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.getStandardOffset(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeTo(java.io.DataOutput)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.hashCode()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.hashCode()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getID()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.hashCode()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.iID</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.DateTimeZone(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getID()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getName(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getShortName(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.toTimeZone()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.writeReplace()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.isFixed()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.isPrecise()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.isFixed()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.nextTransition(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.createInfo(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.nextTransition(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.offsetFormatter()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.cOffsetFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.DateTimeZone)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneOffset(java.lang.String, boolean, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.util.TimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getName(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getShortName(long, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.previousTransition(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.previousTransition(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.setDefault(org.joda.time.DateTimeZone)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.SecurityException</outbound>
                <outbound type="class" confirmed="no">java.lang.SecurityManager</outbound>
                <outbound type="feature" confirmed="no">java.lang.SecurityManager.checkPermission(java.security.Permission)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.System.getSecurityManager()</outbound>
                <outbound type="class" confirmed="no">java.security.Permission</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.cDefault</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZonePermission.DateTimeZonePermission(java.lang.String)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.setNameProvider(org.joda.time.tz.NameProvider)</name>
                <outbound type="class" confirmed="no">java.lang.SecurityException</outbound>
                <outbound type="class" confirmed="no">java.lang.SecurityManager</outbound>
                <outbound type="feature" confirmed="no">java.lang.SecurityManager.checkPermission(java.security.Permission)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.System.getSecurityManager()</outbound>
                <outbound type="class" confirmed="no">java.security.Permission</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setNameProvider0(org.joda.time.tz.NameProvider)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZonePermission.DateTimeZonePermission(java.lang.String)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.NameProvider</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.setNameProvider0(org.joda.time.tz.NameProvider)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.cNameProvider</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultNameProvider()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.NameProvider</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setNameProvider(org.joda.time.tz.NameProvider)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.setProvider(org.joda.time.tz.Provider)</name>
                <outbound type="class" confirmed="no">java.lang.SecurityException</outbound>
                <outbound type="class" confirmed="no">java.lang.SecurityManager</outbound>
                <outbound type="feature" confirmed="no">java.lang.SecurityManager.checkPermission(java.security.Permission)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.System.getSecurityManager()</outbound>
                <outbound type="class" confirmed="no">java.security.Permission</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setProvider0(org.joda.time.tz.Provider)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZonePermission.DateTimeZonePermission(java.lang.String)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.Provider</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.setProvider0(org.joda.time.tz.Provider)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Set</outbound>
                <outbound type="feature" confirmed="no">java.util.Set.contains(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.Set.size()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.cAvailableIDs</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.cProvider</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.equals(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultProvider()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.Provider</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.Provider.getAvailableIDs()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.Provider.getDateTimeZone(java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setProvider(org.joda.time.tz.Provider)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.static {}</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="no">java.lang.RuntimeException</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.System.getProperty(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.util.TimeZone</outbound>
                <outbound type="feature" confirmed="no">java.util.TimeZone.getDefault()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.cDefault</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.util.TimeZone)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setNameProvider0(org.joda.time.tz.NameProvider)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setProvider0(org.joda.time.tz.Provider)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.FixedDateTimeZone.FixedDateTimeZone(java.lang.String, java.lang.String, int, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.NameProvider</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.Provider</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getID()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.toTimeZone()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.TimeZone</outbound>
                <outbound type="feature" confirmed="no">java.util.TimeZone.getTimeZone(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.iID</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone.writeReplace()</name>
                <outbound type="class" confirmed="no">java.io.ObjectStreamException</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone$Stub.DateTimeZone$Stub(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.iID</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.DateTimeZone$Stub</name>
            <outbound type="class" confirmed="no">java.io.Serializable</outbound>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone$Stub.DateTimeZone$Stub(java.lang.String)</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone$Stub.iID</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.writeReplace()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone$Stub.iID</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone$Stub.DateTimeZone$Stub(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone$Stub.readObject(java.io.ObjectInputStream)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone$Stub.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone$Stub.writeObject(java.io.ObjectOutputStream)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone$Stub.readObject(java.io.ObjectInputStream)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.ObjectInputStream</outbound>
                <outbound type="feature" confirmed="no">java.io.ObjectInputStream.readUTF()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone$Stub.iID</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone$Stub.readResolve()</name>
                <outbound type="class" confirmed="no">java.io.ObjectStreamException</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone$Stub.iID</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.lang.String)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone$Stub.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DateTimeZone$Stub.writeObject(java.io.ObjectOutputStream)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.ObjectOutputStream</outbound>
                <outbound type="feature" confirmed="no">java.io.ObjectOutputStream.writeUTF(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone$Stub.iID</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.Duration</name>
            <outbound type="class" confirmed="no">java.io.Serializable</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.AbstractDuration</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.toDuration()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableDuration, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInterval)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getDuration()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iDuration</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setDurationAfterStart(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setDurationBeforeEnd(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setEndMillis(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setStartMillis(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.toDuration()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableInterval.getDuration()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.getDurationType(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.parseDuration(org.joda.time.DurationType, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationParser.parseDuration(org.joda.time.DurationType, java.lang.String)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.Duration.Duration(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(java.lang.Object)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Duration.Duration(org.joda.time.DurationType)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Duration.Duration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Duration.Duration(org.joda.time.DurationType, java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Duration.Duration(org.joda.time.DurationType, long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getDuration()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Duration.Duration(org.joda.time.DurationType, long, long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, long, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Duration.Duration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Duration.Duration(org.joda.time.DurationType, org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Duration.Duration(org.joda.time.ReadableDuration)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.ReadableDuration)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.toDuration()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Duration.normalize()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Duration.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Duration.setDays(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Duration.setDuration(int, int, int, int, int, int, int, int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Duration.setDuration(org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Duration.setHours(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Duration.setMillis(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Duration.setMinutes(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Duration.setMonths(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Duration.setSeconds(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Duration.setTotalMillis(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Duration.setTotalMillis(long, long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Duration.setWeeks(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Duration.setYears(int)</name>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.DurationField</name>
            <outbound type="class" confirmed="no">java.lang.Comparable</outbound>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(long, int, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.checkPrecise(org.joda.time.DurationField, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.checkSupport(org.joda.time.DurationField, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDays(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setHours(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setMillis(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setMinutes(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setMonths(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setSeconds(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setWeeks(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setYears(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.updateTotalMillis()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.centuries()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.days()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.eras()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.hours()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.millis()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.minutes()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.months()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.seconds()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.weeks()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.weekyears()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Chronology.years()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getLeapDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$AverageYearMonthType.DurationType$AverageYearMonthType(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$AverageYearMonthType.iMonths</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$AverageYearMonthType.iYears</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$AverageYearMonthType.months()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$AverageYearMonthType.years()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.days()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.hours()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.isPrecise()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.millis()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.minutes()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.seconds()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.days()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.hours()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.isPrecise()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.millis()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.minutes()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.months()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.seconds()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.weeks()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.years()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MillisType.millis()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearMonthType.DurationType$PreciseYearMonthType(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearMonthType.iMonths</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearMonthType.iYears</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearMonthType.isPrecise()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearMonthType.months()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearMonthType.years()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearWeekType.DurationType$PreciseYearWeekType(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearWeekType.iYears</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearWeekType.isPrecise()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearWeekType.weeks()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearWeekType.years()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearMonthType.isPrecise()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearMonthType.months()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearMonthType.years()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearWeekType.isPrecise()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearWeekType.weeks()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearWeekType.years()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.days()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.equals(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.hashCode()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.hours()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.millis()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.minutes()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.months()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.seconds()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.weeks()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withDaysRemoved()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withHoursRemoved()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withMillisRemoved()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withMinutesRemoved()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withMonthsRemoved()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withSecondsRemoved()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withWeeksRemoved()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withYearsRemoved()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.years()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addDays(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addMonths(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addWeeks(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addWeekyears(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addYears(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addDays(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addHours(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addMillis(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addMinutes(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addMonths(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addSeconds(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addWeeks(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addWeekyears(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addYears(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.addHours(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.addMillis(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.addMinutes(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.addSeconds(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.centuries()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.centuryOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.clockhourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.clockhourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.dayOfMonth()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.dayOfWeek()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.dayOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.days()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.era()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.eras()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.halfdayOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.hourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.hourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.hours()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.millis()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.millisOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.millisOfSecond()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.minuteOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.minuteOfHour()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.minutes()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.monthOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.months()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.secondOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.secondOfMinute()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.seconds()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.weekOfWeekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.weeks()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.weekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.weekyears()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.year()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.yearOfCentury()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.yearOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.years()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$HalfdayField.AbstractGJChronology$HalfdayField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.access$000()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.access$100()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cDaysField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cHalfdaysField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cHoursField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cMillisField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cMinutesField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cSecondsField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cWeeksField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.centuries</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.days</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.eras</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.hours</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.isSupported(org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.millis</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.minutes</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.months</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.seconds</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weeks</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weekyears</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.years</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.centuries()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.days()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.eras()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.hours()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iCenturies</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iDays</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iEras</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iHours</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iMillis</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iMinutes</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iMonths</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iSeconds</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iWeeks</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iWeekyears</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iYears</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.millis()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.minutes()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.months()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.seconds()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.weeks()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.weekyears()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.years()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.getDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.cMonthsField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticDayOfMonthDateTimeField.CopticDayOfMonthDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticDayOfMonthDateTimeField.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.getDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.CopticMonthOfYearDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.getLeapDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.getLeapDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, long, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getLeapDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iDurationField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.GJChronology$ImpreciseCutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.GJChronology$ImpreciseCutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.GJChronology$ImpreciseCutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.GJChronology$ImpreciseCutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, org.joda.time.DurationField, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$LinkedDurationField.GJChronology$LinkedDurationField(org.joda.time.DurationField, org.joda.time.chrono.GJChronology$ImpreciseCutoverField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfMonthDateTimeField.GJDayOfMonthDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfMonthDateTimeField.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.GJDayOfWeekDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfYearDateTimeField.GJDayOfYearDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfYearDateTimeField.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.getDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getLeapDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.GJWeekOfWeekyearDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.getLeapDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.getLeapDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.LimitChronology$LimitDateTimeField(org.joda.time.chrono.LimitChronology, org.joda.time.DateTimeField, org.joda.time.DurationField, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getLeapDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.iDurationField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.iLeapDurationField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.iRangeDurationField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.LimitChronology$LimitDurationField(org.joda.time.chrono.LimitChronology, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.add(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.add(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getDifference(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getDifferenceAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getMillis(int, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getMillis(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getValue(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getValueAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.convertField(org.joda.time.DurationField, java.util.HashMap)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.ZonedChronology$ZonedDateTimeField(org.joda.time.DateTimeField, org.joda.time.DateTimeZone, org.joda.time.DurationField, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getLeapDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iDurationField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iLeapDurationField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iRangeDurationField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.ZonedChronology$ZonedDurationField(org.joda.time.DurationField, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.add(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.add(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getDifference(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getDifferenceAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getMillis(int, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getMillis(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getUnitMillis()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getValue(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getValueAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.iField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.isPrecise()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DurationField, java.util.HashMap)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.useTimeArithmetic(org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.add(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.add(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getDifference(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getDifferenceAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getLeapDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getRangeDurationField()</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.AbstractDurationField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.compareTo(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.DecoratedDurationField(org.joda.time.DurationField, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.add(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.add(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getDifferenceAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getMillis(int, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getMillis(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getUnitMillis()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getValueAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getWrappedField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.iField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.isPrecise()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getLeapDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getRangeDurationField()</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.DelegatedDurationField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.DelegatedDurationField(org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.DelegatedDurationField(org.joda.time.DurationField, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.add(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.add(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.compareTo(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getDifference(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getDifferenceAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getMillis(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getMillis(int, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getMillis(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getMillis(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getName()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getUnitMillis()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getValue(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getValue(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getValueAsLong(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getValueAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getWrappedField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.iField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.isPrecise()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.isSupported()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.DateTimeField, java.lang.String, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.field.RemainderDateTimeField, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.getDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.iDurationField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.ImpreciseDateTimeField(java.lang.String, java.lang.String, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.getDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.iDurationField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.MillisDurationField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.MillisDurationField.INSTANCE</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.MillisDurationField.compareTo(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.MillisDurationField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.MillisDurationField.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.getLeapDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.getLeapDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.PreciseDateTimeField(java.lang.String, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.iRangeField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.PreciseDurationDateTimeField(java.lang.String, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.getDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.iUnitField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(org.joda.time.DateTimeField, java.lang.String, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(org.joda.time.field.DividedDateTimeField, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.iRangeField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.ScaledDurationField(org.joda.time.DurationField, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.add(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.add(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getDifference(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getDifferenceAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getMillis(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getMillis(int, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getMillis(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getMillis(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getUnitMillis()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getValue(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getValue(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getValueAsLong(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getValueAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.UnsupportedDateTimeField(java.lang.String, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.add(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.add(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getDifference(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getDifferenceAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getLeapDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.iDurationField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.static {}</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.DateTimeFormatterBuilder$Fraction(org.joda.time.Chronology, org.joda.time.DateTimeField, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFraction(org.joda.time.DateTimeField, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.compareTo(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.getFieldValue(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.isSupported(org.joda.time.DurationType)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getLeapDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getRangeDurationField()</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.DurationField.add(long, int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(long, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addDays(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addMonths(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addWeeks(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addWeekyears(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addYears(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addDays(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addHours(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addMillis(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addMinutes(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addMonths(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addSeconds(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addWeeks(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addWeekyears(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addYears(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.addHours(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.addMillis(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.addMinutes(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.addSeconds(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.add(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationField.add(long, long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.add(long, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationField.compareTo(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.compareTo(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationField.getDifference(long, long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getDifference(long, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationField.getDifferenceAsLong(long, long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getDifferenceAsLong(long, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationField.getMillis(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.updateTotalMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getMillis(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getMillis(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationField.getMillis(int, long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getMillis(int, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getMillis(int, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getMillis(int, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getMillis(int, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getMillis(int, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationField.getMillis(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getMillis(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationField.getMillis(long, long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getMillis(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getMillis(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getMillis(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getMillis(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getMillis(long, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationField.getName()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$LinkedDurationField.GJChronology$LinkedDurationField(org.joda.time.DurationField, org.joda.time.chrono.GJChronology$ImpreciseCutoverField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.LimitChronology$LimitDurationField(org.joda.time.chrono.LimitChronology, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.ZonedChronology$ZonedDurationField(org.joda.time.DurationField, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getName()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationField.getUnitMillis()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$AverageYearMonthType.DurationType$AverageYearMonthType(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getUnitMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.useTimeArithmetic(org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.compareTo(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.getMillis(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.getMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.getValueAsLong(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getUnitMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getUnitMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.MillisDurationField.compareTo(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.PreciseDateTimeField(java.lang.String, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.PreciseDurationDateTimeField(java.lang.String, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getUnitMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.DateTimeFormatterBuilder$Fraction(org.joda.time.Chronology, org.joda.time.DateTimeField, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationField.getValue(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getValue(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationField.getValue(long, long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getValue(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getValue(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getValue(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getValue(long, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationField.getValueAsLong(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getValueAsLong(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getValueAsLong(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationField.getValueAsLong(long, long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getValueAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getValueAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.getValue(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getValueAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getValueAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getValueAsLong(long, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationField.isPrecise()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.checkPrecise(org.joda.time.DurationField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.updateTotalMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.isPrecise()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.isPrecise()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearMonthType.isPrecise()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearWeekType.isPrecise()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearMonthType.isPrecise()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearWeekType.isPrecise()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.isPrecise()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.isPrecise()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.isPrecise()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.PreciseDateTimeField(java.lang.String, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.PreciseDurationDateTimeField(java.lang.String, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFraction(org.joda.time.DateTimeField, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationField.isSupported()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.checkSupport(org.joda.time.DurationField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withDaysRemoved()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withHoursRemoved()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withMillisRemoved()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withMinutesRemoved()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withMonthsRemoved()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withSecondsRemoved()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withWeeksRemoved()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withYearsRemoved()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.isSupported(org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.convertField(org.joda.time.DurationField, java.util.HashMap)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.ZonedChronology$ZonedDurationField(org.joda.time.DurationField, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DurationField, java.util.HashMap)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.DecoratedDurationField(org.joda.time.DurationField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.isSupported()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.getFieldValue(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.isSupported(org.joda.time.DurationType)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationField.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.DurationType</name>
            <outbound type="class" confirmed="no">java.io.Serializable</outbound>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(long, int, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.equals(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getDurationType()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.hashCode()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.iType</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDays(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(int, int, int, int, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setHours(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setMillis(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setMinutes(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setMonths(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setSeconds(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setWeeks(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setYears(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.updateTotalMillis()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getDuration()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Duration.Duration(org.joda.time.DurationType)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Duration.Duration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Duration.Duration(org.joda.time.DurationType, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Duration.Duration(org.joda.time.DurationType, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Duration.Duration(org.joda.time.DurationType, long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Duration.Duration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Duration.Duration(org.joda.time.DurationType, org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$AverageYearMonthType.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$AverageYearMonthType.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.DurationType$DayHourType</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.DurationType$MaskedType</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.DurationType$MaskedType(org.joda.time.DurationType, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.days()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.getChronology()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.hours()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.iType</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.mask(org.joda.time.DurationType, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.millis()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.minutes()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.months()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.seconds()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.weeks()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.years()</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.DurationType$MillisType</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MillisType.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MillisType.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearMonthType.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearMonthType.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearWeekType.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearWeekType.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearMonthType.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearMonthType.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearWeekType.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearWeekType.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.MutableDuration(org.joda.time.DurationType)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.MutableDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.MutableDuration(org.joda.time.DurationType, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.MutableDuration(org.joda.time.DurationType, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.MutableDuration(org.joda.time.DurationType, long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.MutableDuration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.MutableDuration(org.joda.time.DurationType, org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getDurationType()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.DurationConverter.getDurationType(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.getDurationType(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.getDurationType(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.getDurationType(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getDurationType(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.parseDuration(org.joda.time.DurationType, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.parseMutableDuration(org.joda.time.DurationType, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.chooseFieldToPrint(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.getFieldValue(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.isSupported(org.joda.time.DurationType)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationParser.parseDuration(org.joda.time.DurationType, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationParser.parseMutableDuration(org.joda.time.DurationType, java.lang.String)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.DurationType()</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.DurationType$DayHourType(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.DurationType$MaskedType(org.joda.time.DurationType, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MillisType.DurationType$MillisType()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.days()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.INSTANCE</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(long, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDays(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.updateTotalMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.days()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.hashCode()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withDaysRemoved()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.getFieldValue(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.isSupported(org.joda.time.DurationType)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.equals(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.equals(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.days()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.hours()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.millis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.minutes()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.months()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.seconds()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.weeks()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.years()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.equals(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.getAverageYearMonthType()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$AverageYearMonthType.DurationType$AverageYearMonthType(org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getAverageYearMonthType(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.getDurationType(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.getAverageYearMonthType(org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.equals(java.lang.Object)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$AverageYearMonthType.DurationType$AverageYearMonthType(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.getAverageYearMonthType()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.isPrecise()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$AverageYearMonthType.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$AverageYearMonthType.withChronology(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.getChronology()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.getChronology()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.hashCode()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.getDayHourType()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.getDayHourType(org.joda.time.Chronology)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.getDayHourType(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.DurationType$DayHourType(org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getDayHourType()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.getMillisType()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType$1</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MillisType.DurationType$MillisType(org.joda.time.DurationType$1)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MillisType.readResolve()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.getPreciseYearMonthType()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearMonthType.DurationType$PreciseYearMonthType(org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getDuration()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearMonthType.readResolve()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.getPreciseYearWeekType()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearWeekType.DurationType$PreciseYearWeekType(org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearWeekType.readResolve()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.getYearMonthType()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.getYearMonthType(org.joda.time.Chronology)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getDurationType(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.getYearMonthType(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$YearMonthType.DurationType$YearMonthType(org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearMonthType.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getYearMonthType()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.getYearWeekType()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.getYearWeekType(org.joda.time.Chronology)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getDurationType(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.getYearWeekType(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$YearWeekType.DurationType$YearWeekType(org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearWeekType.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getYearWeekType()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.hashCode()</name>
                <outbound type="feature" confirmed="no">java.lang.Object.hashCode()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.days()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.hours()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.millis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.minutes()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.months()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.seconds()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.weeks()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.years()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.hashCode()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.hours()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.INSTANCE</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(long, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setHours(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.updateTotalMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.hours()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.hashCode()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withHoursRemoved()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.getFieldValue(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.isSupported(org.joda.time.DurationType)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.isPrecise()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getAverageYearMonthType(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.millis()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.INSTANCE</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(long, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setMillis(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.updateTotalMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.millis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.hashCode()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withMillisRemoved()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.getFieldValue(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.isSupported(org.joda.time.DurationType)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.minutes()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.INSTANCE</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(long, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setMinutes(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.updateTotalMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.minutes()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.hashCode()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withMinutesRemoved()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.getFieldValue(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.isSupported(org.joda.time.DurationType)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.months()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.INSTANCE</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(long, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setMonths(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.updateTotalMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.months()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.hashCode()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withMonthsRemoved()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.getFieldValue(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.isSupported(org.joda.time.DurationType)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.seconds()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.INSTANCE</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(long, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setSeconds(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.updateTotalMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.seconds()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.hashCode()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withSecondsRemoved()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.getFieldValue(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.isSupported(org.joda.time.DurationType)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.weeks()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.INSTANCE</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(long, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setWeeks(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.updateTotalMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.weeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.hashCode()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withWeeksRemoved()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.getFieldValue(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.isSupported(org.joda.time.DurationType)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.withChronology(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(long, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.withChronology(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.withDaysRemoved()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isSupported()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.mask(org.joda.time.DurationType, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.days()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.withHoursRemoved()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isSupported()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.mask(org.joda.time.DurationType, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.hours()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.withMillisRemoved()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isSupported()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.mask(org.joda.time.DurationType, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.millis()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.withMinutesRemoved()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isSupported()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.mask(org.joda.time.DurationType, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.minutes()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.withMonthsRemoved()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isSupported()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.mask(org.joda.time.DurationType, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.months()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.withSecondsRemoved()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isSupported()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.mask(org.joda.time.DurationType, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.seconds()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.withWeeksRemoved()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isSupported()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.mask(org.joda.time.DurationType, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.weeks()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.withYearsRemoved()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isSupported()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.mask(org.joda.time.DurationType, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.years()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType.years()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.INSTANCE</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(long, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(org.joda.time.DurationType, long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setYears(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.updateTotalMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.years()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.hashCode()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withYearsRemoved()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.getFieldValue(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.isSupported(org.joda.time.DurationType)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.DurationType$1</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MillisType.DurationType$MillisType(org.joda.time.DurationType$1)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getMillisType()</inbound>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.DurationType$AverageYearMonthType</name>
            <outbound type="class" confirmed="yes">org.joda.time.DurationType$DayHourType</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$AverageYearMonthType.DurationType$AverageYearMonthType(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.months()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.years()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getUnitMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$AverageYearMonthType.iMonths</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$AverageYearMonthType.iYears</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.DurationType$DayHourType(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationField.PreciseDurationField(java.lang.String, long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getAverageYearMonthType()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getAverageYearMonthType(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$AverageYearMonthType.iMonths</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$AverageYearMonthType.DurationType$AverageYearMonthType(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$AverageYearMonthType.months()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$AverageYearMonthType.iYears</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$AverageYearMonthType.DurationType$AverageYearMonthType(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$AverageYearMonthType.years()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$AverageYearMonthType.months()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$AverageYearMonthType.iMonths</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$AverageYearMonthType.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.getAverageYearMonthType(org.joda.time.Chronology)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$AverageYearMonthType.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$AverageYearMonthType.withChronology(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.getAverageYearMonthType(org.joda.time.Chronology)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$AverageYearMonthType.years()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$AverageYearMonthType.iYears</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.DurationType$DayHourType</name>
            <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
            <inbound type="class" confirmed="yes">org.joda.time.DurationType$AverageYearMonthType</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.DurationType$PreciseYearMonthType</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.DurationType$PreciseYearWeekType</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.DurationType$YearMonthType</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.DurationType$YearWeekType</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$DayHourType.DurationType$DayHourType(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.DurationType()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$AverageYearMonthType.DurationType$AverageYearMonthType(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearMonthType.DurationType$PreciseYearMonthType(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearWeekType.DurationType$PreciseYearWeekType(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearMonthType.DurationType$YearMonthType(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearWeekType.DurationType$YearWeekType(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getDayHourType(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$DayHourType.days()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.days()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.iChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.isPrecise()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$DayHourType.getChronology()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$DayHourType.hours()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.hours()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.iChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.isPrecise()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$DayHourType.iChronology</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$AverageYearMonthType.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$AverageYearMonthType.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.DurationType$DayHourType(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.days()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.getChronology()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.hours()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.millis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.minutes()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.seconds()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearWeekType.weeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearMonthType.months()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearMonthType.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearMonthType.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearMonthType.years()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearWeekType.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearWeekType.weeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearWeekType.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearWeekType.years()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$DayHourType.isPrecise()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isPrecise()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.days()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.hours()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.minutes()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.seconds()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearMonthType.isPrecise()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearWeekType.isPrecise()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearMonthType.isPrecise()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearWeekType.isPrecise()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$DayHourType.millis()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$DayHourType.minutes()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.minutes()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.iChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.isPrecise()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$DayHourType.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.getDayHourType(org.joda.time.Chronology)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$DayHourType.seconds()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.seconds()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.iChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.isPrecise()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$DayHourType.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$DayHourType.withChronology(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.DurationType$DayHourType(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.iChronology</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.DurationType$MaskedType</name>
            <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$MaskedType.DurationType$MaskedType(org.joda.time.DurationType, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.iMask</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.iType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.DurationType()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.mask(org.joda.time.DurationType, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$MaskedType.days()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.iMask</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.iType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.days()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.INSTANCE</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.isPrecise()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$MaskedType.getChronology()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.iType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.getChronology()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.withChronology(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$MaskedType.hours()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.iMask</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.iType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.hours()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.INSTANCE</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.isPrecise()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$MaskedType.iMask</name>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.DurationType$MaskedType(org.joda.time.DurationType, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.days()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.hours()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.mask(org.joda.time.DurationType, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.millis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.minutes()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.months()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.seconds()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.weeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.years()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$MaskedType.iType</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.DurationType$MaskedType(org.joda.time.DurationType, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.days()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.getChronology()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.hours()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.mask(org.joda.time.DurationType, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.millis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.minutes()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.months()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.seconds()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.weeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.years()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$MaskedType.isPrecise()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isPrecise()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.days()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.hours()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.minutes()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.months()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.seconds()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.weeks()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.years()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$MaskedType.mask(org.joda.time.DurationType, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.DurationType$MaskedType(org.joda.time.DurationType, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.iMask</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.iType</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withDaysRemoved()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withHoursRemoved()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withMillisRemoved()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withMinutesRemoved()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withMonthsRemoved()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withSecondsRemoved()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withWeeksRemoved()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.withYearsRemoved()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$MaskedType.millis()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.iMask</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.iType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.millis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.INSTANCE</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$MaskedType.minutes()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.iMask</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.iType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.minutes()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.INSTANCE</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.isPrecise()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$MaskedType.months()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.iMask</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.iType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.months()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.INSTANCE</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.isPrecise()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$MaskedType.seconds()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.iMask</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.iType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.seconds()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.INSTANCE</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.isPrecise()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$MaskedType.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$MaskedType.weeks()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.iMask</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.iType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.weeks()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.INSTANCE</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.isPrecise()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$MaskedType.withChronology(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.iMask</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.iType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.mask(org.joda.time.DurationType, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.withChronology(org.joda.time.Chronology)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$MaskedType.years()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.iMask</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.iType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.years()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.INSTANCE</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.isPrecise()</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.DurationType$MillisType</name>
            <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$MillisType.DurationType$MillisType()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.DurationType()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MillisType.DurationType$MillisType(org.joda.time.DurationType$1)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$MillisType.DurationType$MillisType(org.joda.time.DurationType$1)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType$1</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$MillisType.DurationType$MillisType()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getMillisType()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$MillisType.getChronology()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$MillisType.isPrecise()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$MillisType.millis()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.MillisDurationField.INSTANCE</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$MillisType.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.getMillisType()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$MillisType.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$MillisType.withChronology(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.DurationType$PreciseYearMonthType</name>
            <outbound type="class" confirmed="yes">org.joda.time.DurationType$DayHourType</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$PreciseYearMonthType.DurationType$PreciseYearMonthType(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.days()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.DurationType$DayHourType(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearMonthType.iMonths</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearMonthType.iYears</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.ScaledDurationField(org.joda.time.DurationField, java.lang.String, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getPreciseYearMonthType()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$PreciseYearMonthType.iMonths</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearMonthType.DurationType$PreciseYearMonthType(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearMonthType.months()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$PreciseYearMonthType.iYears</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearMonthType.DurationType$PreciseYearMonthType(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearMonthType.years()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$PreciseYearMonthType.isPrecise()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isPrecise()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.isPrecise()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearMonthType.months()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearMonthType.years()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$PreciseYearMonthType.months()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearMonthType.iMonths</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearMonthType.isPrecise()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$PreciseYearMonthType.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.getPreciseYearMonthType()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$PreciseYearMonthType.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$PreciseYearMonthType.withChronology(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$PreciseYearMonthType.years()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearMonthType.iYears</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearMonthType.isPrecise()</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.DurationType$PreciseYearWeekType</name>
            <outbound type="class" confirmed="yes">org.joda.time.DurationType$DayHourType</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$PreciseYearWeekType.DurationType$PreciseYearWeekType(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.days()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.DurationType$DayHourType(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearWeekType.iYears</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.ScaledDurationField(org.joda.time.DurationField, java.lang.String, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getPreciseYearWeekType()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$PreciseYearWeekType.iYears</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearWeekType.DurationType$PreciseYearWeekType(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearWeekType.years()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$PreciseYearWeekType.isPrecise()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isPrecise()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.isPrecise()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearWeekType.weeks()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearWeekType.years()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$PreciseYearWeekType.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.getPreciseYearWeekType()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$PreciseYearWeekType.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$PreciseYearWeekType.weeks()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weeks()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.iChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearWeekType.isPrecise()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$PreciseYearWeekType.withChronology(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$PreciseYearWeekType.years()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearWeekType.iYears</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearWeekType.isPrecise()</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.DurationType$YearMonthType</name>
            <outbound type="class" confirmed="yes">org.joda.time.DurationType$DayHourType</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$YearMonthType.DurationType$YearMonthType(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.DurationType$DayHourType(org.joda.time.Chronology)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearMonthType.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getYearMonthType(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$YearMonthType.isPrecise()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isPrecise()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.isPrecise()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$YearMonthType.months()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$YearMonthType.years()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$YearMonthType.months()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.months()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.iChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearMonthType.isPrecise()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$YearMonthType.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.getYearMonthType(org.joda.time.Chronology)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$YearMonthType.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$YearMonthType.withChronology(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$YearMonthType.DurationType$YearMonthType(org.joda.time.Chronology)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$YearMonthType.years()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.years()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.iChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearMonthType.isPrecise()</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.DurationType$YearWeekType</name>
            <outbound type="class" confirmed="yes">org.joda.time.DurationType$DayHourType</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$YearWeekType.DurationType$YearWeekType(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.DurationType$DayHourType(org.joda.time.Chronology)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearWeekType.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getYearWeekType(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$YearWeekType.isPrecise()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isPrecise()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.isPrecise()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$YearWeekType.weeks()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$YearWeekType.years()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$YearWeekType.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.getYearWeekType(org.joda.time.Chronology)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$YearWeekType.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$YearWeekType.weeks()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weeks()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.iChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearWeekType.isPrecise()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$YearWeekType.withChronology(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$YearWeekType.DurationType$YearWeekType(org.joda.time.Chronology)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.DurationType$YearWeekType.years()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weekyears()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType$DayHourType.iChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$YearWeekType.isPrecise()</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.Instant</name>
            <outbound type="class" confirmed="no">java.io.Serializable</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.AbstractInstant</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toInstant()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toInstant(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableDuration, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getEndInstant()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getStartInstant()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iEndInstant</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.iStartInstant</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setEndMillis(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setStartMillis(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.toInstant()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableInterval.getEndInstant()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableInterval.getStartInstant()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.DEFAULT_CUTOVER</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.GJChronology(org.joda.time.Chronology, org.joda.time.chrono.JulianChronology, org.joda.time.chrono.GregorianChronology, org.joda.time.Instant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.GJChronology(org.joda.time.chrono.JulianChronology, org.joda.time.chrono.GregorianChronology, org.joda.time.Instant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getGregorianCutover()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstanceUTC()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iCutoverInstant</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.Instant.Instant()</name>
                <outbound type="feature" confirmed="no">java.lang.System.currentTimeMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.AbstractInstant()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Instant.iMillis</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Instant.Instant(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.AbstractInstant()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Instant.iMillis</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterManager</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstance()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstantConverter(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.InstantConverter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.InstantConverter.getInstantMillis(java.lang.Object)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Instant.Instant(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.AbstractInstant()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Instant.iMillis</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toInstant(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getEndInstant()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getStartInstant()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Instant.withMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Instant.Instant(org.joda.time.ReadableInstant)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.AbstractInstant()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Instant.iMillis</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toInstant()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Instant.getChronology()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Instant.getMillis()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.Instant.iMillis</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Instant.getMillis(org.joda.time.ReadableInstant)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.Instant.iMillis</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Instant.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Instant.iMillis</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Instant.iMillis</name>
                <inbound type="feature" confirmed="yes">org.joda.time.Instant.Instant()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Instant.Instant(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Instant.Instant(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Instant.Instant(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Instant.getMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Instant.getMillis(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Instant.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Instant.withMillis(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Instant.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Instant.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.print(org.joda.time.ReadableInstant)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.ISODateTimeFormat</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTime()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstanceUTC()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Instant.withChronology(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Instant.withDateTimeZone(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Instant.withMillis(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.Instant.Instant(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Instant.iMillis</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.Interval</name>
            <outbound type="class" confirmed="no">java.io.Serializable</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.AbstractInterval</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.ReadableInterval</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.toInterval()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableInterval.toInterval()</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.Interval.Interval(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(java.lang.Object)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Interval.Interval(long, long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(long, long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Interval.Interval(org.joda.time.ReadableDuration, org.joda.time.ReadableInstant)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableDuration, org.joda.time.ReadableInstant)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Interval.Interval(org.joda.time.ReadableInstant, org.joda.time.ReadableDuration)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableDuration)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Interval.Interval(org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Interval.Interval(org.joda.time.ReadableInterval)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInterval)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInterval</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.toInterval()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Interval.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Interval.setDurationAfterStart(org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Interval.setDurationBeforeEnd(org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Interval.setEndMillis(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.Interval.setStartMillis(long)</name>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.MutableDateOnly</name>
            <outbound type="class" confirmed="no">java.io.Serializable</outbound>
            <outbound type="class" confirmed="no">java.lang.Cloneable</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.AbstractPartialInstant</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.MutableDateOnly()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.MutableDateOnly(int, int, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateOnlyMillis(int, int, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.MutableDateOnly(int, int, int, org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateOnlyMillis(int, int, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.MutableDateOnly(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.MutableDateOnly(java.lang.Object, org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.MutableDateOnly(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.MutableDateOnly(long, org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.withMillis(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.MutableDateOnly(org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.MutableDateOnly(org.joda.time.DateTimeZone)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.add(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.add(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.add(org.joda.time.ReadableDuration, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterManager</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getDurationConverter(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstance()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.DurationConverter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.DurationConverter.getDurationMillis(java.lang.Object)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.add(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setMillis(long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.add(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.add(org.joda.time.DateTimeField, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.add(org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.addInto(org.joda.time.ReadWritableInstant, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.add(org.joda.time.ReadableDuration, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.addInto(org.joda.time.ReadWritableInstant, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.add(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.addDays(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.days()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.addMonths(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.months()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.addWeeks(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weeks()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.addWeekyears(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weekyears()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.addWrapped(org.joda.time.DateTimeField, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.addWrapped(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.addYears(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.years()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.centuryOfEra()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.centuryOfEra()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.clone()</name>
                <outbound type="class" confirmed="no">java.lang.CloneNotSupportedException</outbound>
                <outbound type="feature" confirmed="no">java.lang.InternalError.InternalError(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.clone()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.copy()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.copy()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.clone()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.dayOfMonth()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfMonth()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.dayOfWeek()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfWeek()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.dayOfYear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfYear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.era()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.era()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.getCenturyOfEra()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.centuryOfEra()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.getDayOfMonth()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfMonth()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.getDayOfWeek()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfWeek()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.getDayOfYear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfYear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.getEra()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.era()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.getLowerLimit()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfYear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.getMonthOfYear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.monthOfYear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.getUpperLimit()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.getWeekOfWeekyear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weekOfWeekyear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.getWeekyear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weekyear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.getYear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.year()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.getYearOfCentury()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.yearOfCentury()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.getYearOfEra()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.yearOfEra()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.monthOfYear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.monthOfYear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.moveDateTimeZone(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.set(org.joda.time.DateTimeField, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.setChronology(org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.setChronology(org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.setDate(int, int, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateOnlyMillis(int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.setDate(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setMillis(java.lang.Object)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.setDate(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.setDateTimeZone(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.setDayOfMonth(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfMonth()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.setDayOfWeek(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfWeek()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.setDayOfYear(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfYear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.setMillis(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.setMillis(java.lang.Object)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setDate(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.setMillis(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.setMillis(long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.add(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.add(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addDays(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addMonths(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addWeeks(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addWeekyears(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addWrapped(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.addYears(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.set(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setDate(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setDate(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setDayOfMonth(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setDayOfWeek(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setDayOfYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setMonthOfYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setWeekOfWeekyear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setWeekyear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setYear(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.setMonthOfYear(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.monthOfYear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.setWeekOfWeekyear(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weekOfWeekyear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.setWeekyear(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weekyear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.setYear(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.year()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.print(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.ISODateTimeFormat</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.date()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance(org.joda.time.Chronology)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.weekOfWeekyear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weekOfWeekyear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.weekyear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weekyear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.withChronology(org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.withUTC()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.MutableDateOnly(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.withMillis(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.MutableDateOnly(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.year()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.year()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.yearOfCentury()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.yearOfCentury()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateOnly.yearOfEra()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.yearOfEra()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.MutableDateTime</name>
            <outbound type="class" confirmed="no">java.io.Serializable</outbound>
            <outbound type="class" confirmed="no">java.lang.Cloneable</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.AbstractDateTime</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.ReadWritableDateTime</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableDateTime.toMutableDateTime()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableDateTime.toMutableDateTime(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableDateTime.toMutableDateTime(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseMutableDateTime(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseMutableDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseMutableDateTime(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseMutableDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.parseMutableDateTime(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.parseMutableDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseMutableDateTime(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseMutableDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.MutableDateTime()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.MutableDateTime(int, int, int, int, int, int, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(int, int, int, int, int, int, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.MutableDateTime(int, int, int, int, int, int, int, org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(int, int, int, int, int, int, int, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.MutableDateTime(int, int, int, int, int, int, int, org.joda.time.DateTimeZone)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(int, int, int, int, int, int, int, org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.MutableDateTime(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.MutableDateTime(java.lang.Object, org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant, org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.MutableDateTime(java.lang.Object, org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object, org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.MutableDateTime(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.MutableDateTime(long, org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.withMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseMutableDateTime(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseMutableDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseTime(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.MutableDateTime(long, org.joda.time.DateTimeZone)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(long, org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.MutableDateTime(org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.MutableDateTime(org.joda.time.DateTimeZone)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.add(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.add(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.add(org.joda.time.ReadableDuration, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterManager</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getDurationConverter(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstance()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.DurationConverter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.DurationConverter.getDurationMillis(java.lang.Object)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.add(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.add(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.add(org.joda.time.DateTimeField, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.add(org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.addInto(org.joda.time.ReadWritableInstant, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.add(org.joda.time.ReadableDuration, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.addInto(org.joda.time.ReadWritableInstant, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.add(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.addDays(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.days()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.addHours(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.hours()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.addMillis(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.addMinutes(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.minutes()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.addMonths(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.months()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.addSeconds(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.seconds()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.addWeeks(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weeks()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.addWeekyears(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weekyears()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.addWrapped(org.joda.time.DateTimeField, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.addWrapped(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.addYears(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.years()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.centuryOfEra()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.centuryOfEra()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.clone()</name>
                <outbound type="class" confirmed="no">java.lang.CloneNotSupportedException</outbound>
                <outbound type="feature" confirmed="no">java.lang.InternalError.InternalError(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.clone()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.copy()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.copy()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.clone()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.dayOfMonth()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfMonth()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.dayOfWeek()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfWeek()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.dayOfYear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfYear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.era()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.era()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.hourOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.hourOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.millisOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millisOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.millisOfSecond()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millisOfSecond()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.minuteOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.minuteOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.minuteOfHour()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.minuteOfHour()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.monthOfYear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.monthOfYear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.moveDateTimeZone(org.joda.time.DateTimeZone)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.moveDateTimeZone(org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.secondOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.secondOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.secondOfMinute()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.secondOfMinute()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.set(org.joda.time.DateTimeField, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.setChronology(org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.setChronology(org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.setDate(int, int, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeMillis(int, int, int, int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDate(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.setDate(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDate(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterManager</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstance()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstantConverter(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.InstantConverter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.InstantConverter.getInstantMillis(java.lang.Object)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.setDate(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateOnlyMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getTimeOnlyMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDate(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDate(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.setDateTime(int, int, int, int, int, int, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeMillis(int, int, int, int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDateTime(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.setDateTime(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.setDateTime(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDateTime(int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setTime(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.setDateTimeZone(org.joda.time.DateTimeZone)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.setDateTimeZone(org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.setDayOfMonth(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfMonth()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.setDayOfWeek(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfWeek()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.setDayOfYear(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfYear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.setHourOfDay(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.hourOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.setMillis(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.setMillis(java.lang.Object)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.setMillis(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.setMillis(long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.add(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.add(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addDays(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addHours(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addMillis(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addMinutes(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addMonths(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addSeconds(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addWeeks(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addWeekyears(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addWrapped(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.addYears(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.set(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDate(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDateTime(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDayOfMonth(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDayOfWeek(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDayOfYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setHourOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillisOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillisOfSecond(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMinuteOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMinuteOfHour(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMonthOfYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setSecondOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setSecondOfMinute(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setTime(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setWeekOfWeekyear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setWeekyear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setYear(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.setMillisOfDay(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millisOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.setMillisOfSecond(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millisOfSecond()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.setMinuteOfDay(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.minuteOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.setMinuteOfHour(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.minuteOfHour()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.setMonthOfYear(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.monthOfYear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.setSecondOfDay(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.secondOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.setSecondOfMinute(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.secondOfMinute()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.setTime(int, int, int, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeMillis(long, int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setTime(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.setTime(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDateTime(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterManager</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstance()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstantConverter(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.InstantConverter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.InstantConverter.getInstantMillis(java.lang.Object)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.setTime(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateOnlyMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getTimeOnlyMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setTime(int, int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.setWeekOfWeekyear(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weekOfWeekyear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.setWeekyear(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weekyear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.setYear(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.year()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.print(org.joda.time.ReadableInstant)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.ISODateTimeFormat</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTime()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance(org.joda.time.Chronology)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.weekOfWeekyear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weekOfWeekyear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.weekyear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weekyear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.withChronology(org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.withMillis(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.year()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.year()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.yearOfCentury()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.yearOfCentury()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDateTime.yearOfEra()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.yearOfEra()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.MutableDuration</name>
            <outbound type="class" confirmed="no">java.io.Serializable</outbound>
            <outbound type="class" confirmed="no">java.lang.Cloneable</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.AbstractDuration</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.ReadWritableDuration</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.toMutableDuration()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.toMutableDuration()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.parseDuration(org.joda.time.DurationType, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.parseMutableDuration(org.joda.time.DurationType, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationParser.parseMutableDuration(org.joda.time.DurationType, java.lang.String)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.MutableDuration(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(java.lang.Object)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.MutableDuration(org.joda.time.DurationType)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.MutableDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, int, int, int, int, int, int, int, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.MutableDuration(org.joda.time.DurationType, java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.MutableDuration(org.joda.time.DurationType, long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.parseMutableDuration(org.joda.time.DurationType, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.MutableDuration(org.joda.time.DurationType, long, long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, long, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.MutableDuration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.MutableDuration(org.joda.time.DurationType, org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.MutableDuration(org.joda.time.ReadableDuration)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.ReadableDuration)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.toMutableDuration()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.add(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.add(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.add(org.joda.time.ReadableDuration)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.add(org.joda.time.ReadableDuration)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.addDays(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addDays(int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.addHours(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addHours(int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.addMillis(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addMillis(int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.addMinutes(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addMinutes(int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.addMonths(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addMonths(int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.addSeconds(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addSeconds(int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.addWeeks(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addWeeks(int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.addYears(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addYears(int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.clone()</name>
                <outbound type="class" confirmed="no">java.lang.CloneNotSupportedException</outbound>
                <outbound type="feature" confirmed="no">java.lang.InternalError.InternalError(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.clone()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.copy()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.copy()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDuration.clone()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.normalize()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.normalize()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.setDays(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDays(int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.setDuration(int, int, int, int, int, int, int, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(int, int, int, int, int, int, int, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.setDuration(org.joda.time.ReadableDuration)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.ReadableDuration)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.setHours(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setHours(int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.setMillis(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setMillis(int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.setMinutes(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setMinutes(int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.setMonths(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setMonths(int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.setSeconds(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setSeconds(int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.setTotalMillis(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.setTotalMillis(long, long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setTotalMillis(long, long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.setWeeks(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setWeeks(int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableDuration.setYears(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setYears(int)</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.MutableInterval</name>
            <outbound type="class" confirmed="no">java.io.Serializable</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.AbstractInterval</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInterval</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.toMutableInterval()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableInterval.toMutableInterval()</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.MutableInterval.MutableInterval(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(java.lang.Object)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableInterval.MutableInterval(long, long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(long, long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableInterval.MutableInterval(org.joda.time.ReadableDuration, org.joda.time.ReadableInstant)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableDuration, org.joda.time.ReadableInstant)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableInterval.MutableInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableDuration)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableDuration)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableInterval.MutableInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableInterval.MutableInterval(org.joda.time.ReadableInterval)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInterval)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInterval</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.toMutableInterval()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableInterval.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableInterval.setDurationAfterStart(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getStartMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setEndMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableInterval.setDurationAfterStart(org.joda.time.ReadableDuration)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setDurationAfterStart(org.joda.time.ReadableDuration)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableInterval.setDurationBeforeEnd(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.getEndMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setStartMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableInterval.setDurationBeforeEnd(org.joda.time.ReadableDuration)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setDurationBeforeEnd(org.joda.time.ReadableDuration)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableInterval.setEndInstant(org.joda.time.ReadableInstant)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setEndMillis(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableInterval.setEndMillis(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setEndMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableInterval.setStartInstant(org.joda.time.ReadableInstant)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setStartMillis(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableInterval.setStartMillis(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setStartMillis(long)</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.MutableTimeOnly</name>
            <outbound type="class" confirmed="no">java.io.Serializable</outbound>
            <outbound type="class" confirmed="no">java.lang.Cloneable</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.AbstractPartialInstant</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.MutableTimeOnly()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.MutableTimeOnly(int, int, int, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getTimeOnlyMillis(int, int, int, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.MutableTimeOnly(int, int, int, int, org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getTimeOnlyMillis(int, int, int, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.MutableTimeOnly(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.MutableTimeOnly(java.lang.Object, org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.MutableTimeOnly(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.MutableTimeOnly(long, org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.withMillis(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.MutableTimeOnly(org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.MutableTimeOnly(org.joda.time.DateTimeZone)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.add(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.add(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.add(org.joda.time.ReadableDuration, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterManager</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getDurationConverter(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstance()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.DurationConverter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.DurationConverter.getDurationMillis(java.lang.Object)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.add(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillis(long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.add(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.add(org.joda.time.DateTimeField, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.add(org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.addInto(org.joda.time.ReadWritableInstant, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.add(org.joda.time.ReadableDuration, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.addInto(org.joda.time.ReadWritableInstant, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.add(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.addHours(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.hours()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.addMillis(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.addMinutes(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.minutes()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.addSeconds(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.seconds()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.addWrapped(org.joda.time.DateTimeField, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.addWrapped(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.clockhourOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.clockhourOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.clockhourOfHalfday()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.clockhourOfHalfday()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.clone()</name>
                <outbound type="class" confirmed="no">java.lang.CloneNotSupportedException</outbound>
                <outbound type="feature" confirmed="no">java.lang.InternalError.InternalError(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.clone()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.copy()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.copy()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.clone()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.getClockhourOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.clockhourOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.getClockhourOfHalfday()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.clockhourOfHalfday()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.getHalfdayOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.halfdayOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.getHourOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.hourOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.getHourOfHalfday()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.hourOfHalfday()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.getLowerLimit()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.getMillisOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millisOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.getMillisOfSecond()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millisOfSecond()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.getMinuteOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.minuteOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.getMinuteOfHour()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.minuteOfHour()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.getSecondOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.secondOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.getSecondOfMinute()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.secondOfMinute()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.getUpperLimit()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfYear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.halfdayOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.halfdayOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.hourOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.hourOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.hourOfHalfday()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.hourOfHalfday()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.millisOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millisOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.millisOfSecond()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millisOfSecond()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.minuteOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.minuteOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.minuteOfHour()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.minuteOfHour()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.moveDateTimeZone(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.secondOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.secondOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.secondOfMinute()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.secondOfMinute()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.set(org.joda.time.DateTimeField, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.setChronology(org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.setChronology(org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.setClockhourOfDay(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.clockhourOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.setClockhourOfHalfday(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.clockhourOfHalfday()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.setDateTimeZone(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.setHalfdayOfDay(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.halfdayOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.setHourOfDay(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.hourOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.setHourOfHalfday(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.hourOfHalfday()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.setMillis(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.setMillis(java.lang.Object)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setTime(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.setMillis(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.setMillis(long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.add(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.add(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.addHours(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.addMillis(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.addMinutes(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.addSeconds(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.addWrapped(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.set(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setClockhourOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setClockhourOfHalfday(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setHalfdayOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setHourOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setHourOfHalfday(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillisOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillisOfSecond(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMinuteOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMinuteOfHour(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setSecondOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setSecondOfMinute(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setTime(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setTime(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.setMillisOfDay(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millisOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.setMillisOfSecond(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millisOfSecond()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.setMinuteOfDay(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.minuteOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.setMinuteOfHour(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.minuteOfHour()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.setSecondOfDay(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.secondOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.setSecondOfMinute(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.secondOfMinute()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.setTime(int, int, int, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getTimeOnlyMillis(int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.setTime(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillis(java.lang.Object)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.setTime(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.setMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.print(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.ISODateTimeFormat</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinuteSecondFraction()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.withChronology(org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.withUTC()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.MutableTimeOnly(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.MutableTimeOnly.withMillis(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.MutableTimeOnly(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.PartialInstant</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            <inbound type="class" confirmed="yes">org.joda.time.AbstractPartialInstant</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.isMatchingType(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.getChronology(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.getInstantMillis(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.getInstantMillis(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.PartialInstant.equals(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.PartialInstant.getChronology()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.getChronology(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.PartialInstant.getLowerLimit()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.isMatchingType(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.PartialInstant.getMillis()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.getInstantMillis(java.lang.Object, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.getInstantMillis(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.PartialInstant.getMillis(org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.PartialInstant.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.PartialInstant.getUpperLimit()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.isMatchingType(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.PartialInstant.hashCode()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.PartialInstant.resetSupportedFields(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.PartialInstant.resetUnsupportedFields(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.PartialInstant.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.ReadWritableDateTime</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.ReadableDateTime</outbound>
            <inbound type="class" confirmed="yes">org.joda.time.MutableDateTime</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDateTime.addDays(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDateTime.addHours(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDateTime.addMillis(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDateTime.addMinutes(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDateTime.addMonths(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDateTime.addSeconds(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDateTime.addWeeks(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDateTime.addWeekyears(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDateTime.addYears(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDateTime.setDate(int, int, int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDateTime.setDate(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDateTime.setDate(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDateTime.setDateTime(int, int, int, int, int, int, int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDateTime.setDateTime(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDateTime.setDateTime(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDateTime.setDayOfMonth(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDateTime.setDayOfWeek(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDateTime.setDayOfYear(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDateTime.setHourOfDay(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDateTime.setMillisOfDay(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDateTime.setMillisOfSecond(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDateTime.setMinuteOfDay(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDateTime.setMinuteOfHour(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDateTime.setMonthOfYear(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDateTime.setSecondOfDay(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDateTime.setSecondOfMinute(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDateTime.setTime(int, int, int, int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDateTime.setTime(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDateTime.setTime(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDateTime.setWeekOfWeekyear(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDateTime.setWeekyear(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDateTime.setYear(int)</name>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.ReadWritableDuration</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, java.lang.Object)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.MutableDuration</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.DurationConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.parseMutableDuration(org.joda.time.DurationType, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.setFieldValue(org.joda.time.ReadWritableDuration, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationParser.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDuration.add(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDuration.add(org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDuration.addDays(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDuration.addHours(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDuration.addMillis(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDuration.addMinutes(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDuration.addMonths(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDuration.addSeconds(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDuration.addWeeks(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDuration.addYears(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDuration.normalize()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDuration.setDays(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.setFieldValue(org.joda.time.ReadWritableDuration, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDuration.setDuration(int, int, int, int, int, int, int, int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDuration.setDuration(org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDuration.setHours(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.setFieldValue(org.joda.time.ReadWritableDuration, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDuration.setMillis(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.setFieldValue(org.joda.time.ReadWritableDuration, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDuration.setMinutes(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.setFieldValue(org.joda.time.ReadWritableDuration, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDuration.setMonths(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.setFieldValue(org.joda.time.ReadWritableDuration, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDuration.setSeconds(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.setFieldValue(org.joda.time.ReadWritableDuration, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDuration.setTotalMillis(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDuration.setTotalMillis(long, long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDuration.setWeeks(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.setFieldValue(org.joda.time.ReadWritableDuration, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableDuration.setYears(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.setFieldValue(org.joda.time.ReadWritableDuration, int)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.ReadWritableInstant</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addInto(org.joda.time.ReadWritableInstant, int)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.MutableDateOnly</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.add(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.add(org.joda.time.ReadableDuration, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.centuryOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.dayOfMonth()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.dayOfWeek()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.dayOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.era()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.monthOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.weekOfWeekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.weekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.year()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.yearOfCentury()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.yearOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.add(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.add(org.joda.time.ReadableDuration, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.centuryOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.dayOfMonth()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.dayOfWeek()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.dayOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.era()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.hourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.millisOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.millisOfSecond()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.minuteOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.minuteOfHour()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.monthOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.secondOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.secondOfMinute()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.weekOfWeekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.weekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.year()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.yearOfCentury()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.yearOfEra()</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.MutableTimeOnly</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.add(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.add(org.joda.time.ReadableDuration, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.clockhourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.clockhourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.halfdayOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.hourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.hourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.millisOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.millisOfSecond()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.minuteOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.minuteOfHour()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.secondOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.secondOfMinute()</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.ReadWritableDateTime</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.addInto(org.joda.time.ReadWritableInstant, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.add(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.add(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.addWrapped(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.getInstant()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.iInstant</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundCeiling()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundFloor()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundHalfCeiling()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundHalfEven()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundHalfFloor()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.set(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.set(java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseTime(java.lang.String)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableInstant.add(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableInstant.add(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableInstant.add(org.joda.time.DateTimeField, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableInstant.add(org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableInstant.add(org.joda.time.ReadableDuration, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableInstant.addWrapped(org.joda.time.DateTimeField, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableInstant.moveDateTimeZone(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableInstant.set(org.joda.time.DateTimeField, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableInstant.setChronology(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableInstant.setDateTimeZone(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableInstant.setMillis(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableInstant.setMillis(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addInto(org.joda.time.ReadWritableInstant, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.add(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.add(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.addWrapped(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundCeiling()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundFloor()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundHalfCeiling()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundHalfEven()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundHalfFloor()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.set(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.set(java.lang.String, java.util.Locale)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.ReadWritableInterval</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.ReadableInterval</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(java.lang.Object)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.MutableInterval</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.IntervalConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableInterval.setDurationAfterStart(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableInterval.setDurationAfterStart(org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableInterval.setDurationBeforeEnd(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableInterval.setDurationBeforeEnd(org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableInterval.setEndInstant(org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableInterval.setEndMillis(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableInterval.setStartInstant(org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadWritableInterval.setStartMillis(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.ReadableDateTime</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            <inbound type="class" confirmed="yes">org.joda.time.AbstractDateTime</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.DateTime</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.ReadWritableDateTime</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getInstance(org.joda.time.Chronology, org.joda.time.ReadableDateTime, org.joda.time.ReadableDateTime)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDateTime.getCenturyOfEra()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDateTime.getDayOfMonth()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDateTime.getDayOfWeek()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDateTime.getDayOfYear()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDateTime.getEra()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDateTime.getHourOfDay()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDateTime.getMillisOfDay()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDateTime.getMillisOfSecond()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDateTime.getMinuteOfDay()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDateTime.getMinuteOfHour()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDateTime.getMonthOfYear()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDateTime.getSecondOfDay()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDateTime.getSecondOfMinute()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDateTime.getWeekOfWeekyear()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDateTime.getWeekyear()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDateTime.getYear()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDateTime.getYearOfCentury()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDateTime.getYearOfEra()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDateTime.toDateOnly()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateOnly</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDateTime.toDateOnly(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateOnly</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDateTime.toDateTime()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getInstance(org.joda.time.Chronology, org.joda.time.ReadableDateTime, org.joda.time.ReadableDateTime)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDateTime.toDateTime(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDateTime.toDateTime(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDateTime.toMutableDateTime()</name>
                <outbound type="class" confirmed="yes">org.joda.time.MutableDateTime</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDateTime.toMutableDateTime(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.MutableDateTime</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDateTime.toMutableDateTime(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.MutableDateTime</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDateTime.toString(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDateTime.toString(java.lang.String, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDateTime.toTimeOnly()</name>
                <outbound type="class" confirmed="yes">org.joda.time.TimeOnly</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDateTime.toTimeOnly(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.TimeOnly</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.ReadableDuration</name>
            <outbound type="class" confirmed="no">java.lang.Comparable</outbound>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="class" confirmed="yes">org.joda.time.AbstractDuration</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.add(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.compareTo(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.equals(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.isEqual(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.isLongerThan(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.isShorterThan(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.toDuration()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.toMutableDuration()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableDuration, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setDurationAfterStart(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setDurationBeforeEnd(org.joda.time.ReadableDuration)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.Duration</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Duration.Duration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Duration.Duration(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Duration.setDuration(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Interval.Interval(org.joda.time.ReadableDuration, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Interval.Interval(org.joda.time.ReadableInstant, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Interval.setDurationAfterStart(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Interval.setDurationBeforeEnd(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.add(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.add(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.add(org.joda.time.ReadableDuration, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.add(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.add(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.add(org.joda.time.ReadableDuration, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.MutableDuration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.MutableDuration(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.add(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.setDuration(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.MutableInterval(org.joda.time.ReadableDuration, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.MutableInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.setDurationAfterStart(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.setDurationBeforeEnd(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.add(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.add(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.add(org.joda.time.ReadableDuration, int)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.ReadWritableDuration</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadWritableDuration.add(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadWritableDuration.setDuration(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadWritableInstant.add(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadWritableInstant.add(org.joda.time.ReadableDuration, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadWritableInterval.setDurationAfterStart(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadWritableInterval.setDurationBeforeEnd(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.getDurationMillis(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.getDurationType(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.isPrecise(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.countFieldsToPrint(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.print(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.chooseFieldToPrint(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.countFieldsToPrint(org.joda.time.ReadableDuration, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.countFieldsToPrint(org.joda.time.ReadableDuration, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.countFieldsToPrint(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.countFieldsToPrint(org.joda.time.ReadableDuration, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.getFieldValue(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal.countFieldsToPrint(org.joda.time.ReadableDuration, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.countFieldsToPrint(org.joda.time.ReadableDuration, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationPrinter.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationPrinter.countFieldsToPrint(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationPrinter.countFieldsToPrint(org.joda.time.ReadableDuration, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationPrinter.print(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationPrinter.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationPrinter.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDuration.addInto(org.joda.time.ReadWritableInstant, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.add(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.add(org.joda.time.ReadableDuration, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.add(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.add(org.joda.time.ReadableDuration, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.add(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.add(org.joda.time.ReadableDuration, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDuration.addTo(long, int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setDurationAfterStart(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setDurationBeforeEnd(org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDuration.addTo(long, int, org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDuration.addTo(org.joda.time.ReadableInstant, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableDuration, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDuration.compareTo(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDuration.equals(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDuration.getDays()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.getFieldValue(org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDuration.getDurationType()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.getDurationType(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.chooseFieldToPrint(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.getFieldValue(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDuration.getHours()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.getFieldValue(org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDuration.getMillis()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.getFieldValue(org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDuration.getMinutes()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.getFieldValue(org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDuration.getMonths()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.getFieldValue(org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDuration.getSeconds()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.getFieldValue(org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDuration.getTotalMillis()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.add(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.compareTo(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.getDurationMillis(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDuration.getWeeks()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.getFieldValue(org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDuration.getYears()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.setDuration(org.joda.time.DurationType, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.getFieldValue(org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDuration.hashCode()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDuration.isEqual(org.joda.time.ReadableDuration)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDuration.isLongerThan(org.joda.time.ReadableDuration)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDuration.isPrecise()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableDuration, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setDurationAfterStart(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setDurationBeforeEnd(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.isPrecise(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDuration.isShorterThan(org.joda.time.ReadableDuration)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDuration.toDuration()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Duration</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableDuration, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setDurationAfterStart(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.setDurationBeforeEnd(org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDuration.toMutableDuration()</name>
                <outbound type="class" confirmed="yes">org.joda.time.MutableDuration</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableDuration.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.ReadableInstant</name>
            <outbound type="class" confirmed="no">java.lang.Comparable</outbound>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.setMillis(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.toString(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.toString(java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.withMillis(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(org.joda.time.ReadableInstant, int)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.AbstractInstant</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.compareTo(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.equals(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.getMillis(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.isAfter(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.isBefore(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.isEqual(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toInstant()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toInstant(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.withMillis(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableDuration, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.contains(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.isAfter(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.isBefore(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.setMillis(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.withMillis(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.withMillis(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.compare(java.lang.Object, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Duration.Duration(org.joda.time.DurationType, org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.Instant</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Instant.Instant(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Instant.getMillis(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Instant.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Instant.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Instant.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Instant.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Instant.withMillis(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Interval.Interval(org.joda.time.ReadableDuration, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Interval.Interval(org.joda.time.ReadableInstant, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Interval.Interval(org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.withMillis(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDate(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setTime(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.withMillis(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDuration.MutableDuration(org.joda.time.DurationType, org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.MutableInterval(org.joda.time.ReadableDuration, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.MutableInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.MutableInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.setEndInstant(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.setStartInstant(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.withMillis(long)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.PartialInstant</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.PartialInstant.getMillis(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.PartialInstant.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadWritableInterval.setEndInstant(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadWritableInterval.setStartInstant(org.joda.time.ReadableInstant)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.ReadableDateTime</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.addTo(org.joda.time.ReadableInstant, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableInterval.contains(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableInterval.isAfter(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableInterval.isBefore(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.withMillis(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstanceUTC()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.getMessage()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getInstance(org.joda.time.Chronology, org.joda.time.ReadableDateTime, org.joda.time.ReadableDateTime)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.getChronology(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.getInstantMillis(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.getInstantLocal(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseMutableDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.print(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.io.Writer, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseMutableDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.print(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.printTo(java.io.Writer, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.parseDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.parseMutableDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.print(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.io.Writer, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseMutableDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.print(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.io.Writer, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.compareTo(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.get()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getAsShortText(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getAsText()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getAsText(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getDifference(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getDifferenceAsLong(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getInstant()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getLeapAmount()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getMaximumValue()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getMinimumValue()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.isLeap()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.remainder()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.addToCopy(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.addToCopy(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.addWrappedToCopy(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.getInstant()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundCeilingCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundFloorCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundHalfCeilingCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundHalfEvenCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundHalfFloorCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.setCopy(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.setCopy(java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.addToCopy(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.addToCopy(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.addWrappedToCopy(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.getInstant()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundCeilingCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundFloorCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundHalfCeilingCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundHalfEvenCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundHalfFloorCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.setCopy(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.setCopy(java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.getInstant()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.addToCopy(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.addToCopy(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.addWrappedToCopy(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.getInstant()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundCeilingCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundFloorCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundHalfCeilingCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundHalfEvenCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundHalfFloorCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.setCopy(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.setCopy(java.lang.String, java.util.Locale)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInstant.compareTo(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInstant.equals(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInstant.get(org.joda.time.DateTimeField)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.compareTo(org.joda.time.ReadableInstant)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInstant.getChronology()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.getDateTimeZone()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.hashCode()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toTrustedISODateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.getChronology(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.print(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.io.Writer, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInstant.getDateTimeZone()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.getInstantLocal(org.joda.time.ReadableInstant)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInstant.getMillis()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.setMillis(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addInto(org.joda.time.ReadWritableInstant, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(org.joda.time.ReadableInstant, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.get(org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.hashCode()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDate()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableDuration, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInstant, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.contains(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.isAfter(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.isBefore(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.setMillis(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.compare(java.lang.Object, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Instant.Instant(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDate(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setTime(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.setEndInstant(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.setStartInstant(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.getInstantMillis(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.getInstantLocal(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.print(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.io.Writer, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.get()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getAsShortText(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getAsText()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getAsText(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getDifference(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getDifferenceAsLong(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getLeapAmount()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getMaximumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getMinimumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.isLeap()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.remainder()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.add(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.add(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.addWrapped(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundCeiling()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundFloor()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundHalfCeiling()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundHalfEven()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundHalfFloor()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.set(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.set(java.lang.String, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInstant.getMillis(org.joda.time.ReadableInstant)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.compareTo(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.isAfter(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.isBefore(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.isEqual(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.compare(java.lang.Object, java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInstant.getMillis(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toInstant(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInstant.hashCode()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInstant.isAfter(org.joda.time.ReadableInstant)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInstant.isBefore(org.joda.time.ReadableInstant)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getInstance(org.joda.time.Chronology, org.joda.time.ReadableDateTime, org.joda.time.ReadableDateTime)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInstant.isEqual(org.joda.time.ReadableInstant)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInstant.toInstant()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Instant</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInstant.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInstant.withChronology(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInstant.withDateTimeZone(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInstant.withMillis(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.addTo(org.joda.time.ReadableInstant, int)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.ReadableInterval</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="class" confirmed="yes">org.joda.time.AbstractInterval</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInterval)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.contains(org.joda.time.ReadableInterval)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.equals(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.overlaps(org.joda.time.ReadableInterval)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.toInterval()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.toMutableInterval()</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.Interval</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Interval.Interval(org.joda.time.ReadableInterval)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableInterval.MutableInterval(org.joda.time.ReadableInterval)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.ReadWritableInterval</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.getDurationMillis(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.getDurationType(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInterval.contains(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInterval.contains(org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInterval.contains(org.joda.time.ReadableInterval)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInterval.equals(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInterval.getDuration()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Duration</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInterval)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.getDurationType(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInterval.getDurationMillis()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.getDurationMillis(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInterval.getEndInstant()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Instant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInterval.getEndMillis()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInterval)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.contains(org.joda.time.ReadableInterval)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.overlaps(org.joda.time.ReadableInterval)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInterval.getStartInstant()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Instant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInterval.getStartMillis()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(org.joda.time.ReadableInterval)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.contains(org.joda.time.ReadableInterval)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.overlaps(org.joda.time.ReadableInterval)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInterval.hashCode()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInterval.isAfter(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInterval.isAfter(org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInterval.isBefore(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInterval.isBefore(org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInterval.overlaps(org.joda.time.ReadableInterval)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInterval.toInterval()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Interval</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInterval.toMutableInterval()</name>
                <outbound type="class" confirmed="yes">org.joda.time.MutableInterval</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.ReadableInterval.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.TimeOnly</name>
            <outbound type="class" confirmed="no">java.io.Serializable</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.AbstractPartialInstant</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toTimeOnly()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toTimeOnly(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableDateTime.toTimeOnly()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.ReadableDateTime.toTimeOnly(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.TimeOnlyFieldProperty(org.joda.time.TimeOnly, org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.addToCopy(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.addToCopy(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.addWrappedToCopy(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.getDateTime()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.getInstant()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.iInstant</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundCeilingCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundFloorCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundHalfCeilingCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundHalfEvenCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundHalfFloorCopy()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.setCopy(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.setCopy(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.setCopy(java.lang.String, java.util.Locale)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.TimeOnly()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.TimeOnly(int, int, int, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getTimeOnlyMillis(int, int, int, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.TimeOnly(int, int, int, int, org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getTimeOnlyMillis(int, int, int, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.TimeOnly(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toTimeOnly()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.TimeOnly(java.lang.Object, org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toTimeOnly(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.TimeOnly(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.TimeOnly(long, org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.withMillis(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.TimeOnly(org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.TimeOnly(org.joda.time.DateTimeZone)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.clockhourOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.clockhourOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.TimeOnlyFieldProperty(org.joda.time.TimeOnly, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.clockhourOfHalfday()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.clockhourOfHalfday()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.TimeOnlyFieldProperty(org.joda.time.TimeOnly, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.getClockhourOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.clockhourOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.getClockhourOfHalfday()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.clockhourOfHalfday()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.getHalfdayOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.halfdayOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.getHourOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.hourOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.getHourOfHalfday()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.hourOfHalfday()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.getLowerLimit()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.getMillisOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millisOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.getMillisOfSecond()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millisOfSecond()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.getMinuteOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.minuteOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.getMinuteOfHour()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.minuteOfHour()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.getSecondOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.secondOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.getSecondOfMinute()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.secondOfMinute()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.getUpperLimit()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfYear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.halfdayOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.halfdayOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.TimeOnlyFieldProperty(org.joda.time.TimeOnly, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.hourOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.hourOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.TimeOnlyFieldProperty(org.joda.time.TimeOnly, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.hourOfHalfday()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.hourOfHalfday()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.TimeOnlyFieldProperty(org.joda.time.TimeOnly, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.millisOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millisOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.TimeOnlyFieldProperty(org.joda.time.TimeOnly, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.millisOfSecond()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millisOfSecond()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.TimeOnlyFieldProperty(org.joda.time.TimeOnly, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.minuteOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.minuteOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.TimeOnlyFieldProperty(org.joda.time.TimeOnly, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.minuteOfHour()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.minuteOfHour()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.TimeOnlyFieldProperty(org.joda.time.TimeOnly, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.secondOfDay()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.secondOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.TimeOnlyFieldProperty(org.joda.time.TimeOnly, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.secondOfMinute()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.secondOfMinute()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.TimeOnlyFieldProperty(org.joda.time.TimeOnly, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.setChronology(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.setMillis(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.print(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.ISODateTimeFormat</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinuteSecondFraction()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.withChronology(org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.withUTC()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.TimeOnly.TimeOnly(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.TimeOnly.withMillis(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.resetUnsupportedFields(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.TimeOnly.TimeOnly(long, org.joda.time.Chronology)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.addToCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.addToCopy(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.addWrappedToCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundCeilingCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundFloorCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundHalfCeilingCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundHalfEvenCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundHalfFloorCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.setCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.setCopy(java.lang.String, java.util.Locale)</inbound>
            </feature>
        </class>
    </package>
    <package confirmed="yes">
        <name>org.joda.time.chrono</name>
        <class confirmed="yes">
            <name>org.joda.time.chrono.AbstractChronology</name>
            <outbound type="class" confirmed="no">java.io.Serializable</outbound>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.AssembledChronology</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.AbstractChronology()</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.AssembledChronology(org.joda.time.Chronology, java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.centuries()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getInstance(java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.centuryOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.centuryOfEra()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.centuries()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.clockhourOfDay()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.hours()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.clockhourOfHalfday()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.hours()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.dayOfMonth()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.days()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateTimeMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.dayOfWeek()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.days()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.dayOfYear()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.days()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateOnlyMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getTimeOnlyMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.days()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getInstance(java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.dayOfMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.dayOfWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.dayOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.era()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.eras()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.eras()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getInstance(java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.era()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.getDateOnlyMillis(int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateTimeMillis(int, int, int, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateOnlyMillis(int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.getDateOnlyMillis(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundFloor(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.dayOfYear()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateOnlyMillis(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.getDateTimeMillis(int, int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.dayOfMonth()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.millisOfDay()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.monthOfYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.year()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateOnlyMillis(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeMillis(int, int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.getDateTimeMillis(int, int, int, int, int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.dayOfMonth()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.hourOfDay()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.millisOfSecond()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.minuteOfHour()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.monthOfYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.secondOfMinute()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.year()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.getDateTimeMillis(long, int, int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.hourOfDay()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.millisOfSecond()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.minuteOfHour()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.secondOfMinute()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.getDateTimeZone()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.getTimeOnlyMillis(int, int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.hourOfDay()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.millisOfSecond()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.minuteOfHour()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.secondOfMinute()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.getTimeOnlyMillis(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.remainder(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.dayOfYear()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getTimeOnlyMillis(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.halfdayOfDay()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getInstance(java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.hourOfDay()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.hours()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.hourOfHalfday()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.hours()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.hours()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getInstance(java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.clockhourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.clockhourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.hourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.hourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.millis()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getInstance(java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.millisOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.millisOfSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.millisOfDay()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.millis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateTimeMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.millisOfSecond()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.millis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.minuteOfDay()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.minutes()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.minuteOfHour()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.minutes()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.minutes()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getInstance(java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.minuteOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.minuteOfHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.monthOfYear()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.months()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateTimeMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.months()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getInstance(java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.monthOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.secondOfDay()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.seconds()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.secondOfMinute()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.seconds()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.seconds()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getInstance(java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.secondOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.secondOfMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.weekOfWeekyear()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.weeks()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.weeks()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getInstance(java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.weekOfWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.weekyear()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.weekyears()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.weekyears()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getInstance(java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.weekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.withDateTimeZone(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.withUTC()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.year()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.years()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateTimeMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.yearOfCentury()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.years()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.yearOfEra()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.years()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractChronology.years()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getInstance(java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.year()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.yearOfCentury()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.yearOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.AbstractGJChronology</name>
            <outbound type="class" confirmed="yes">org.joda.time.chrono.AssembledChronology</outbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.CopticChronology</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticDayOfMonthDateTimeField.CopticDayOfMonthDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticDayOfMonthDateTimeField.get(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticDayOfMonthDateTimeField.getMaximumValue(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticDayOfMonthDateTimeField.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticDayOfMonthDateTimeField.iChronology</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticDayOfMonthDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.CopticMonthOfYearDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.get(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.getLeapDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.iChronology</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.isLeap(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.CopticYearDateTimeField(org.joda.time.chrono.AbstractGJChronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.addWrapped(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.get(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.getDifferenceAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.getLeapAmount(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.getLeapDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.getMaximumValue()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.getMinimumValue()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.iChronology</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.isLeap(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.roundCeiling(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.roundFloor(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfMonthDateTimeField.GJDayOfMonthDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfMonthDateTimeField.get(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfMonthDateTimeField.getMaximumValue(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfMonthDateTimeField.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfMonthDateTimeField.iChronology</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfMonthDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.GJDayOfWeekDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.get(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.iChronology</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfYearDateTimeField.GJDayOfYearDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfYearDateTimeField.get(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfYearDateTimeField.getMaximumValue(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfYearDateTimeField.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfYearDateTimeField.iChronology</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfYearDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.GJEraDateTimeField(org.joda.time.chrono.AbstractGJChronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.get(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.iChronology</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.roundCeiling(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.roundFloor(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.GJMonthOfYearDateTimeField(org.joda.time.chrono.AbstractGJChronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.add(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.add(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.get(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getDifferenceAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getLeapDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.iChronology</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.isLeap(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.roundFloor(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.GJWeekOfWeekyearDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.get(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.getMaximumValue(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.getRangeDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.iChronology</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.GJWeekyearDateTimeField(org.joda.time.chrono.AbstractGJChronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.get(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.getDifferenceAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.getLeapAmount(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.getLeapDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.getMaximumValue()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.getMinimumValue()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.iChronology</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.isLeap(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.roundFloor(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.GJYearDateTimeField(org.joda.time.chrono.AbstractGJChronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.addWrapped(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.get(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.getDifferenceAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.getLeapAmount(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.getLeapDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.getMaximumValue()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.getMinimumValue()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.iChronology</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.isLeap(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.roundCeiling(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.roundFloor(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.GJYearOfEraDateTimeField(org.joda.time.DateTimeField, org.joda.time.chrono.AbstractGJChronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.iChronology</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.set(long, int)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.GregorianChronology</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.JulianChronology</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoWeekyearZeroField.JulianChronology$NoWeekyearZeroField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoWeekyearZeroField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoYearZeroField.JulianChronology$NoYearZeroField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoYearZeroField.iChronology</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoYearZeroField.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.AbstractGJChronology(org.joda.time.Chronology, java.lang.Object, int)</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <outbound type="feature" confirmed="no">java.lang.Class.getName()</outbound>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Integer</outbound>
                <outbound type="feature" confirmed="no">java.lang.Integer.getInteger(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Integer.intValue()</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.getClass()</outbound>
                <outbound type="class" confirmed="no">java.lang.SecurityException</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.concat(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$YearInfo</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.iMinDaysInFirstWeek</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.iYearInfoCache</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.iYearInfoCacheMask</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.AssembledChronology(org.joda.time.Chronology, java.lang.Object)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.CopticChronology(org.joda.time.Chronology, java.lang.Object, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.GregorianChronology(org.joda.time.Chronology, java.lang.Object, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.JulianChronology(org.joda.time.Chronology, java.lang.Object, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.MAX_DAYS_PER_MONTH_ARRAY</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateOnlyMillis(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDaysInYearMonth(int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.MAX_TOTAL_MILLIS_BY_MONTH_ARRAY</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateOnlyMillis(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getTotalMillisByYearMonth(int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.MILLIS_1970_TO_2000</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.MIN_DAYS_PER_MONTH_ARRAY</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateOnlyMillis(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDaysInYearMonth(int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.MIN_TOTAL_MILLIS_BY_MONTH_ARRAY</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateOnlyMillis(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getTotalMillisByYearMonth(int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.access$000()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cHalfdaysField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$HalfdayField.AbstractGJChronology$HalfdayField()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.access$100()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cDaysField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$HalfdayField.AbstractGJChronology$HalfdayField()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDurationField()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cClockhourOfDayField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cClockhourOfHalfdayField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cDaysField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cHalfdayOfDayField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cHourOfDayField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cHourOfHalfdayField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cHoursField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cMillisField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cMillisOfDayField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cMillisOfSecondField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cMinuteOfDayField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cMinuteOfHourField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cMinutesField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cSecondOfDayField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cSecondOfMinuteField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cSecondsField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cWeeksField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.centuries</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.centuryOfEra</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.clockhourOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.clockhourOfHalfday</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.dayOfMonth</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.dayOfWeek</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.dayOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.days</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.era</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.halfdayOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.hourOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.hourOfHalfday</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.hours</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.millis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.millisOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.millisOfSecond</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.minuteOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.minuteOfHour</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.minutes</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.monthOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.months</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.secondOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.secondOfMinute</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.seconds</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weekOfWeekyear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weeks</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weekyear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weekyears</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.year</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.yearOfCentury</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.yearOfEra</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.years</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfMonthDateTimeField.GJDayOfMonthDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.GJDayOfWeekDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfYearDateTimeField.GJDayOfYearDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.GJEraDateTimeField(org.joda.time.chrono.AbstractGJChronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.GJMonthOfYearDateTimeField(org.joda.time.chrono.AbstractGJChronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.GJWeekOfWeekyearDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.GJWeekyearDateTimeField(org.joda.time.chrono.AbstractGJChronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.GJYearDateTimeField(org.joda.time.chrono.AbstractGJChronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.GJYearOfEraDateTimeField(org.joda.time.DateTimeField, org.joda.time.chrono.AbstractGJChronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.DividedDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.DateTimeField, java.lang.String, java.lang.String, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(org.joda.time.DateTimeField, java.lang.String, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(org.joda.time.field.DividedDateTimeField, java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.cClockhourOfDayField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.cClockhourOfHalfdayField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.cDaysField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.access$100()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.cHalfdayOfDayField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.cHalfdaysField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.access$000()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.cHourOfDayField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.cHourOfHalfdayField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.cHoursField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.cMillisField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.cMillisOfDayField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.cMillisOfSecondField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.cMinuteOfDayField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.cMinuteOfHourField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.cMinutesField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.cSecondOfDayField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.cSecondOfMinuteField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.cSecondsField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.cWeeksField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.calculateFirstDayOfYearMillis(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearInfo(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getApproxMillisAtEpoch()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYear(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getAverageMillisPerMonth()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.GJMonthOfYearDateTimeField(org.joda.time.chrono.AbstractGJChronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getAverageMillisPerYear()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYear(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.CopticYearDateTimeField(org.joda.time.chrono.AbstractGJChronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.GJWeekyearDateTimeField(org.joda.time.chrono.AbstractGJChronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.GJYearDateTimeField(org.joda.time.chrono.AbstractGJChronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getDateOnlyMillis(int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateOnlyMillis(int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.MAX_DAYS_PER_MONTH_ARRAY</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.MAX_TOTAL_MILLIS_BY_MONTH_ARRAY</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.MIN_DAYS_PER_MONTH_ARRAY</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.MIN_TOTAL_MILLIS_BY_MONTH_ARRAY</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMaxYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMinYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearMillis(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.isLeapYear(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(java.lang.String, int, int, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateTimeMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getDateOnlyMillis(int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getDateTimeMillis(int, int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeMillis(int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateOnlyMillis(int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(java.lang.String, int, int, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeMillis(int, int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getDateTimeMillis(int, int, int, int, int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeMillis(int, int, int, int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateOnlyMillis(int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getTimeOnlyMillis(int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getDateTimeMillis(long, int, int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeMillis(long, int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getTimeOnlyMillis(int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateOnlyMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getDateTimeZone()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeZone()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getDayOfMonth(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDayOfMonth(long, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMonthOfYear(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYear(long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfMonthDateTimeField.get(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getDayOfMonth(long, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDayOfMonth(long, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMonthOfYear(long, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getDayOfMonth(long, int, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getTotalMillisByYearMonth(int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearMillis(int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDayOfMonth(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDayOfMonth(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getDifferenceAsLong(long, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getDayOfWeek(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getFirstWeekOfYearMillis(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getDayOfYear(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDayOfYear(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYear(long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticDayOfMonthDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticDayOfMonthDateTimeField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfYearDateTimeField.get(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getDayOfYear(long, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearMillis(int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDayOfYear(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.setYear(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getDaysInYear(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.isLeapYear(int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfYearDateTimeField.getMaximumValue(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getDaysInYearMonth(int, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.MAX_DAYS_PER_MONTH_ARRAY</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.MIN_DAYS_PER_MONTH_ARRAY</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.isLeapYear(int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfMonthDateTimeField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getFirstWeekOfYearMillis(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDayOfWeek(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearMillis(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.iMinDaysInFirstWeek</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getWeekOfWeekyear(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getWeeksInYear(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getMaxYear()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateOnlyMillis(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearOverflow(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.getMaximumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.getMaximumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.getMaximumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getMillisOfDay(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.setYear(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getMinYear()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateOnlyMillis(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearOverflow(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.getMinimumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.getMinimumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.getMinimumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getMinimumDaysInFirstWeek()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.iMinDaysInFirstWeek</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getMinimumDaysInFirstWeek()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getMonthOfYear(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMonthOfYear(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYear(long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.get(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getMonthOfYear(long, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearMillis(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.isLeapYear(int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDayOfMonth(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDayOfMonth(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMonthOfYear(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfMonthDateTimeField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.roundFloor(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getTimeOnlyMillis(int, int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getTimeOnlyMillis(int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(java.lang.String, int, int, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getTotalMillisByYearMonth(int, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.MAX_TOTAL_MILLIS_BY_MONTH_ARRAY</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.MIN_TOTAL_MILLIS_BY_MONTH_ARRAY</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.isLeapYear(int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDayOfMonth(long, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearMonthDayMillis(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearMonthMillis(int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getWeekOfWeekyear(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getWeekOfWeekyear(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYear(long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getWeekOfWeekyear(long, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getFirstWeekOfYearMillis(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getWeeksInYear(int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getWeekOfWeekyear(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getWeekyear(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getWeeksInYear(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getFirstWeekOfYearMillis(int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getWeekOfWeekyear(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.getLeapAmount(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getWeekyear(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getWeekOfWeekyear(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYear(long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.getLeapAmount(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.isLeap(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getYear(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getApproxMillisAtEpoch()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getAverageMillisPerYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearMillis(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearOverflow(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.isLeapYear(int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDayOfMonth(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDayOfYear(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMonthOfYear(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getWeekOfWeekyear(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getWeekyear(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.setYear(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticDayOfMonthDateTimeField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfMonthDateTimeField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfYearDateTimeField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getYearInfo(int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$YearInfo</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$YearInfo.AbstractGJChronology$YearInfo(int, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$YearInfo.iYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.calculateFirstDayOfYearMillis(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.iYearInfoCache</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.iYearInfoCacheMask</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearMillis(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getYearMillis(int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$YearInfo</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$YearInfo.iFirstDayMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearInfo(int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateOnlyMillis(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDayOfMonth(long, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDayOfYear(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getFirstWeekOfYearMillis(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMonthOfYear(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYear(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearMonthDayMillis(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearMonthMillis(int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearOverflow(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getDateOnlyMillis(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.roundFloor(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getYearMonthDayMillis(int, int, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getTotalMillisByYearMonth(int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearMillis(int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.setYear(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getYearMonthMillis(int, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getTotalMillisByYearMonth(int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearMillis(int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.roundFloor(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.getYearOverflow(long)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(long)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMaxYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMinYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearMillis(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.isLeapYear(int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYear(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.iMinDaysInFirstWeek</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.AbstractGJChronology(org.joda.time.Chronology, java.lang.Object, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getFirstWeekOfYearMillis(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMinimumDaysInFirstWeek()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.iYearInfoCache</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$YearInfo</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.AbstractGJChronology(org.joda.time.Chronology, java.lang.Object, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearInfo(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.iYearInfoCacheMask</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.AbstractGJChronology(org.joda.time.Chronology, java.lang.Object, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearInfo(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.isLeapYear(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateOnlyMillis(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDaysInYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDaysInYearMonth(int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMonthOfYear(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getTotalMillisByYearMonth(int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYear(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearOverflow(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.setYear(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticDayOfMonthDateTimeField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.getLeapAmount(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.getLeapAmount(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.isLeap(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.setYear(long, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDayOfYear(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMillisOfDay(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearMonthDayMillis(int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.isLeapYear(int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.static {}</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$HalfdayField.AbstractGJChronology$HalfdayField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.MAX_DAYS_PER_MONTH_ARRAY</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.MAX_TOTAL_MILLIS_BY_MONTH_ARRAY</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.MIN_DAYS_PER_MONTH_ARRAY</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.MIN_TOTAL_MILLIS_BY_MONTH_ARRAY</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cClockhourOfDayField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cClockhourOfHalfdayField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cDaysField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cHalfdayOfDayField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cHalfdaysField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cHourOfDayField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cHourOfHalfdayField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cHoursField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cMillisField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cMillisOfDayField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cMillisOfSecondField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cMinuteOfDayField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cMinuteOfHourField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cMinutesField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cSecondOfDayField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cSecondOfMinuteField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cSecondsField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.cWeeksField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.MillisDurationField.INSTANCE</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.NonZeroDateTimeField(org.joda.time.DateTimeField, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.PreciseDateTimeField(java.lang.String, org.joda.time.DurationField, org.joda.time.DurationField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationField.PreciseDurationField(java.lang.String, long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology.toString()</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <outbound type="feature" confirmed="no">java.lang.Class.getName()</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.getClass()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.lastIndexOf(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.substring(int)</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getID()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateTimeZone()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMinimumDaysInFirstWeek()</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.AbstractGJChronology$HalfdayField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.PreciseDateTimeField</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology$HalfdayField.AbstractGJChronology$HalfdayField()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.access$000()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.access$100()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.PreciseDateTimeField(java.lang.String, org.joda.time.DurationField, org.joda.time.DurationField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology$HalfdayField.getAsText(long, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.forLocale(java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.halfdayValueToText(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology$HalfdayField.getMaximumTextLength(java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.forLocale(java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.getHalfdayMaxTextLength()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology$HalfdayField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology$HalfdayField.set(long, java.lang.String, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.forLocale(java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.halfdayTextToValue(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.set(long, int)</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.AbstractGJChronology$YearInfo</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.AbstractGJChronology(org.joda.time.Chronology, java.lang.Object, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearInfo(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearMillis(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.iYearInfoCache</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology$YearInfo.AbstractGJChronology$YearInfo(int, long)</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$YearInfo.iFirstDayMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$YearInfo.iYear</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearInfo(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology$YearInfo.iFirstDayMillis</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$YearInfo.AbstractGJChronology$YearInfo(int, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearMillis(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AbstractGJChronology$YearInfo.iYear</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$YearInfo.AbstractGJChronology$YearInfo(int, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearInfo(int)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.AssembledChronology</name>
            <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractChronology</outbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.BuddhistChronology</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.GJChronology</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.LenientChronology</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.StrictChronology</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.ZonedChronology</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.AssembledChronology(org.joda.time.Chronology, java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.AbstractChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iBase</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iParam</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.AbstractGJChronology(org.joda.time.Chronology, java.lang.Object, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.BuddhistChronology(org.joda.time.Chronology, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.GJChronology(org.joda.time.Chronology, org.joda.time.chrono.JulianChronology, org.joda.time.chrono.GregorianChronology, org.joda.time.Instant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.GJChronology(org.joda.time.chrono.JulianChronology, org.joda.time.chrono.GregorianChronology, org.joda.time.Instant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.ISOChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.LenientChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.LimitChronology(org.joda.time.Chronology, org.joda.time.DateTime, org.joda.time.DateTime)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.StrictChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.ZonedChronology(org.joda.time.Chronology, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.centuries()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iCenturies</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.centuryOfEra()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iCenturyOfEra</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.clockhourOfDay()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iClockhourOfDay</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.clockhourOfHalfday()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iClockhourOfHalfday</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.dayOfMonth()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iDayOfMonth</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticDayOfMonthDateTimeField.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfMonthDateTimeField.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getDifferenceAsLong(long, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.dayOfWeek()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iDayOfWeek</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDayOfWeek(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.dayOfYear()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iDayOfYear</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfYearDateTimeField.readResolve()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.days()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iDays</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.getLeapDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.getLeapDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getLeapDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.getLeapDurationField()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.era()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iEra</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.readResolve()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.eras()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iEras</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.getBase()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iBase</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateOnlyMillis(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateTimeMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateTimeZone()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getDateOnlyMillis(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateOnlyMillis(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeZone()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.withUTC()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.getMessage()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getDateOnlyMillis(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getDateOnlyMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getDateTimeMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getTimeOnlyMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.withUTC()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getDateOnlyMillis(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getDateTimeMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.withUTC()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.getDateOnlyMillis(int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateOnlyMillis(int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateOnlyMillis(int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iBase</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iBaseFlags</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.DateOnly(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.MutableDateOnly(int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.getDateOnlyMillis(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateOnlyMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateOnlyMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iBase</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.getDateTimeMillis(int, int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeMillis(int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateTimeMillis(int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iBase</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iBaseFlags</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.getDateTimeMillis(int, int, int, int, int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeMillis(int, int, int, int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateTimeMillis(int, int, int, int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iBase</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iBaseFlags</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.getDateTimeMillis(long, int, int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeMillis(long, int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getDateTimeMillis(long, int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iBase</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iBaseFlags</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.getDateTimeZone()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeZone()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iBase</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.writeReplace()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.withUTC()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.withUTC()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.getParam()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iParam</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getDateTimeZone()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.getTimeOnlyMillis(int, int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getTimeOnlyMillis(int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getTimeOnlyMillis(int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iBase</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iBaseFlags</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.MutableTimeOnly(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.TimeOnly(int, int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.getTimeOnlyMillis(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getTimeOnlyMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.getTimeOnlyMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iBase</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.halfdayOfDay()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iHalfdayOfDay</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.hourOfDay()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iHourOfDay</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.hourOfHalfday()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iHourOfHalfday</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.hours()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iHours</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iBase</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.AssembledChronology(org.joda.time.Chronology, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateOnlyMillis(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateOnlyMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeZone()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getTimeOnlyMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iBaseFlags</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateOnlyMillis(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iCenturies</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.centuries()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iCenturyOfEra</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.centuryOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iClockhourOfDay</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.clockhourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iClockhourOfHalfday</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.clockhourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iDayOfMonth</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.dayOfMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iDayOfWeek</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.dayOfWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iDayOfYear</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.dayOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iDays</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.days()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iEra</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.era()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iEras</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.eras()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iHalfdayOfDay</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.halfdayOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iHourOfDay</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.hourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iHourOfHalfday</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.hourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iHours</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.hours()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iMillis</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.millis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iMillisOfDay</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.millisOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iMillisOfSecond</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.millisOfSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iMinuteOfDay</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.minuteOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iMinuteOfHour</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.minuteOfHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iMinutes</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.minutes()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iMonthOfYear</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.monthOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iMonths</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.months()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iParam</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.AssembledChronology(org.joda.time.Chronology, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getParam()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iSecondOfDay</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.secondOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iSecondOfMinute</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.secondOfMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iSeconds</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.seconds()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iWeekOfWeekyear</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.weekOfWeekyear()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iWeeks</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.weeks()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iWeekyear</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.weekyear()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iWeekyears</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.weekyears()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iYear</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.year()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iYearOfCentury</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.yearOfCentury()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iYearOfEra</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.yearOfEra()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.iYears</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.years()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.millis()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iMillis</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.millisOfDay()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iMillisOfDay</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.millisOfSecond()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iMillisOfSecond</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.minuteOfDay()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iMinuteOfDay</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.minuteOfHour()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iMinuteOfHour</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.minutes()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iMinutes</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.monthOfYear()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iMonthOfYear</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseMonth(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.months()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iMonths</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticDayOfMonthDateTimeField.getRangeDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfMonthDateTimeField.getRangeDurationField()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.readObject(java.io.ObjectInputStream)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.ObjectInputStream</outbound>
                <outbound type="feature" confirmed="no">java.io.ObjectInputStream.defaultReadObject()</outbound>
                <outbound type="class" confirmed="no">java.lang.ClassNotFoundException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.secondOfDay()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iSecondOfDay</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.secondOfMinute()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iSecondOfMinute</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.seconds()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iSeconds</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.setFields()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfMonth()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.hourOfDay()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millisOfDay()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millisOfSecond()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.minuteOfHour()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.monthOfYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.secondOfMinute()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.year()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.centuries()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.centuryOfEra()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.clockhourOfDay()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.clockhourOfHalfday()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.dayOfMonth()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.dayOfWeek()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.dayOfYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.days()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.era()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.eras()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.halfdayOfDay()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.hourOfDay()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.hourOfHalfday()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.hours()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.millis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.millisOfDay()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.millisOfSecond()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.minuteOfDay()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.minuteOfHour()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.minutes()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.monthOfYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.months()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.secondOfDay()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.secondOfMinute()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.seconds()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.weekOfWeekyear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.weeks()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.weekyear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.weekyears()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.year()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.yearOfCentury()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.yearOfEra()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.years()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.AssembledChronology$Fields()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.centuries</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.centuryOfEra</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.clockhourOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.clockhourOfHalfday</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.dayOfMonth</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.dayOfWeek</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.dayOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.days</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.era</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.eras</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.halfdayOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.hourOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.hourOfHalfday</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.hours</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.millis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.millisOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.millisOfSecond</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.minuteOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.minuteOfHour</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.minutes</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.monthOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.months</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.secondOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.secondOfMinute</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.seconds</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weekOfWeekyear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weeks</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weekyear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weekyears</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.year</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.yearOfCentury</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.yearOfEra</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.years</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iBase</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iBaseFlags</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iCenturies</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iCenturyOfEra</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iClockhourOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iClockhourOfHalfday</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iDayOfMonth</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iDayOfWeek</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iDayOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iDays</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iEra</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iEras</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iHalfdayOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iHourOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iHourOfHalfday</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iHours</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iMillisOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iMillisOfSecond</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iMinuteOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iMinuteOfHour</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iMinutes</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iMonthOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iMonths</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iSecondOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iSecondOfMinute</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iSeconds</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iWeekOfWeekyear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iWeeks</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iWeekyear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iWeekyears</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iYearOfCentury</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iYearOfEra</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iYears</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.AssembledChronology(org.joda.time.Chronology, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.readObject(java.io.ObjectInputStream)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.weekOfWeekyear()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iWeekOfWeekyear</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.roundFloor(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.weeks()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iWeeks</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.getRangeDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.getLeapDurationField()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.weekyear()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iWeekyear</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoWeekyearZeroField.readResolve()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.weekyears()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iWeekyears</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.getRangeDurationField()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.year()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iYear</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.ISOYearOfEraDateTimeField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoYearZeroField.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.yearOfCentury()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iYearOfCentury</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.yearOfEra()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iYearOfEra</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.readResolve()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology.years()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.iYears</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.getRangeDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfYearDateTimeField.getRangeDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getRangeDurationField()</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.AssembledChronology$Fields</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.AssembledChronology$Fields()</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.centuries</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.centuryOfEra</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.clockhourOfDay</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.clockhourOfHalfday</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.centuries()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.centuryOfEra()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.clockhourOfDay()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.clockhourOfHalfday()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfMonth()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfWeek()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.days()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.era()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.eras()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.halfdayOfDay()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.hourOfDay()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.hourOfHalfday()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.hours()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millisOfDay()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millisOfSecond()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.minuteOfDay()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.minuteOfHour()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.minutes()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.monthOfYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.months()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.secondOfDay()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.secondOfMinute()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.seconds()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weekOfWeekyear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weeks()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weekyear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weekyears()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.year()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.yearOfCentury()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.yearOfEra()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.years()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.centuries</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.centuryOfEra</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.clockhourOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.clockhourOfHalfday</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.dayOfMonth</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.dayOfWeek</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.dayOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.days</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.era</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.eras</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.halfdayOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.hourOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.hourOfHalfday</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.hours</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.isSupported(org.joda.time.DateTimeField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.isSupported(org.joda.time.DurationField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.millis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.millisOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.millisOfSecond</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.minuteOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.minuteOfHour</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.minutes</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.monthOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.months</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.secondOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.secondOfMinute</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.seconds</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weekOfWeekyear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weeks</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weekyear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weekyears</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.year</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.yearOfCentury</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.yearOfEra</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.years</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.dayOfMonth</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.dayOfWeek</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.dayOfYear</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.days</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.era</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.eras</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.halfdayOfDay</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.hourOfDay</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.hourOfHalfday</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.hours</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.isSupported(org.joda.time.DateTimeField)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.isSupported()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.isSupported(org.joda.time.DurationField)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isSupported()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.millis</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.millisOfDay</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.millisOfSecond</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.minuteOfDay</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.minuteOfHour</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.minutes</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.monthOfYear</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.months</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.secondOfDay</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.secondOfMinute</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.seconds</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.weekOfWeekyear</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.weeks</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.weekyear</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.weekyears</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.year</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.yearOfCentury</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.yearOfEra</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.AssembledChronology$Fields.years</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.setFields()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.BuddhistChronology</name>
            <outbound type="class" confirmed="yes">org.joda.time.chrono.AssembledChronology</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistChronology.BE</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistChronology.BUDDHIST_OFFSET</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistChronology.BuddhistChronology(org.joda.time.Chronology, java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.AssembledChronology(org.joda.time.Chronology, java.lang.Object)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistChronology.INSTANCE_UTC</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.getInstanceUTC()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.withUTC()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getName()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.centuryOfEra</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.era</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weekyear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.year</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.yearOfCentury</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.yearOfEra</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getParam()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.INSTANCE</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.DividedDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.DateTimeField, java.lang.String, java.lang.String, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(org.joda.time.DateTimeField, java.lang.String, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(org.joda.time.field.DividedDateTimeField, java.lang.String)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistChronology.cCache</name>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistChronology.getInstance()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistChronology.getInstance(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.get(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.put(java.lang.Object, java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(int, int, int, int, int, int, int, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDateTime</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.BuddhistChronology(org.joda.time.Chronology, java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.cCache</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getInstance(org.joda.time.Chronology, org.joda.time.ReadableDateTime, org.joda.time.ReadableDateTime)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.getInstance()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistChronology.getInstanceUTC()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.INSTANCE_UTC</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistChronology.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeZone()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistChronology.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistChronology.static {}</name>
                <outbound type="feature" confirmed="no">java.util.HashMap.HashMap()</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.INSTANCE_UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.cCache</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistChronology.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getID()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeZone()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistChronology.withDateTimeZone(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeZone()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistChronology.withUTC()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.INSTANCE_UTC</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.BuddhistEraDateTimeField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.AbstractDateTimeField</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistEraDateTimeField.BuddhistEraDateTimeField()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.AbstractDateTimeField(java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistEraDateTimeField.INSTANCE</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistEraDateTimeField.get(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistEraDateTimeField.getAsShortText(long, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistEraDateTimeField.getAsText(long, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistEraDateTimeField.getDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.INSTANCE</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistEraDateTimeField.getMaximumShortTextLength(java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistEraDateTimeField.getMaximumTextLength(java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistEraDateTimeField.getMaximumValue()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistEraDateTimeField.getMinimumValue()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistEraDateTimeField.getRangeDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistEraDateTimeField.isLenient()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistEraDateTimeField.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.INSTANCE</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistEraDateTimeField.roundCeiling(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistEraDateTimeField.roundFloor(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistEraDateTimeField.roundHalfCeiling(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistEraDateTimeField.roundHalfEven(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistEraDateTimeField.roundHalfFloor(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistEraDateTimeField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistEraDateTimeField.set(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.getMaximumValue()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.getMinimumValue()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeField, int, int, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistEraDateTimeField.set(long, java.lang.String, java.util.Locale)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.equals(java.lang.Object)</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.BuddhistEraDateTimeField.static {}</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.BuddhistEraDateTimeField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.INSTANCE</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.CopticChronology</name>
            <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticChronology.AM</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticChronology.CopticChronology(org.joda.time.Chronology, java.lang.Object, int)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.AbstractGJChronology(org.joda.time.Chronology, java.lang.Object, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticChronology.INSTANCE_UTC</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstanceUTC()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.withUTC()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticChronology.MILLIS_PER_MONTH</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticChronology.MILLIS_PER_YEAR</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDurationField()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.dayOfMonth</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.days</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.era</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.monthOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.months</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weekyear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.year</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.years</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.cMonthsField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticDayOfMonthDateTimeField.CopticDayOfMonthDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.INSTANCE</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.CopticMonthOfYearDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.CopticYearDateTimeField(org.joda.time.chrono.AbstractGJChronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoWeekyearZeroField.JulianChronology$NoWeekyearZeroField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DateTimeField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoYearZeroField.JulianChronology$NoYearZeroField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticChronology.cCache</name>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticChronology.cMonthsField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticChronology.calculateFirstDayOfYearMillis(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.isLeapYear(int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticChronology.getApproxMillisAtEpoch()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticChronology.getAverageMillisPerMonth()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticChronology.getAverageMillisPerYear()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticChronology.getDateOnlyMillis(int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateOnlyMillis(int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearMillis(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getMaxYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getMinYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.isLeapYear(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(java.lang.String, int, int, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticChronology.getInstance()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone, int)</name>
                <outbound type="class" confirmed="no">java.lang.ArrayIndexOutOfBoundsException</outbound>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.get(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.put(java.lang.Object, java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(int, int, int, int, int, int, int, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.CopticChronology(org.joda.time.Chronology, java.lang.Object, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.cCache</outbound>
                <outbound type="class" confirmed="no">org.joda.time.chrono.CopticChronology[]</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getInstance(org.joda.time.Chronology, org.joda.time.ReadableDateTime, org.joda.time.ReadableDateTime)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ZonedChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getInstance(org.joda.time.Chronology, org.joda.time.DateTimeZone)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticChronology.getInstanceUTC()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.INSTANCE_UTC</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticChronology.getMaxYear()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getDateOnlyMillis(int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticChronology.getMinYear()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getDateOnlyMillis(int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticChronology.isLeapYear(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.calculateFirstDayOfYearMillis(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getDateOnlyMillis(int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticChronology.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeZone()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticChronology.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticChronology.static {}</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.util.HashMap.HashMap()</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.INSTANCE_UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.cCache</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.cMonthsField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationField.PreciseDurationField(java.lang.String, long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticChronology.withDateTimeZone(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateTimeZone()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticChronology.withUTC()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.INSTANCE_UTC</outbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>org.joda.time.chrono.CopticChronology[]</name>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.CopticDayOfMonthDateTimeField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticDayOfMonthDateTimeField.CopticDayOfMonthDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticDayOfMonthDateTimeField.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.PreciseDurationDateTimeField(java.lang.String, org.joda.time.DurationField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticDayOfMonthDateTimeField.get(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDayOfYear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticDayOfMonthDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticDayOfMonthDateTimeField.getMaximumValue()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticDayOfMonthDateTimeField.getMaximumValue(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDayOfYear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.isLeapYear(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticDayOfMonthDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticDayOfMonthDateTimeField.getMinimumValue()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticDayOfMonthDateTimeField.getRangeDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.months()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticDayOfMonthDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticDayOfMonthDateTimeField.iChronology</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticDayOfMonthDateTimeField.CopticDayOfMonthDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticDayOfMonthDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticDayOfMonthDateTimeField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticDayOfMonthDateTimeField.getRangeDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticDayOfMonthDateTimeField.readResolve()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticDayOfMonthDateTimeField.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.dayOfMonth()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticDayOfMonthDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticDayOfMonthDateTimeField.serialVersionUID</name>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.CopticEraDateTimeField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.AbstractDateTimeField</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticEraDateTimeField.CopticEraDateTimeField()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.AbstractDateTimeField(java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticEraDateTimeField.INSTANCE</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticEraDateTimeField.get(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticEraDateTimeField.getAsShortText(long, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticEraDateTimeField.getAsText(long, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticEraDateTimeField.getDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.INSTANCE</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticEraDateTimeField.getMaximumShortTextLength(java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticEraDateTimeField.getMaximumTextLength(java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticEraDateTimeField.getMaximumValue()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticEraDateTimeField.getMinimumValue()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticEraDateTimeField.getRangeDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticEraDateTimeField.isLenient()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticEraDateTimeField.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.INSTANCE</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticEraDateTimeField.roundCeiling(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticEraDateTimeField.roundFloor(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticEraDateTimeField.roundHalfCeiling(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticEraDateTimeField.roundHalfEven(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticEraDateTimeField.roundHalfFloor(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticEraDateTimeField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticEraDateTimeField.set(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.getMaximumValue()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.getMinimumValue()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeField, int, int, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticEraDateTimeField.set(long, java.lang.String, java.util.Locale)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.equals(java.lang.Object)</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticEraDateTimeField.static {}</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.CopticEraDateTimeField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.INSTANCE</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.CopticMonthOfYearDateTimeField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticMonthOfYearDateTimeField.CopticMonthOfYearDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.PreciseDurationDateTimeField(java.lang.String, org.joda.time.DurationField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticMonthOfYearDateTimeField.get(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDayOfYear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.iChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.isLeap(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticMonthOfYearDateTimeField.getLeapAmount(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.isLeap(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticMonthOfYearDateTimeField.getLeapDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.days()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticMonthOfYearDateTimeField.getMaximumValue()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticMonthOfYearDateTimeField.getMinimumValue()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticMonthOfYearDateTimeField.getRangeDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.years()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticMonthOfYearDateTimeField.iChronology</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.CopticMonthOfYearDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.getLeapDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.getRangeDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticMonthOfYearDateTimeField.isLeap(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.isLeapYear(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.iChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.getLeapAmount(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticMonthOfYearDateTimeField.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.monthOfYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticMonthOfYearDateTimeField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticMonthOfYearDateTimeField.set(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDayOfYear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.set(long, int)</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.CopticYearDateTimeField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticYearDateTimeField.CopticYearDateTimeField(org.joda.time.chrono.AbstractGJChronology)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getAverageMillisPerYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.ImpreciseDateTimeField(java.lang.String, java.lang.String, long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticYearDateTimeField.add(long, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.set(long, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.add(long, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticYearDateTimeField.add(long, long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.safeToInt(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticYearDateTimeField.addWrapped(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMaxYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMinYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.getWrappedValue(int, int, int, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticYearDateTimeField.get(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.iChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.getLeapAmount(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.roundFloor(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticYearDateTimeField.getDifferenceAsLong(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearMillis(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.getDifference(long, long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticYearDateTimeField.getLeapAmount(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.isLeapYear(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticYearDateTimeField.getLeapDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.days()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticYearDateTimeField.getMaximumValue()</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMaxYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticYearDateTimeField.getMinimumValue()</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMinYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticYearDateTimeField.getRangeDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticYearDateTimeField.iChronology</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.CopticYearDateTimeField(org.joda.time.chrono.AbstractGJChronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.getLeapAmount(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.getLeapDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.getMaximumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.getMinimumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticYearDateTimeField.isLeap(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.isLeapYear(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticYearDateTimeField.isLenient()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticYearDateTimeField.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.year()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticYearDateTimeField.remainder(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.roundFloor(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticYearDateTimeField.roundCeiling(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearMillis(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticYearDateTimeField.roundFloor(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearMillis(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.iChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.remainder(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticYearDateTimeField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.CopticYearDateTimeField.set(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDayOfYear(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMaxYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMillisOfDay(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMinYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearMonthDayMillis(int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.isLeapYear(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeField, int, int, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.addWrapped(long, int)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.GJChronology</name>
            <outbound type="class" confirmed="yes">org.joda.time.chrono.AssembledChronology</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, long, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.gregorianToJulian(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.julianToGregorian(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.roundCeiling(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.roundFloor(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.this$0</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.GJChronology$ImpreciseCutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.GJChronology$ImpreciseCutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.GJChronology$ImpreciseCutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.GJChronology$ImpreciseCutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, org.joda.time.DurationField, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.add(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.add(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.this$0</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.DEFAULT_CUTOVER</name>
                <outbound type="class" confirmed="yes">org.joda.time.Instant</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstanceUTC()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.GJChronology(org.joda.time.Chronology, org.joda.time.chrono.JulianChronology, org.joda.time.chrono.GregorianChronology, org.joda.time.Instant)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Instant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.AssembledChronology(org.joda.time.Chronology, java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GregorianChronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.JulianChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.GJChronology(org.joda.time.chrono.JulianChronology, org.joda.time.chrono.GregorianChronology, org.joda.time.Instant)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Instant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.AssembledChronology(org.joda.time.Chronology, java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GregorianChronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.JulianChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException()</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.Object[]</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDurationField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundCeiling(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Instant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Instant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMinimumDaysInFirstWeek()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.centuries</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.centuryOfEra</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.clockhourOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.clockhourOfHalfday</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.dayOfMonth</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.dayOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.era</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.halfdayOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.hourOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.hourOfHalfday</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.millisOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.millisOfSecond</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.minuteOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.minuteOfHour</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.monthOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.months</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.secondOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.secondOfMinute</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weekOfWeekyear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weekyear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weekyears</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.year</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.yearOfCentury</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.yearOfEra</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.years</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.centuryOfEra()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.clockhourOfDay()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.clockhourOfHalfday()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.dayOfMonth()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.dayOfYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.era()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getParam()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.halfdayOfDay()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.hourOfDay()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.hourOfHalfday()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.millisOfDay()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.millisOfSecond()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.minuteOfDay()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.minuteOfHour()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.monthOfYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.secondOfDay()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.secondOfMinute()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.weekOfWeekyear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.weekyear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.year()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.yearOfCentury()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.yearOfEra()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, long, boolean)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.GJChronology$ImpreciseCutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.GJChronology$ImpreciseCutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, boolean)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.GJChronology$ImpreciseCutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, org.joda.time.DurationField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iCutoverInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iCutoverMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iGapDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iGregorianChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iJulianChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.julianToGregorianByYear(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GregorianChronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.JulianChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.cCache</name>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.convertByWeekyear(long, org.joda.time.Chronology, org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfWeek()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millisOfDay()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weekOfWeekyear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weekyear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.gregorianToJulianByWeekyear(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.julianToGregorianByWeekyear(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.convertByYear(long, org.joda.time.Chronology, org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfMonth()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeMillis(int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millisOfDay()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.monthOfYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.year()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.gregorianToJulianByYear(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.julianToGregorianByYear(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.getDateOnlyMillis(int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateOnlyMillis(int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeMillis(int, int, int, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.getDateTimeMillis(int, int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeMillis(int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateTimeMillis(int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iCutoverMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iGregorianChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iJulianChronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GregorianChronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.JulianChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateOnlyMillis(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.getDateTimeMillis(int, int, int, int, int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeMillis(int, int, int, int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeMillis(int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getTimeOnlyMillis(int, int, int, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.getDateTimeMillis(long, int, int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeMillis(long, int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateOnlyMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getTimeOnlyMillis(int, int, int, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.getDateTimeZone()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeZone()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.getGregorianCutover()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Instant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iCutoverInstant</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.getInstance()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Instant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.DEFAULT_CUTOVER</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Instant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.DEFAULT_CUTOVER</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Instant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Instant.Instant(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Instant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.DEFAULT_CUTOVER</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.util.ArrayList</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.ArrayList(int)</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.add(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.get(int)</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.size()</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.get(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.put(java.lang.Object, java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.equals(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Instant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.toInstant()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.DEFAULT_CUTOVER</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.GJChronology(org.joda.time.Chronology, org.joda.time.chrono.JulianChronology, org.joda.time.chrono.GregorianChronology, org.joda.time.Instant)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.GJChronology(org.joda.time.chrono.JulianChronology, org.joda.time.chrono.GregorianChronology, org.joda.time.Instant)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.cCache</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getGregorianCutover()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getMinimumDaysInFirstWeek()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iCutoverInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iGregorianChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iJulianChronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GregorianChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.JulianChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ZonedChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getInstance(org.joda.time.Chronology, org.joda.time.DateTimeZone)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstanceUTC()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.getInstanceUTC()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Instant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.DEFAULT_CUTOVER</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.getMinimumDaysInFirstWeek()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMinimumDaysInFirstWeek()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iGregorianChronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GregorianChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.getTimeOnlyMillis(int, int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getTimeOnlyMillis(int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getTimeOnlyMillis(int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iGregorianChronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GregorianChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.gregorianToJulianByWeekyear(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.convertByWeekyear(long, org.joda.time.Chronology, org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iGregorianChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iJulianChronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GregorianChronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.JulianChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.gregorianToJulian(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.gregorianToJulianByYear(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.convertByYear(long, org.joda.time.Chronology, org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iGregorianChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iJulianChronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GregorianChronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.JulianChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.gregorianToJulian(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.iCutoverInstant</name>
                <outbound type="class" confirmed="yes">org.joda.time.Instant</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getGregorianCutover()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.iCutoverMillis</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.iGapDuration</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.iGregorianChronology</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GregorianChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getMinimumDaysInFirstWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.gregorianToJulianByWeekyear(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.gregorianToJulianByYear(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.julianToGregorianByWeekyear(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.julianToGregorianByYear(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.iJulianChronology</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.JulianChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.gregorianToJulianByWeekyear(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.gregorianToJulianByYear(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.julianToGregorianByWeekyear(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.julianToGregorianByYear(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.julianToGregorianByWeekyear(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.convertByWeekyear(long, org.joda.time.Chronology, org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iGregorianChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iJulianChronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GregorianChronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.JulianChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.julianToGregorian(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.julianToGregorianByYear(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.convertByYear(long, org.joda.time.Chronology, org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iGregorianChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iJulianChronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GregorianChronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.JulianChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.julianToGregorian(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Instant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeZone()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getMinimumDaysInFirstWeek()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iCutoverInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.static {}</name>
                <outbound type="feature" confirmed="no">java.util.HashMap.HashMap()</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Instant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Instant.Instant(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.DEFAULT_CUTOVER</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.cCache</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getTimeOnlyMillis(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getID()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeZone()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getMinimumDaysInFirstWeek()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iCutoverMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.withUTC()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.lang.StringBuffer, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.ISODateTimeFormat</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.date()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTime()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance(org.joda.time.Chronology)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.withDateTimeZone(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Instant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeZone()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getMinimumDaysInFirstWeek()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iCutoverInstant</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.withUTC()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology.withUTC()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.withDateTimeZone(org.joda.time.DateTimeZone)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.toString()</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.GJChronology$CutoverField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.AbstractDateTimeField</outbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, long, boolean)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iCutoverMillis</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, boolean)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, long, boolean)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iCutoverMillis</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.GJChronology$ImpreciseCutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, org.joda.time.DurationField, boolean)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, long, boolean)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, long, boolean)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDurationField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getName()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iConvertByWeekyear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iCutover</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iGregorianField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iJulianField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.AbstractDateTimeField(java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.add(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iGregorianField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.add(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iGregorianField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.get(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iCutover</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iGregorianField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iJulianField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.getAsShortText(long, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getAsShortText(long, java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iCutover</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iGregorianField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iJulianField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.getAsText(long, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getAsText(long, java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iCutover</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iGregorianField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iJulianField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.getDifference(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDifference(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iGregorianField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.getDifferenceAsLong(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDifferenceAsLong(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iGregorianField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.getDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iDurationField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.getLeapAmount(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getLeapAmount(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iCutover</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iGregorianField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iJulianField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.getLeapDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getLeapDurationField()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iGregorianField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.getMaximumShortTextLength(java.util.Locale)</name>
                <outbound type="feature" confirmed="no">java.lang.Math.max(int, int)</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMaximumShortTextLength(java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iGregorianField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iJulianField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.getMaximumTextLength(java.util.Locale)</name>
                <outbound type="feature" confirmed="no">java.lang.Math.max(int, int)</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMaximumTextLength(java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iGregorianField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iJulianField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.getMaximumValue()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMaximumValue()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iGregorianField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.getMaximumValue(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMaximumValue(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iCutover</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iGregorianField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iJulianField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.getMinimumValue()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMinimumValue()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iJulianField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.getMinimumValue(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMinimumValue(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iCutover</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iGregorianField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iJulianField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.getRangeDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getRangeDurationField()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iGregorianField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iJulianField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.gregorianToJulian(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iConvertByWeekyear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.gregorianToJulianByWeekyear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.gregorianToJulianByYear(long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.getDifferenceAsLong(long, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.iConvertByWeekyear</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, long, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.gregorianToJulian(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.julianToGregorian(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.iCutover</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, long, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getAsShortText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getAsText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getLeapAmount(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMinimumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.getMinimumValue(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.iDurationField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, long, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.GJChronology$ImpreciseCutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, org.joda.time.DurationField, boolean)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.iGregorianField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, long, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getAsShortText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getAsText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getLeapAmount(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getLeapDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMaximumShortTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMaximumTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMaximumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMinimumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getRangeDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.getMinimumValue(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.iJulianField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, long, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getAsShortText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getAsText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getLeapAmount(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMaximumShortTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMaximumTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMinimumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getMinimumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.getRangeDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.getMinimumValue(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.isLeap(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.isLeap(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iCutover</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iGregorianField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iJulianField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.isLenient()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.julianToGregorian(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iConvertByWeekyear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.julianToGregorianByWeekyear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.julianToGregorianByYear(long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.getDifferenceAsLong(long, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.roundCeiling(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundCeiling(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iCutover</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iGregorianField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iJulianField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.julianToGregorian(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iGapDuration</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.roundFloor(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundFloor(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.gregorianToJulian(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iCutover</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iGregorianField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iJulianField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iGapDuration</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.set(long, int)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getName()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.gregorianToJulian(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iCutover</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iGregorianField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iJulianField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.julianToGregorian(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iGapDuration</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.set(long, java.lang.String, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, java.lang.String, java.util.Locale)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.gregorianToJulian(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iCutover</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iGregorianField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iJulianField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.julianToGregorian(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iGapDuration</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$CutoverField.this$0</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, long, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.gregorianToJulian(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.julianToGregorian(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.set(long, java.lang.String, java.util.Locale)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.GJChronology$ImpreciseCutoverField</name>
            <outbound type="class" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$LinkedDurationField.GJChronology$LinkedDurationField(org.joda.time.DurationField, org.joda.time.chrono.GJChronology$ImpreciseCutoverField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$LinkedDurationField.add(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$LinkedDurationField.add(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$LinkedDurationField.getDifference(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$LinkedDurationField.getDifferenceAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$LinkedDurationField.iField</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$ImpreciseCutoverField.GJChronology$ImpreciseCutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.GJChronology$ImpreciseCutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, org.joda.time.DurationField, boolean)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$ImpreciseCutoverField.GJChronology$ImpreciseCutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, boolean)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.GJChronology$ImpreciseCutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, org.joda.time.DurationField, boolean)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$ImpreciseCutoverField.GJChronology$ImpreciseCutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, org.joda.time.DurationField)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.GJChronology$ImpreciseCutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, org.joda.time.DurationField, boolean)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$ImpreciseCutoverField.GJChronology$ImpreciseCutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, org.joda.time.DurationField, boolean)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, boolean)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$LinkedDurationField.GJChronology$LinkedDurationField(org.joda.time.DurationField, org.joda.time.chrono.GJChronology$ImpreciseCutoverField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.GJChronology$ImpreciseCutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.GJChronology$ImpreciseCutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.GJChronology$ImpreciseCutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, org.joda.time.DurationField)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$ImpreciseCutoverField.add(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.gregorianToJulian(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iCutover</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iGregorianField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iJulianField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.julianToGregorian(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iGapDuration</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$LinkedDurationField.add(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$ImpreciseCutoverField.add(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.gregorianToJulian(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iCutover</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iGregorianField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iJulianField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.julianToGregorian(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iGapDuration</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$LinkedDurationField.add(long, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$ImpreciseCutoverField.getDifference(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDifference(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.gregorianToJulian(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iCutover</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iGregorianField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iJulianField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.julianToGregorian(long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$LinkedDurationField.getDifference(long, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$ImpreciseCutoverField.getDifferenceAsLong(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDifferenceAsLong(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.gregorianToJulian(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iCutover</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iGregorianField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iJulianField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.julianToGregorian(long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$LinkedDurationField.getDifferenceAsLong(long, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$ImpreciseCutoverField.getMaximumValue(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMaximumValue(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iCutover</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iGregorianField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iJulianField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$ImpreciseCutoverField.getMinimumValue(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMinimumValue(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iCutover</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iGregorianField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.iJulianField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$ImpreciseCutoverField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$ImpreciseCutoverField.this$0</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.GJChronology$ImpreciseCutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, org.joda.time.DurationField, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.add(long, long)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.GJChronology$LinkedDurationField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.DecoratedDurationField</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$LinkedDurationField.GJChronology$LinkedDurationField(org.joda.time.DurationField, org.joda.time.chrono.GJChronology$ImpreciseCutoverField)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getName()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$LinkedDurationField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.DecoratedDurationField(org.joda.time.DurationField, java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.GJChronology$ImpreciseCutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, org.joda.time.DurationField, boolean)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$LinkedDurationField.add(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$LinkedDurationField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$LinkedDurationField.add(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.add(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$LinkedDurationField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$LinkedDurationField.getDifference(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.getDifference(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$LinkedDurationField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$LinkedDurationField.getDifferenceAsLong(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField.getDifferenceAsLong(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$LinkedDurationField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$LinkedDurationField.iField</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJChronology$ImpreciseCutoverField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$LinkedDurationField.GJChronology$LinkedDurationField(org.joda.time.DurationField, org.joda.time.chrono.GJChronology$ImpreciseCutoverField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$LinkedDurationField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$LinkedDurationField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$LinkedDurationField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$LinkedDurationField.getDifferenceAsLong(long, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJChronology$LinkedDurationField.serialVersionUID</name>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.GJDayOfMonthDateTimeField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfMonthDateTimeField.GJDayOfMonthDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfMonthDateTimeField.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.PreciseDurationDateTimeField(java.lang.String, org.joda.time.DurationField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfMonthDateTimeField.get(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDayOfMonth(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfMonthDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfMonthDateTimeField.getMaximumValue()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfMonthDateTimeField.getMaximumValue(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDaysInYearMonth(int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMonthOfYear(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfMonthDateTimeField.iChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfMonthDateTimeField.getMaximumValueForSet(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfMonthDateTimeField.getMaximumValueForSet(long, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfMonthDateTimeField.getMaximumValue(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfMonthDateTimeField.getMinimumValue()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfMonthDateTimeField.getRangeDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.months()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfMonthDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfMonthDateTimeField.iChronology</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfMonthDateTimeField.GJDayOfMonthDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfMonthDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfMonthDateTimeField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfMonthDateTimeField.getRangeDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfMonthDateTimeField.readResolve()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfMonthDateTimeField.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.dayOfMonth()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfMonthDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfMonthDateTimeField.serialVersionUID</name>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.GJDayOfWeekDateTimeField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfWeekDateTimeField.GJDayOfWeekDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.PreciseDurationDateTimeField(java.lang.String, org.joda.time.DurationField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfWeekDateTimeField.get(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDayOfWeek(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.iChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.getAsText(long, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfWeekDateTimeField.getAsShortText(long, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.get(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.dayOfWeekValueToShortText(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.forLocale(java.util.Locale)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfWeekDateTimeField.getAsText(long, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.get(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.dayOfWeekValueToText(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.forLocale(java.util.Locale)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfWeekDateTimeField.getMaximumShortTextLength(java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.forLocale(java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.getDayOfWeekMaxShortTextLength()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfWeekDateTimeField.getMaximumTextLength(java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.forLocale(java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.getDayOfWeekMaxTextLength()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfWeekDateTimeField.getMaximumValue()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfWeekDateTimeField.getMinimumValue()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfWeekDateTimeField.getRangeDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.weeks()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfWeekDateTimeField.iChronology</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.GJDayOfWeekDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.getRangeDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.readResolve()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfWeekDateTimeField.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.dayOfWeek()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfWeekDateTimeField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfWeekDateTimeField.set(long, java.lang.String, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.dayOfWeekTextToValue(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.forLocale(java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.set(long, int)</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.GJDayOfYearDateTimeField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfYearDateTimeField.GJDayOfYearDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfYearDateTimeField.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.PreciseDurationDateTimeField(java.lang.String, org.joda.time.DurationField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfYearDateTimeField.get(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDayOfYear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfYearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfYearDateTimeField.getMaximumValue()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfYearDateTimeField.getMaximumValue(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDaysInYear(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfYearDateTimeField.iChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfYearDateTimeField.getMaximumValueForSet(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfYearDateTimeField.getMaximumValueForSet(long, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfYearDateTimeField.getMaximumValue(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfYearDateTimeField.getMinimumValue()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfYearDateTimeField.getRangeDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.years()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfYearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfYearDateTimeField.iChronology</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfYearDateTimeField.GJDayOfYearDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfYearDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfYearDateTimeField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfYearDateTimeField.getRangeDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfYearDateTimeField.readResolve()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfYearDateTimeField.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.dayOfYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfYearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJDayOfYearDateTimeField.serialVersionUID</name>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.GJEraDateTimeField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.AbstractDateTimeField</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJEraDateTimeField.GJEraDateTimeField(org.joda.time.chrono.AbstractGJChronology)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.AbstractDateTimeField(java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJEraDateTimeField.get(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.iChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.getAsText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJEraDateTimeField.getAsText(long, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.get(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.eraValueToText(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.forLocale(java.util.Locale)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJEraDateTimeField.getDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.INSTANCE</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJEraDateTimeField.getMaximumTextLength(java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.forLocale(java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.getEraMaxTextLength()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJEraDateTimeField.getMaximumValue()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJEraDateTimeField.getMinimumValue()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJEraDateTimeField.getRangeDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJEraDateTimeField.iChronology</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.GJEraDateTimeField(org.joda.time.chrono.AbstractGJChronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJEraDateTimeField.isLenient()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJEraDateTimeField.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.era()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJEraDateTimeField.roundCeiling(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.setYear(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJEraDateTimeField.roundFloor(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.setYear(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.iChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.roundHalfCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.roundHalfEven(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.roundHalfFloor(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJEraDateTimeField.roundHalfCeiling(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.roundFloor(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJEraDateTimeField.roundHalfEven(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.roundFloor(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJEraDateTimeField.roundHalfFloor(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.roundFloor(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJEraDateTimeField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJEraDateTimeField.set(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.setYear(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeField, int, int, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJEraDateTimeField.set(long, java.lang.String, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.set(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.eraTextToValue(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.forLocale(java.util.Locale)</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.GJLocaleSymbols</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$HalfdayField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$HalfdayField.getMaximumTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$HalfdayField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.getMaximumShortTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getMaximumShortTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.FAST_CACHE_SIZE</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols(java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.ref.WeakReference</outbound>
                <outbound type="feature" confirmed="no">java.lang.ref.WeakReference.WeakReference(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.text.DateFormatSymbols.DateFormatSymbols(java.util.Locale)</outbound>
                <outbound type="feature" confirmed="no">java.text.DateFormatSymbols.getAmPmStrings()</outbound>
                <outbound type="feature" confirmed="no">java.text.DateFormatSymbols.getEras()</outbound>
                <outbound type="feature" confirmed="no">java.text.DateFormatSymbols.getMonths()</outbound>
                <outbound type="feature" confirmed="no">java.text.DateFormatSymbols.getShortMonths()</outbound>
                <outbound type="feature" confirmed="no">java.text.DateFormatSymbols.getShortWeekdays()</outbound>
                <outbound type="feature" confirmed="no">java.text.DateFormatSymbols.getWeekdays()</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="no">java.util.Locale.getDefault()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iDaysOfWeek</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iEras</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iHalfday</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iLocale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iMaxDayOfWeekLength</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iMaxEraLength</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iMaxHalfdayLength</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iMaxMonthLength</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iMaxShortDayOfWeekLength</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iMaxShortMonthLength</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iMonths</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iShortDaysOfWeek</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iShortMonths</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.maxLength(java.lang.String[])</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.realignDaysOfWeek(java.lang.String[])</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.realignMonths(java.lang.String[])</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.forLocale(java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.cCache</name>
                <outbound type="class" confirmed="no">java.util.WeakHashMap</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.forLocale(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.cFastCache</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.forLocale(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.dayOfWeekTextToValue(java.lang.String)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.equalsIgnoreCase(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iDaysOfWeek</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iShortDaysOfWeek</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.dayOfWeekValueToShortText(int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iShortDaysOfWeek</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.dayOfWeekValueToText(int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iDaysOfWeek</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.getAsText(long, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.eraTextToValue(java.lang.String)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.equalsIgnoreCase(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iEras</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.eraValueToText(int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iEras</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.getAsText(long, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.forLocale(java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.lang.System.identityHashCode(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.lang.ref.Reference.get()</outbound>
                <outbound type="class" confirmed="no">java.lang.ref.WeakReference</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="no">java.util.WeakHashMap</outbound>
                <outbound type="feature" confirmed="no">java.util.WeakHashMap.get(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.WeakHashMap.put(java.lang.Object, java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols(java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.cCache</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.cFastCache</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iLocale</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$HalfdayField.getAsText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$HalfdayField.getMaximumTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$HalfdayField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.getAsText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.getMaximumShortTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.getAsText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getAsText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getMaximumShortTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.getDayOfWeekMaxShortTextLength()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iMaxShortDayOfWeekLength</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.getMaximumShortTextLength(java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.getDayOfWeekMaxTextLength()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iMaxDayOfWeekLength</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.getEraMaxTextLength()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iMaxEraLength</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.getHalfdayMaxTextLength()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iMaxHalfdayLength</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$HalfdayField.getMaximumTextLength(java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.getMonthMaxShortTextLength()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iMaxShortMonthLength</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getMaximumShortTextLength(java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.getMonthMaxTextLength()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iMaxMonthLength</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.halfdayTextToValue(java.lang.String)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.equalsIgnoreCase(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iHalfday</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$HalfdayField.set(long, java.lang.String, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.halfdayValueToText(int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iHalfday</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$HalfdayField.getAsText(long, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.iDaysOfWeek</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.dayOfWeekTextToValue(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.dayOfWeekValueToText(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.iEras</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.eraTextToValue(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.eraValueToText(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.iHalfday</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.halfdayTextToValue(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.halfdayValueToText(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.iLocale</name>
                <outbound type="class" confirmed="no">java.lang.ref.WeakReference</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.forLocale(java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.iMaxDayOfWeekLength</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.getDayOfWeekMaxTextLength()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.iMaxEraLength</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.getEraMaxTextLength()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.iMaxHalfdayLength</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.getHalfdayMaxTextLength()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.iMaxMonthLength</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.getMonthMaxTextLength()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.iMaxShortDayOfWeekLength</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.getDayOfWeekMaxShortTextLength()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.iMaxShortMonthLength</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.getMonthMaxShortTextLength()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.iMonths</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.monthOfYearTextToValue(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.monthOfYearValueToText(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.iShortDaysOfWeek</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.dayOfWeekTextToValue(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.dayOfWeekValueToShortText(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.iShortMonths</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.monthOfYearTextToValue(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.monthOfYearValueToShortText(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.maxLength(java.lang.String[])</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols(java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.monthOfYearTextToValue(java.lang.String)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.equalsIgnoreCase(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iMonths</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iShortMonths</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.monthOfYearValueToShortText(int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iShortMonths</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.monthOfYearValueToText(int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.iMonths</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getAsText(long, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.realignDaysOfWeek(java.lang.String[])</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols(java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.realignMonths(java.lang.String[])</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.GJLocaleSymbols(java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJLocaleSymbols.static {}</name>
                <outbound type="class" confirmed="no">java.util.WeakHashMap</outbound>
                <outbound type="feature" confirmed="no">java.util.WeakHashMap.WeakHashMap()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.cCache</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.cFastCache</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.GJMonthOfYearDateTimeField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJMonthOfYearDateTimeField.GJMonthOfYearDateTimeField(org.joda.time.chrono.AbstractGJChronology)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getAverageMillisPerMonth()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.ImpreciseDateTimeField(java.lang.String, java.lang.String, long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJMonthOfYearDateTimeField.MAX</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJMonthOfYearDateTimeField.MIN</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJMonthOfYearDateTimeField.add(long, int)</name>
                <outbound type="feature" confirmed="no">java.lang.Math.abs(int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDayOfMonth(long, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDaysInYearMonth(int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMillisOfDay(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMonthOfYear(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearMonthDayMillis(int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.iChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.add(long, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJMonthOfYearDateTimeField.add(long, long)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Math.abs(long)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(long)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDayOfMonth(long, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDaysInYearMonth(int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMaxYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMillisOfDay(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMinYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMonthOfYear(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearMonthDayMillis(int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJMonthOfYearDateTimeField.addWrapped(long, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.getWrappedValue(int, int, int, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJMonthOfYearDateTimeField.get(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMonthOfYear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.iChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getAsText(long, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJMonthOfYearDateTimeField.getAsShortText(long, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.forLocale(java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.monthOfYearValueToShortText(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJMonthOfYearDateTimeField.getAsText(long, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.forLocale(java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.monthOfYearValueToText(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJMonthOfYearDateTimeField.getDifferenceAsLong(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDayOfMonth(long, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDaysInYearMonth(int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMonthOfYear(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearMonthMillis(int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.dayOfMonth()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.getDifference(long, long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJMonthOfYearDateTimeField.getLeapAmount(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.isLeap(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJMonthOfYearDateTimeField.getLeapDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.days()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJMonthOfYearDateTimeField.getMaximumShortTextLength(java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.forLocale(java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.getMonthMaxShortTextLength()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJMonthOfYearDateTimeField.getMaximumTextLength(java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.forLocale(java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.getMonthMaxTextLength()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJMonthOfYearDateTimeField.getMaximumValue()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJMonthOfYearDateTimeField.getMinimumValue()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJMonthOfYearDateTimeField.getRangeDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.years()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJMonthOfYearDateTimeField.iChronology</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.GJMonthOfYearDateTimeField(org.joda.time.chrono.AbstractGJChronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getLeapDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getRangeDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJMonthOfYearDateTimeField.isLeap(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDaysInYearMonth(int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMonthOfYear(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.iChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getLeapAmount(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJMonthOfYearDateTimeField.isLenient()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJMonthOfYearDateTimeField.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.monthOfYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJMonthOfYearDateTimeField.remainder(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.roundFloor(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJMonthOfYearDateTimeField.roundFloor(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMonthOfYear(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearMonthMillis(int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.iChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.remainder(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJMonthOfYearDateTimeField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJMonthOfYearDateTimeField.set(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDayOfMonth(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDaysInYearMonth(int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMillisOfDay(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearMonthDayMillis(int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeField, int, int, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJMonthOfYearDateTimeField.set(long, java.lang.String, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.forLocale(java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJLocaleSymbols.monthOfYearTextToValue(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.set(long, int)</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.GJWeekOfWeekyearDateTimeField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.GJWeekOfWeekyearDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.PreciseDurationDateTimeField(java.lang.String, org.joda.time.DurationField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.get(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getWeekOfWeekyear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.getMaximumValue()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.getMaximumValue(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getWeeksInYear(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getWeekyear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.iChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.getMaximumValueForSet(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.getMaximumValueForSet(long, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.getMaximumValue(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.getMinimumValue()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.getRangeDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.weekyears()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.iChronology</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.GJWeekOfWeekyearDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.getRangeDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.readResolve()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.weekOfWeekyear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.remainder(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.remainder(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.roundCeiling(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.roundCeiling(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.roundFloor(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.roundFloor(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.serialVersionUID</name>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.GJWeekyearDateTimeField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekyearDateTimeField.GJWeekyearDateTimeField(org.joda.time.chrono.AbstractGJChronology)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getAverageMillisPerYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.ImpreciseDateTimeField(java.lang.String, java.lang.String, long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekyearDateTimeField.WEEK_53</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekyearDateTimeField.add(long, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.set(long, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.addWrapped(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekyearDateTimeField.add(long, long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.safeToInt(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekyearDateTimeField.addWrapped(long, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.add(long, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekyearDateTimeField.get(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getWeekyear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.iChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekyearDateTimeField.getDifferenceAsLong(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getWeeksInYear(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.remainder(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.getDifference(long, long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekyearDateTimeField.getLeapAmount(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getWeeksInYear(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getWeekyear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekyearDateTimeField.getLeapDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.weeks()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekyearDateTimeField.getMaximumValue()</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMaxYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekyearDateTimeField.getMinimumValue()</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMinYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekyearDateTimeField.getRangeDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekyearDateTimeField.iChronology</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.GJWeekyearDateTimeField(org.joda.time.chrono.AbstractGJChronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.getLeapAmount(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.getLeapDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.getMaximumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.getMinimumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekyearDateTimeField.isLeap(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getWeeksInYear(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getWeekyear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekyearDateTimeField.isLenient()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekyearDateTimeField.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.weekyear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekyearDateTimeField.remainder(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.roundFloor(long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.getDifferenceAsLong(long, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekyearDateTimeField.roundFloor(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundFloor(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getWeekOfWeekyear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.weekOfWeekyear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.iChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.remainder(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekyearDateTimeField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJWeekyearDateTimeField.set(long, int)</name>
                <outbound type="feature" confirmed="no">java.lang.Math.abs(int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDayOfWeek(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMaxYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMinYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getWeekOfWeekyear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getWeeksInYear(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.setYear(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.dayOfWeek()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeField, int, int, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.add(long, int)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.GJYearDateTimeField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearDateTimeField.FEB_29</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearDateTimeField.GJYearDateTimeField(org.joda.time.chrono.AbstractGJChronology)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getAverageMillisPerYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.ImpreciseDateTimeField(java.lang.String, java.lang.String, long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearDateTimeField.add(long, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.set(long, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.add(long, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearDateTimeField.add(long, long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.safeToInt(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearDateTimeField.addWrapped(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMaxYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMinYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.getWrappedValue(int, int, int, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearDateTimeField.get(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.iChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.getLeapAmount(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.roundFloor(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearDateTimeField.getDifferenceAsLong(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearMillis(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.isLeapYear(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.getDifference(long, long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearDateTimeField.getLeapAmount(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.isLeapYear(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearDateTimeField.getLeapDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.days()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearDateTimeField.getMaximumValue()</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMaxYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearDateTimeField.getMinimumValue()</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMinYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearDateTimeField.getRangeDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearDateTimeField.iChronology</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.GJYearDateTimeField(org.joda.time.chrono.AbstractGJChronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.getLeapAmount(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.getLeapDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.getMaximumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.getMinimumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearDateTimeField.isLeap(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.isLeapYear(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearDateTimeField.isLenient()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearDateTimeField.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.year()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearDateTimeField.remainder(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.roundFloor(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearDateTimeField.roundCeiling(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearMillis(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearDateTimeField.roundFloor(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYearMillis(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.iChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.remainder(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearDateTimeField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearDateTimeField.set(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMaxYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getMinYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.setYear(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeField, int, int, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.addWrapped(long, int)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.GJYearOfEraDateTimeField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.DecoratedDateTimeField</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearOfEraDateTimeField.GJYearOfEraDateTimeField(org.joda.time.DateTimeField, org.joda.time.chrono.AbstractGJChronology)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.DecoratedDateTimeField(org.joda.time.DateTimeField, java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearOfEraDateTimeField.add(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearOfEraDateTimeField.add(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearOfEraDateTimeField.addWrapped(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.addWrapped(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearOfEraDateTimeField.get(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearOfEraDateTimeField.getDifference(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDifference(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearOfEraDateTimeField.getDifferenceAsLong(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDifferenceAsLong(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearOfEraDateTimeField.getMaximumValue()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMaximumValue()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearOfEraDateTimeField.getMinimumValue()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearOfEraDateTimeField.iChronology</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.GJYearOfEraDateTimeField(org.joda.time.DateTimeField, org.joda.time.chrono.AbstractGJChronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearOfEraDateTimeField.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.yearOfEra()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearOfEraDateTimeField.remainder(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.remainder(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearOfEraDateTimeField.roundCeiling(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundCeiling(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearOfEraDateTimeField.roundFloor(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundFloor(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearOfEraDateTimeField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GJYearOfEraDateTimeField.set(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getYear(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.getMaximumValue()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeField, int, int, int)</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.GregorianChronology</name>
            <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.GJChronology(org.joda.time.Chronology, org.joda.time.chrono.JulianChronology, org.joda.time.chrono.GregorianChronology, org.joda.time.Instant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.GJChronology(org.joda.time.chrono.JulianChronology, org.joda.time.chrono.GregorianChronology, org.joda.time.Instant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getMinimumDaysInFirstWeek()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.gregorianToJulianByWeekyear(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.gregorianToJulianByYear(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iGregorianChronology</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.julianToGregorianByWeekyear(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.julianToGregorianByYear(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.ISOYearOfEraDateTimeField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GregorianChronology.GregorianChronology(org.joda.time.Chronology, java.lang.Object, int)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.AbstractGJChronology(org.joda.time.Chronology, java.lang.Object, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GregorianChronology.INSTANCE_UTC</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstanceUTC()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.withUTC()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GregorianChronology.MILLIS_PER_MONTH</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GregorianChronology.MILLIS_PER_YEAR</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GregorianChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GregorianChronology.cCache</name>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GregorianChronology.calculateFirstDayOfYearMillis(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.isLeapYear(int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GregorianChronology.getApproxMillisAtEpoch()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GregorianChronology.getAverageMillisPerMonth()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GregorianChronology.getAverageMillisPerYear()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GregorianChronology.getInstance()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone, int)</name>
                <outbound type="class" confirmed="no">java.lang.ArrayIndexOutOfBoundsException</outbound>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.get(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.put(java.lang.Object, java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.GregorianChronology(org.joda.time.Chronology, java.lang.Object, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.cCache</outbound>
                <outbound type="class" confirmed="no">org.joda.time.chrono.GregorianChronology[]</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ZonedChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getInstance(org.joda.time.Chronology, org.joda.time.DateTimeZone)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GregorianChronology.getInstanceUTC()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.INSTANCE_UTC</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.ISOYearOfEraDateTimeField()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GregorianChronology.getMaxYear()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GregorianChronology.getMinYear()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GregorianChronology.isLeapYear(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.calculateFirstDayOfYearMillis(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GregorianChronology.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeZone()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GregorianChronology.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GregorianChronology.static {}</name>
                <outbound type="feature" confirmed="no">java.util.HashMap.HashMap()</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.INSTANCE_UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.cCache</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GregorianChronology.withDateTimeZone(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateTimeZone()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.GregorianChronology.withUTC()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.INSTANCE_UTC</outbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>org.joda.time.chrono.GregorianChronology[]</name>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.ISOChronology</name>
            <outbound type="class" confirmed="yes">org.joda.time.chrono.AssembledChronology</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(int, int, int, int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(int, int, int, int, int, int, int, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.selectChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateOnly(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toTimeOnly(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toTrustedISODateTime()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.selectChronologyUTC(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.DateOnly(int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.DateOnly(int, int, int, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getAverageYearMonthType()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getAverageYearMonthType(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getDayHourType(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getPreciseYearMonthType()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getPreciseYearWeekType()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getYearMonthType(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getYearWeekType(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.MutableDateOnly(int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.MutableDateOnly(int, int, int, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.MutableTimeOnly(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.MutableTimeOnly(int, int, int, int, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.TimeOnly(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.TimeOnly(int, int, int, int, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.withChronology(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology$Stub.readResolve()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.getChronology(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.getChronology(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.getChronology(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.getChronology(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getInstantMillis(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.Chronology, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.DateTimeZone, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstanceUTC()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.DateTimeZone, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance(org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstanceUTC()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.next(long, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.previous(long, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setInstant(int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.next(long, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.nextTransition(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.static {}</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.getLenientISOChronology()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDayOfWeek(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseMonth(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOChronology.FAST_CACHE_SIZE</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOChronology.INSTANCE_UTC</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.withUTC()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOChronology.ISOChronology(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.AssembledChronology(org.joda.time.Chronology, java.lang.Object)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeZone()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDurationField()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.centuries</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.centuryOfEra</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.yearOfCentury</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.INSTANCE</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.DividedDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.DateTimeField, java.lang.String, java.lang.String, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(org.joda.time.field.DividedDateTimeField, java.lang.String)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOChronology.cCache</name>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOChronology.cFastCache</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOChronology.getInstance()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.selectChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateOnly(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime(org.joda.time.ReadableInstant, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime(org.joda.time.ReadableInstant, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toTimeOnly(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.getChronology(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.getChronology(java.lang.Object, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.getChronology(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.getChronology(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.Chronology, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.lang.System.identityHashCode(java.lang.Object)</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.get(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.put(java.lang.Object, java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeZone()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.INSTANCE_UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.ISOChronology(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.cCache</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.cFastCache</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ZonedChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getInstance(org.joda.time.Chronology, org.joda.time.DateTimeZone)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(int, int, int, int, int, int, int, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(long, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toTrustedISODateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology$Stub.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getInstantMillis(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.DateTimeZone, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.DateTimeZone, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance(org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOChronology.getInstanceUTC()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.INSTANCE_UTC</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.selectChronologyUTC(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.DateOnly(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.DateOnly(int, int, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getAverageYearMonthType()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getAverageYearMonthType(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getDayHourType(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getPreciseYearMonthType()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getPreciseYearWeekType()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getYearMonthType(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.getYearWeekType(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.MutableDateOnly(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.MutableDateOnly(int, int, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.MutableTimeOnly(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.MutableTimeOnly(int, int, int, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.TimeOnly(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.TimeOnly(int, int, int, int, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.withChronology(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstanceUTC()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstanceUTC()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.next(long, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.previous(long, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setInstant(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.next(long, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.nextTransition(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.getLenientISOChronology()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDayOfWeek(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseMonth(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOChronology.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOChronology.static {}</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.util.HashMap.HashMap()</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.put(java.lang.Object, java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GregorianChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstanceUTC()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.INSTANCE_UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.ISOChronology(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.cCache</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.cFastCache</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOChronology.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getID()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeZone()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOChronology.withDateTimeZone(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeZone()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOChronology.withUTC()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.INSTANCE_UTC</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOChronology.writeReplace()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeZone()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology$Stub.ISOChronology$Stub(org.joda.time.DateTimeZone)</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.ISOChronology$Stub</name>
            <outbound type="class" confirmed="no">java.io.Serializable</outbound>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOChronology$Stub.ISOChronology$Stub(org.joda.time.DateTimeZone)</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology$Stub.iZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.writeReplace()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOChronology$Stub.iZone</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology$Stub.ISOChronology$Stub(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology$Stub.readObject(java.io.ObjectInputStream)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology$Stub.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology$Stub.writeObject(java.io.ObjectOutputStream)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOChronology$Stub.readObject(java.io.ObjectInputStream)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.ObjectInputStream</outbound>
                <outbound type="feature" confirmed="no">java.io.ObjectInputStream.readObject()</outbound>
                <outbound type="class" confirmed="no">java.lang.ClassNotFoundException</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology$Stub.iZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOChronology$Stub.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology$Stub.iZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOChronology$Stub.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOChronology$Stub.writeObject(java.io.ObjectOutputStream)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.ObjectOutputStream</outbound>
                <outbound type="feature" confirmed="no">java.io.ObjectOutputStream.writeObject(java.lang.Object)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology$Stub.iZone</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.ISOYearOfEraDateTimeField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.DecoratedDateTimeField</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOYearOfEraDateTimeField.INSTANCE</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOYearOfEraDateTimeField.ISOYearOfEraDateTimeField()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.year()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GregorianChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstanceUTC()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.DecoratedDateTimeField(org.joda.time.DateTimeField, java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOYearOfEraDateTimeField.add(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOYearOfEraDateTimeField.add(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOYearOfEraDateTimeField.addWrapped(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.addWrapped(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOYearOfEraDateTimeField.get(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOYearOfEraDateTimeField.getDifference(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDifference(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOYearOfEraDateTimeField.getDifferenceAsLong(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDifferenceAsLong(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOYearOfEraDateTimeField.getMaximumValue()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMaximumValue()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOYearOfEraDateTimeField.getMinimumValue()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOYearOfEraDateTimeField.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.INSTANCE</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOYearOfEraDateTimeField.remainder(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.remainder(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOYearOfEraDateTimeField.roundCeiling(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundCeiling(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOYearOfEraDateTimeField.roundFloor(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundFloor(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOYearOfEraDateTimeField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOYearOfEraDateTimeField.set(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.getMaximumValue()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeField, int, int, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ISOYearOfEraDateTimeField.static {}</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.INSTANCE</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.ISOYearOfEraDateTimeField()</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.JulianChronology</name>
            <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.GJChronology(org.joda.time.Chronology, org.joda.time.chrono.JulianChronology, org.joda.time.chrono.GregorianChronology, org.joda.time.Instant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.GJChronology(org.joda.time.chrono.JulianChronology, org.joda.time.chrono.GregorianChronology, org.joda.time.Instant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getDateTimeMillis(int, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.gregorianToJulianByWeekyear(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.gregorianToJulianByYear(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.iJulianChronology</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.julianToGregorianByWeekyear(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.julianToGregorianByYear(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology.INSTANCE_UTC</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstanceUTC()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.withUTC()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology.JulianChronology(org.joda.time.Chronology, java.lang.Object, int)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.AbstractGJChronology(org.joda.time.Chronology, java.lang.Object, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology.MILLIS_PER_MONTH</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology.MILLIS_PER_YEAR</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology.adjustYearForSet(int)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoYearZeroField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getDateOnlyMillis(int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weekyear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.year</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoWeekyearZeroField.JulianChronology$NoWeekyearZeroField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DateTimeField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoYearZeroField.JulianChronology$NoYearZeroField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology.cCache</name>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology.calculateFirstDayOfYearMillis(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.isLeapYear(int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology.getApproxMillisAtEpoch()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology.getAverageMillisPerMonth()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology.getAverageMillisPerYear()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology.getDateOnlyMillis(int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateOnlyMillis(int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.adjustYearForSet(int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology.getInstance()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone, int)</name>
                <outbound type="class" confirmed="no">java.lang.ArrayIndexOutOfBoundsException</outbound>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.get(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.put(java.lang.Object, java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.JulianChronology(org.joda.time.Chronology, java.lang.Object, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.cCache</outbound>
                <outbound type="class" confirmed="no">org.joda.time.chrono.JulianChronology[]</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ZonedChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getInstance(org.joda.time.Chronology, org.joda.time.DateTimeZone)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology.getInstanceUTC()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.INSTANCE_UTC</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology.getMaxYear()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology.getMinYear()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology.isLeapYear(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.calculateFirstDayOfYearMillis(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeZone()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology.static {}</name>
                <outbound type="feature" confirmed="no">java.util.HashMap.HashMap()</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.INSTANCE_UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.cCache</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology.withDateTimeZone(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateTimeZone()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology.withUTC()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.INSTANCE_UTC</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.JulianChronology$NoWeekyearZeroField</name>
            <outbound type="class" confirmed="yes">org.joda.time.chrono.JulianChronology$NoYearZeroField</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology$NoWeekyearZeroField.JulianChronology$NoWeekyearZeroField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DateTimeField)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoYearZeroField.JulianChronology$NoYearZeroField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DateTimeField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology$NoWeekyearZeroField.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.weekyear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoYearZeroField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology$NoWeekyearZeroField.serialVersionUID</name>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.JulianChronology$NoYearZeroField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.DelegatedDateTimeField</outbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.JulianChronology$NoWeekyearZeroField</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology$NoYearZeroField.JulianChronology$NoYearZeroField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DateTimeField)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoYearZeroField.iChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoYearZeroField.iMinYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.DelegatedDateTimeField(org.joda.time.DateTimeField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getMinimumValue()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoWeekyearZeroField.JulianChronology$NoWeekyearZeroField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology$NoYearZeroField.get(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.get(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology$NoYearZeroField.getMinimumValue()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoYearZeroField.iMinYear</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology$NoYearZeroField.iChronology</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoWeekyearZeroField.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoYearZeroField.JulianChronology$NoYearZeroField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoYearZeroField.readResolve()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology$NoYearZeroField.iMinYear</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoYearZeroField.JulianChronology$NoYearZeroField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoYearZeroField.getMinimumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoYearZeroField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology$NoYearZeroField.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.year()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoYearZeroField.iChronology</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology$NoYearZeroField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.JulianChronology$NoYearZeroField.set(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoYearZeroField.iMinYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.adjustYearForSet(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getMaximumValue()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeField, int, int, int)</outbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>org.joda.time.chrono.JulianChronology[]</name>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.LenientChronology</name>
            <outbound type="class" confirmed="yes">org.joda.time.chrono.AssembledChronology</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.getLenientISOChronology()</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LenientChronology.LenientChronology(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.AssembledChronology(org.joda.time.Chronology, java.lang.Object)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.getInstance(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LenientChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.centuryOfEra</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.clockhourOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.clockhourOfHalfday</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.dayOfMonth</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.dayOfWeek</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.dayOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.era</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.halfdayOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.hourOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.hourOfHalfday</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.millisOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.millisOfSecond</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.minuteOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.minuteOfHour</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.monthOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.secondOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.secondOfMinute</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weekOfWeekyear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weekyear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.year</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.yearOfCentury</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.yearOfEra</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.convertField(org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LenientChronology.convertField(org.joda.time.DateTimeField)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.LenientDateTimeField.getInstance(org.joda.time.DateTimeField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LenientChronology.getInstance(org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.LenientChronology(org.joda.time.Chronology)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.withUTC()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.getLenientISOChronology()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LenientChronology.iWithUTC</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.withUTC()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LenientChronology.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LenientChronology.toString()</name>
                <outbound type="feature" confirmed="no">java.lang.Object.toString()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LenientChronology.withDateTimeZone(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.withDateTimeZone(org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeZone()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.getInstance(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.withUTC()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LenientChronology.withUTC()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.withUTC()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeZone()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.getInstance(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.iWithUTC</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.LimitChronology</name>
            <outbound type="class" confirmed="yes">org.joda.time.chrono.AssembledChronology</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.LimitChronology$LimitDateTimeField(org.joda.time.chrono.LimitChronology, org.joda.time.DateTimeField, org.joda.time.DurationField, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.add(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.add(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.addWrapped(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.get(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getAsText(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getDifference(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getDifferenceAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getLeapAmount(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getMaximumValue(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getMinimumValue(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.isLeap(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.remainder(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundCeiling(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundFloor(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundHalfCeiling(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundHalfEven(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundHalfFloor(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.set(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.this$0</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.LimitChronology$LimitDurationField(org.joda.time.chrono.LimitChronology, org.joda.time.DurationField)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.add(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.add(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getDifference(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getDifferenceAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getMillis(int, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getMillis(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getValue(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getValueAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.this$0</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.LimitChronology$LimitException(org.joda.time.chrono.LimitChronology, java.lang.String, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.getMessage()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.this$0</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology.LimitChronology(org.joda.time.Chronology, org.joda.time.DateTime, org.joda.time.DateTime)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.AssembledChronology(org.joda.time.Chronology, java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.iLowerLimit</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.iUpperLimit</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getInstance(org.joda.time.Chronology, org.joda.time.ReadableDateTime, org.joda.time.ReadableDateTime)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</name>
                <outbound type="class" confirmed="no">java.util.HashMap</outbound>
                <outbound type="feature" confirmed="no">java.util.HashMap.HashMap()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.centuries</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.centuryOfEra</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.clockhourOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.clockhourOfHalfday</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.dayOfMonth</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.dayOfWeek</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.dayOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.days</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.era</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.eras</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.halfdayOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.hourOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.hourOfHalfday</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.hours</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.millis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.millisOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.millisOfSecond</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.minuteOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.minuteOfHour</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.minutes</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.monthOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.months</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.secondOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.secondOfMinute</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.seconds</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weekOfWeekyear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weeks</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weekyear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weekyears</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.year</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.yearOfCentury</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.yearOfEra</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.years</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.convertField(org.joda.time.DurationField, java.util.HashMap)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.LimitChronology$LimitException(org.joda.time.chrono.LimitChronology, java.lang.String, boolean)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.iLowerLimit</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.iUpperLimit</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getAsText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getLeapAmount(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getMinimumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.remainder(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundHalfCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundHalfEven(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundHalfFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getMillis(int, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getMillis(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getValue(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getValueAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getDateOnlyMillis(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getDateOnlyMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getDateTimeMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getTimeOnlyMillis(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.util.HashMap</outbound>
                <outbound type="feature" confirmed="no">java.util.HashMap.containsKey(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.HashMap.get(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.HashMap.put(java.lang.Object, java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDurationField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getLeapDurationField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getRangeDurationField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.isSupported()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.LimitChronology$LimitDateTimeField(org.joda.time.chrono.LimitChronology, org.joda.time.DateTimeField, org.joda.time.DurationField, org.joda.time.DurationField, org.joda.time.DurationField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.convertField(org.joda.time.DurationField, java.util.HashMap)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology.convertField(org.joda.time.DurationField, java.util.HashMap)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.util.HashMap</outbound>
                <outbound type="feature" confirmed="no">java.util.HashMap.containsKey(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.HashMap.get(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.HashMap.put(java.lang.Object, java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isSupported()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.LimitChronology$LimitDurationField(org.joda.time.chrono.LimitChronology, org.joda.time.DurationField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology.getDateOnlyMillis(int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateOnlyMillis(int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology.getDateOnlyMillis(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateOnlyMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology.getDateTimeMillis(int, int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeMillis(int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology.getDateTimeMillis(int, int, int, int, int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeMillis(int, int, int, int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology.getDateTimeMillis(long, int, int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeMillis(long, int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology.getInstance(org.joda.time.Chronology, org.joda.time.ReadableDateTime, org.joda.time.ReadableDateTime)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDateTime.toDateTime()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.isBefore(org.joda.time.ReadableInstant)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.LimitChronology(org.joda.time.Chronology, org.joda.time.DateTime, org.joda.time.DateTime)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology.getLowerLimit()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.iLowerLimit</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.getMessage()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology.getTimeOnlyMillis(int, int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getTimeOnlyMillis(int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology.getTimeOnlyMillis(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getTimeOnlyMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology.getUpperLimit()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.iUpperLimit</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.getMessage()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology.iLowerLimit</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.LimitChronology(org.joda.time.Chronology, org.joda.time.DateTime, org.joda.time.DateTime)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getLowerLimit()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology.iUpperLimit</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.LimitChronology(org.joda.time.Chronology, org.joda.time.DateTime, org.joda.time.DateTime)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getUpperLimit()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology.iWithUTC</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology.toString()</name>
                <outbound type="feature" confirmed="no">java.lang.Object.toString()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology.withDateTimeZone(org.joda.time.DateTimeZone)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toDateTime()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractInstant.toMutableDateTime()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.withDateTimeZone(org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.MutableDateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.moveDateTimeZone(org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeZone()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getInstance(org.joda.time.Chronology, org.joda.time.ReadableDateTime, org.joda.time.ReadableDateTime)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.iLowerLimit</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.iUpperLimit</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.iWithUTC</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.withUTC()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology.withUTC()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.withDateTimeZone(org.joda.time.DateTimeZone)</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.LimitChronology$LimitDateTimeField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.DecoratedDateTimeField</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDateTimeField.LimitChronology$LimitDateTimeField(org.joda.time.chrono.LimitChronology, org.joda.time.DateTimeField, org.joda.time.DurationField, org.joda.time.DurationField, org.joda.time.DurationField)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getName()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.iDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.iLeapDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.iRangeDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.DecoratedDateTimeField(org.joda.time.DateTimeField, java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDateTimeField.add(long, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDateTimeField.add(long, long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDateTimeField.addWrapped(long, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.addWrapped(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDateTimeField.get(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDateTimeField.getAsShortText(long, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getAsShortText(long, java.util.Locale)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDateTimeField.getAsText(long, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getAsText(long, java.util.Locale)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDateTimeField.getDifference(long, long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDifference(long, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDateTimeField.getDifferenceAsLong(long, long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDifferenceAsLong(long, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDateTimeField.getDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.iDurationField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDateTimeField.getLeapAmount(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getLeapAmount(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDateTimeField.getLeapDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.iLeapDurationField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDateTimeField.getMaximumShortTextLength(java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMaximumShortTextLength(java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDateTimeField.getMaximumTextLength(java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMaximumTextLength(java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDateTimeField.getMaximumValue(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMaximumValue(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDateTimeField.getMinimumValue(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMinimumValue(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDateTimeField.getRangeDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.iRangeDurationField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDateTimeField.iDurationField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.LimitChronology$LimitDateTimeField(org.joda.time.chrono.LimitChronology, org.joda.time.DateTimeField, org.joda.time.DurationField, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getDurationField()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDateTimeField.iLeapDurationField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.LimitChronology$LimitDateTimeField(org.joda.time.chrono.LimitChronology, org.joda.time.DateTimeField, org.joda.time.DurationField, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getLeapDurationField()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDateTimeField.iRangeDurationField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.LimitChronology$LimitDateTimeField(org.joda.time.chrono.LimitChronology, org.joda.time.DateTimeField, org.joda.time.DurationField, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getRangeDurationField()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDateTimeField.isLeap(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.isLeap(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDateTimeField.remainder(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.remainder(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundCeiling(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundCeiling(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundFloor(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundFloor(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundHalfCeiling(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundHalfCeiling(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundHalfEven(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundHalfEven(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundHalfFloor(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundHalfFloor(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDateTimeField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDateTimeField.set(long, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDateTimeField.set(long, java.lang.String, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, java.lang.String, java.util.Locale)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDateTimeField.this$0</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.LimitChronology$LimitDateTimeField(org.joda.time.chrono.LimitChronology, org.joda.time.DateTimeField, org.joda.time.DurationField, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getAsText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getLeapAmount(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getMinimumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.remainder(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundHalfCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundHalfEven(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundHalfFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.LimitChronology$LimitDurationField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.DecoratedDurationField</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDurationField.LimitChronology$LimitDurationField(org.joda.time.chrono.LimitChronology, org.joda.time.DurationField)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getName()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.DecoratedDurationField(org.joda.time.DurationField, java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.convertField(org.joda.time.DurationField, java.util.HashMap)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDurationField.add(long, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDurationField.add(long, long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDurationField.getDifference(long, long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getDifference(long, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDurationField.getDifferenceAsLong(long, long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getDifferenceAsLong(long, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDurationField.getMillis(int, long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getMillis(int, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDurationField.getMillis(long, long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getMillis(long, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDurationField.getValue(long, long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getValue(long, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDurationField.getValueAsLong(long, long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getValueAsLong(long, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDurationField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitDurationField.this$0</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.LimitChronology$LimitDurationField(org.joda.time.chrono.LimitChronology, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getMillis(int, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getMillis(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getValue(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getValueAsLong(long, long)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.LimitChronology$LimitException</name>
            <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitException.LimitChronology$LimitException(org.joda.time.chrono.LimitChronology, java.lang.String, boolean)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.iIsLow</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.this$0</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.checkLimits(long, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitException.getMessage()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="feature" confirmed="no">java.lang.Throwable.getMessage()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.iIsLow</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getLowerLimit()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology.getUpperLimit()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.ISODateTimeFormat</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTime()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance(org.joda.time.Chronology)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitException.iIsLow</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.LimitChronology$LimitException(org.joda.time.chrono.LimitChronology, java.lang.String, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.getMessage()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitException.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitException.this$0</name>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.LimitChronology$LimitException(org.joda.time.chrono.LimitChronology, java.lang.String, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.getMessage()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.LimitChronology$LimitException.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.getMessage()</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.StrictChronology</name>
            <outbound type="class" confirmed="yes">org.joda.time.chrono.AssembledChronology</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.StrictChronology.StrictChronology(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.AssembledChronology(org.joda.time.Chronology, java.lang.Object)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.getInstance(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.StrictChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.centuryOfEra</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.clockhourOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.clockhourOfHalfday</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.dayOfMonth</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.dayOfWeek</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.dayOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.era</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.halfdayOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.hourOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.hourOfHalfday</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.millisOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.millisOfSecond</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.minuteOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.minuteOfHour</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.monthOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.secondOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.secondOfMinute</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weekOfWeekyear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weekyear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.year</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.yearOfCentury</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.yearOfEra</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.convertField(org.joda.time.DateTimeField)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.StrictChronology.convertField(org.joda.time.DateTimeField)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.StrictDateTimeField.getInstance(org.joda.time.DateTimeField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.StrictChronology.getInstance(org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.StrictChronology(org.joda.time.Chronology)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.withUTC()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.StrictChronology.iWithUTC</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.withUTC()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.StrictChronology.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.StrictChronology.toString()</name>
                <outbound type="feature" confirmed="no">java.lang.Object.toString()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.StrictChronology.withDateTimeZone(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.withDateTimeZone(org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeZone()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.getInstance(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.withUTC()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.StrictChronology.withUTC()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.withUTC()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getDateTimeZone()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.getInstance(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.iWithUTC</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.ZonedChronology</name>
            <outbound type="class" confirmed="yes">org.joda.time.chrono.AssembledChronology</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology.ZonedChronology(org.joda.time.Chronology, org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.AssembledChronology(org.joda.time.Chronology, java.lang.Object)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getInstance(org.joda.time.Chronology, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.withDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</name>
                <outbound type="class" confirmed="no">java.util.HashMap</outbound>
                <outbound type="feature" confirmed="no">java.util.HashMap.HashMap()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.centuries</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.centuryOfEra</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.clockhourOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.clockhourOfHalfday</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.dayOfMonth</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.dayOfWeek</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.dayOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.days</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.era</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.eras</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.halfdayOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.hourOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.hourOfHalfday</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.hours</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.millis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.millisOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.millisOfSecond</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.minuteOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.minuteOfHour</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.minutes</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.monthOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.months</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.secondOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.secondOfMinute</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.seconds</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weekOfWeekyear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weeks</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weekyear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.weekyears</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.year</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.yearOfCentury</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.yearOfEra</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology$Fields.years</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DurationField, java.util.HashMap)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.util.HashMap</outbound>
                <outbound type="feature" confirmed="no">java.util.HashMap.containsKey(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.HashMap.get(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.HashMap.put(java.lang.Object, java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDurationField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getLeapDurationField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getRangeDurationField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.isSupported()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.ZonedChronology$ZonedDateTimeField(org.joda.time.DateTimeField, org.joda.time.DateTimeZone, org.joda.time.DurationField, org.joda.time.DurationField, org.joda.time.DurationField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DurationField, java.util.HashMap)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getDateTimeZone()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DurationField, java.util.HashMap)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.util.HashMap</outbound>
                <outbound type="feature" confirmed="no">java.util.HashMap.containsKey(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.HashMap.get(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.HashMap.put(java.lang.Object, java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isSupported()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.ZonedChronology$ZonedDurationField(org.joda.time.DurationField, org.joda.time.DateTimeZone)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getDateTimeZone()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology.getDateOnlyMillis(int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateOnlyMillis(int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.localToUTC(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology.getDateTimeMillis(int, int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeMillis(int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.localToUTC(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology.getDateTimeMillis(int, int, int, int, int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeMillis(int, int, int, int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.localToUTC(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology.getDateTimeMillis(long, int, int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeMillis(long, int, int, int, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getDateTimeZone()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.localToUTC(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology.getDateTimeZone()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getParam()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DurationField, java.util.HashMap)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.localToUTC(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology.getInstance(org.joda.time.Chronology, org.joda.time.DateTimeZone)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.withUTC()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.ZonedChronology(org.joda.time.Chronology, org.joda.time.DateTimeZone)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, org.joda.time.ReadableInstant, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology.getTimeOnlyMillis(int, int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getTimeOnlyMillis(int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.localToUTC(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology.localToUTC(long)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffsetFromLocal(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getDateTimeZone()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getDateOnlyMillis(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getDateTimeMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getDateTimeMillis(int, int, int, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getDateTimeMillis(long, int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology.toString()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getID()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.getDateTimeZone()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology.useTimeArithmetic(org.joda.time.DurationField)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getUnitMillis()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.ZonedChronology$ZonedDateTimeField(org.joda.time.DateTimeField, org.joda.time.DateTimeZone, org.joda.time.DurationField, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.ZonedChronology$ZonedDurationField(org.joda.time.DurationField, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology.withDateTimeZone(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getParam()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.ZonedChronology(org.joda.time.Chronology, org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology.withUTC()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.getBase()</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.AbstractDateTimeField</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.ZonedChronology$ZonedDateTimeField(org.joda.time.DateTimeField, org.joda.time.DateTimeZone, org.joda.time.DurationField, org.joda.time.DurationField, org.joda.time.DurationField)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getName()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.isSupported()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iLeapDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iRangeDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.useTimeArithmetic(org.joda.time.DurationField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.AbstractDateTimeField(java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DateTimeField, java.util.HashMap)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.add(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffsetFromLocal(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.add(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffsetFromLocal(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.addWrapped(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.addWrapped(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffsetFromLocal(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.get(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getAsShortText(long, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getAsShortText(long, java.util.Locale)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getAsText(long, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getAsText(long, java.util.Locale)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getDifference(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDifference(long, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getDifferenceAsLong(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDifferenceAsLong(long, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iDurationField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getLeapAmount(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getLeapAmount(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getLeapDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iLeapDurationField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMaximumShortTextLength(java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMaximumShortTextLength(java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMaximumTextLength(java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMaximumTextLength(java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMaximumValue()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMaximumValue()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMaximumValue(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMaximumValue(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMinimumValue()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMinimumValue()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMinimumValue(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMinimumValue(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getRangeDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iRangeDurationField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iDurationField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.ZonedChronology$ZonedDateTimeField(org.joda.time.DateTimeField, org.joda.time.DateTimeZone, org.joda.time.DurationField, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getDurationField()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.ZonedChronology$ZonedDateTimeField(org.joda.time.DateTimeField, org.joda.time.DateTimeZone, org.joda.time.DurationField, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getAsText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getLeapAmount(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMaximumShortTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMaximumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMinimumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMinimumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.isLenient()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.remainder(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iLeapDurationField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.ZonedChronology$ZonedDateTimeField(org.joda.time.DateTimeField, org.joda.time.DateTimeZone, org.joda.time.DurationField, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getLeapDurationField()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iRangeDurationField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.ZonedChronology$ZonedDateTimeField(org.joda.time.DateTimeField, org.joda.time.DateTimeZone, org.joda.time.DurationField, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getRangeDurationField()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iTimeField</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.ZonedChronology$ZonedDateTimeField(org.joda.time.DateTimeField, org.joda.time.DateTimeZone, org.joda.time.DurationField, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.roundFloor(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iZone</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.ZonedChronology$ZonedDateTimeField(org.joda.time.DateTimeField, org.joda.time.DateTimeZone, org.joda.time.DurationField, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getAsText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getLeapAmount(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMinimumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.remainder(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.isLeap(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.isLeap(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.isLenient()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.isLenient()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.remainder(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.remainder(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.roundCeiling(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundCeiling(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffsetFromLocal(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.roundFloor(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundFloor(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffsetFromLocal(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.set(long, int)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getName()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffsetFromLocal(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.set(long, java.lang.String, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, java.lang.String, java.util.Locale)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffsetFromLocal(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.iZone</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.chrono.ZonedChronology$ZonedDurationField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.AbstractDurationField</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDurationField.ZonedChronology$ZonedDurationField(org.joda.time.DurationField, org.joda.time.DateTimeZone)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getName()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isSupported()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.iTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.iZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.useTimeArithmetic(org.joda.time.DurationField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.AbstractDurationField(java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology.convertField(org.joda.time.DurationField, java.util.HashMap)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDurationField.add(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffsetFromLocal(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.iTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.iZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDurationField.add(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffsetFromLocal(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.iTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.iZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDurationField.getDifference(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getDifference(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.iTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.iZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDurationField.getDifferenceAsLong(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getDifferenceAsLong(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.iTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.iZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDurationField.getMillis(int, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getMillis(int, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.iZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDurationField.getMillis(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getMillis(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.iZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDurationField.getUnitMillis()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getUnitMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDurationField.getValue(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getValue(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.iZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDurationField.getValueAsLong(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getValueAsLong(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.iZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDurationField.iField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.ZonedChronology$ZonedDurationField(org.joda.time.DurationField, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getMillis(int, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getMillis(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getUnitMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getValue(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getValueAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.isPrecise()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDurationField.iTimeField</name>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.ZonedChronology$ZonedDurationField(org.joda.time.DurationField, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.isPrecise()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDurationField.iZone</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.ZonedChronology$ZonedDurationField(org.joda.time.DurationField, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getMillis(int, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getMillis(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getValue(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.getValueAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.isPrecise()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDurationField.isPrecise()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.isFixed()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isPrecise()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.iTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.iZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.chrono.ZonedChronology$ZonedDurationField.serialVersionUID</name>
            </feature>
        </class>
    </package>
    <package confirmed="yes">
        <name>org.joda.time.convert</name>
        <class confirmed="yes">
            <name>org.joda.time.convert.AbstractConverter</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.convert.Converter</outbound>
            <inbound type="class" confirmed="yes">org.joda.time.convert.CalendarConverter</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.convert.DateConverter</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.convert.LongConverter</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.convert.ReadableDurationConverter</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.convert.ReadableInstantConverter</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.convert.StringConverter</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.convert.AbstractConverter.AbstractConverter()</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.CalendarConverter()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.DateConverter.DateConverter()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.LongConverter()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.ReadableDurationConverter()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.ReadableInstantConverter()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.StringConverter()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.AbstractConverter.getChronology(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.AbstractConverter.getChronology(java.lang.Object, org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getInstantMillis(java.lang.Object, org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.AbstractConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.AbstractConverter.getInstantMillis(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.getInstantMillis(java.lang.Object, org.joda.time.DateTimeZone)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.getInstantMillis(java.lang.Object, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.getInstantMillis(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.AbstractConverter.getInstantMillis(java.lang.Object, org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.getInstantMillis(java.lang.Object)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.AbstractConverter.getInstantMillis(java.lang.Object, org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.getInstantMillis(java.lang.Object)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.getInstantMillis(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.AbstractConverter.getSupportedType()</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.convert.CalendarConverter</name>
            <outbound type="class" confirmed="yes">org.joda.time.convert.AbstractConverter</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.convert.InstantConverter</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.ConverterManager()</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.convert.CalendarConverter.CalendarConverter()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.AbstractConverter()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.CalendarConverter.INSTANCE</name>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.ConverterManager()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.CalendarConverter.class$(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <outbound type="feature" confirmed="no">java.lang.Class.forName(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.ClassNotFoundException</outbound>
                <outbound type="feature" confirmed="no">java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.Throwable.getMessage()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getSupportedType()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.CalendarConverter.class$java$util$Calendar</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getSupportedType()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.util.Calendar</outbound>
                <outbound type="feature" confirmed="no">java.util.Calendar.getTimeZone()</outbound>
                <outbound type="class" confirmed="no">java.util.TimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.util.TimeZone)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <outbound type="feature" confirmed="no">java.lang.Class.getName()</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.getClass()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.endsWith(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.util.Date</outbound>
                <outbound type="feature" confirmed="no">java.util.Date.getTime()</outbound>
                <outbound type="class" confirmed="no">java.util.GregorianCalendar</outbound>
                <outbound type="feature" confirmed="no">java.util.GregorianCalendar.getGregorianChange()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.BuddhistChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GJChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.getInstance(org.joda.time.DateTimeZone, long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.GregorianChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.GregorianChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.JulianChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.getChronology(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.CalendarConverter.getInstantMillis(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.util.Calendar</outbound>
                <outbound type="feature" confirmed="no">java.util.Calendar.getTime()</outbound>
                <outbound type="class" confirmed="no">java.util.Date</outbound>
                <outbound type="feature" confirmed="no">java.util.Date.getTime()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.CalendarConverter.getSupportedType()</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.class$(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.class$java$util$Calendar</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.CalendarConverter.static {}</name>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.CalendarConverter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.INSTANCE</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.convert.Converter</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="class" confirmed="yes">org.joda.time.convert.AbstractConverter</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.ConverterManager()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.addDurationConverter(org.joda.time.convert.DurationConverter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.addInstantConverter(org.joda.time.convert.InstantConverter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.addIntervalConverter(org.joda.time.convert.IntervalConverter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getDurationConverter(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getDurationConverters()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstantConverter(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstantConverters()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getIntervalConverter(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getIntervalConverters()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.removeDurationConverter(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.removeDurationConverter(org.joda.time.convert.DurationConverter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.removeInstantConverter(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.removeInstantConverter(org.joda.time.convert.InstantConverter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.removeIntervalConverter(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.removeIntervalConverter(org.joda.time.convert.IntervalConverter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet$Entry.ConverterSet$Entry(java.lang.Class, org.joda.time.convert.Converter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet$Entry.iConverter</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.ConverterSet(org.joda.time.convert.Converter[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.add(org.joda.time.convert.Converter, org.joda.time.convert.Converter[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.copyInto(org.joda.time.convert.Converter[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.iConverters</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.remove(int, org.joda.time.convert.Converter[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.remove(org.joda.time.convert.Converter, org.joda.time.convert.Converter[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.select(java.lang.Class)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.selectSlow(org.joda.time.convert.ConverterSet, java.lang.Class)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.size()</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.convert.DurationConverter</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.convert.InstantConverter</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.convert.IntervalConverter</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.convert.Converter.getSupportedType()</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.add(org.joda.time.convert.Converter, org.joda.time.convert.Converter[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.selectSlow(org.joda.time.convert.ConverterSet, java.lang.Class)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.convert.ConverterManager</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.setMillis(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.setMillis(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.getMillisFromObject(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Instant.Instant(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.add(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.add(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDate(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setTime(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.add(java.lang.Object)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterManager.ConverterManager()</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.CalendarConverter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.CalendarConverter.INSTANCE</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.Converter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.iDurationConverters</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.iInstantConverters</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.iIntervalConverters</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterSet</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.ConverterSet(org.joda.time.convert.Converter[])</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.DateConverter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.DateConverter.INSTANCE</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.LongConverter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.INSTANCE</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.PartialInstantConverter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.INSTANCE</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ReadableDurationConverter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.INSTANCE</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ReadableInstantConverter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.INSTANCE</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.INSTANCE</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.StringConverter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.INSTANCE</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstance()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterManager.INSTANCE</name>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstance()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterManager.addDurationConverter(org.joda.time.convert.DurationConverter)</name>
                <outbound type="class" confirmed="yes">org.joda.time.convert.Converter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.iDurationConverters</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterSet</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.add(org.joda.time.convert.Converter, org.joda.time.convert.Converter[])</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.DurationConverter</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterManager.addInstantConverter(org.joda.time.convert.InstantConverter)</name>
                <outbound type="class" confirmed="yes">org.joda.time.convert.Converter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.iInstantConverters</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterSet</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.add(org.joda.time.convert.Converter, org.joda.time.convert.Converter[])</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.InstantConverter</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterManager.addIntervalConverter(org.joda.time.convert.IntervalConverter)</name>
                <outbound type="class" confirmed="yes">org.joda.time.convert.Converter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.iIntervalConverters</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterSet</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.add(org.joda.time.convert.Converter, org.joda.time.convert.Converter[])</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.IntervalConverter</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterManager.getDurationConverter(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <outbound type="feature" confirmed="no">java.lang.Class.getName()</outbound>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.getClass()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.Converter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.iDurationConverters</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterSet</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.select(java.lang.Class)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.DurationConverter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.add(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.add(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.add(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterManager.getDurationConverters()</name>
                <outbound type="class" confirmed="yes">org.joda.time.convert.Converter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.iDurationConverters</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterSet</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.copyInto(org.joda.time.convert.Converter[])</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.size()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.DurationConverter</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterManager.getInstance()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.ConverterManager()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.INSTANCE</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.setMillis(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.setMillis(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.getMillisFromObject(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Instant.Instant(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.add(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.add(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDate(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setTime(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.add(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterManager.getInstantConverter(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <outbound type="feature" confirmed="no">java.lang.Class.getName()</outbound>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.getClass()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.Converter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.iInstantConverters</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterSet</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.select(java.lang.Class)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.InstantConverter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.setMillis(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.setMillis(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.getMillisFromObject(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Instant.Instant(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDate(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setTime(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterManager.getInstantConverters()</name>
                <outbound type="class" confirmed="yes">org.joda.time.convert.Converter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.iInstantConverters</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterSet</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.copyInto(org.joda.time.convert.Converter[])</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.size()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.InstantConverter</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterManager.getIntervalConverter(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <outbound type="feature" confirmed="no">java.lang.Class.getName()</outbound>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.getClass()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.Converter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.iIntervalConverters</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterSet</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.select(java.lang.Class)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.IntervalConverter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterManager.getIntervalConverters()</name>
                <outbound type="class" confirmed="yes">org.joda.time.convert.Converter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.iIntervalConverters</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterSet</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.copyInto(org.joda.time.convert.Converter[])</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.size()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.IntervalConverter</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterManager.iDurationConverters</name>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterSet</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.ConverterManager()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.addDurationConverter(org.joda.time.convert.DurationConverter)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getDurationConverter(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getDurationConverters()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.removeDurationConverter(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.removeDurationConverter(org.joda.time.convert.DurationConverter)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterManager.iInstantConverters</name>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterSet</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.ConverterManager()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.addInstantConverter(org.joda.time.convert.InstantConverter)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstantConverter(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstantConverters()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.removeInstantConverter(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.removeInstantConverter(org.joda.time.convert.InstantConverter)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterManager.iIntervalConverters</name>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterSet</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.ConverterManager()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.addIntervalConverter(org.joda.time.convert.IntervalConverter)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getIntervalConverter(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getIntervalConverters()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.removeIntervalConverter(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.removeIntervalConverter(org.joda.time.convert.IntervalConverter)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterManager.removeDurationConverter(int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.convert.Converter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.iDurationConverters</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterSet</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.remove(int, org.joda.time.convert.Converter[])</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.DurationConverter</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterManager.removeDurationConverter(org.joda.time.convert.DurationConverter)</name>
                <outbound type="class" confirmed="yes">org.joda.time.convert.Converter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.iDurationConverters</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterSet</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.remove(org.joda.time.convert.Converter, org.joda.time.convert.Converter[])</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.DurationConverter</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterManager.removeInstantConverter(int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.convert.Converter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.iInstantConverters</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterSet</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.remove(int, org.joda.time.convert.Converter[])</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.InstantConverter</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterManager.removeInstantConverter(org.joda.time.convert.InstantConverter)</name>
                <outbound type="class" confirmed="yes">org.joda.time.convert.Converter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.iInstantConverters</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterSet</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.remove(org.joda.time.convert.Converter, org.joda.time.convert.Converter[])</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.InstantConverter</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterManager.removeIntervalConverter(int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.convert.Converter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.iIntervalConverters</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterSet</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.remove(int, org.joda.time.convert.Converter[])</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.IntervalConverter</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterManager.removeIntervalConverter(org.joda.time.convert.IntervalConverter)</name>
                <outbound type="class" confirmed="yes">org.joda.time.convert.Converter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.iIntervalConverters</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterSet</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.remove(org.joda.time.convert.Converter, org.joda.time.convert.Converter[])</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.IntervalConverter</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterManager.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.iDurationConverters</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.iInstantConverters</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.iIntervalConverters</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterSet</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.size()</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.convert.ConverterSet</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.ConverterManager()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.addDurationConverter(org.joda.time.convert.DurationConverter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.addInstantConverter(org.joda.time.convert.InstantConverter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.addIntervalConverter(org.joda.time.convert.IntervalConverter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getDurationConverter(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getDurationConverters()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstantConverter(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstantConverters()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getIntervalConverter(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getIntervalConverters()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.iDurationConverters</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.iInstantConverters</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.iIntervalConverters</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.removeDurationConverter(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.removeDurationConverter(org.joda.time.convert.DurationConverter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.removeInstantConverter(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.removeInstantConverter(org.joda.time.convert.InstantConverter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.removeIntervalConverter(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.removeIntervalConverter(org.joda.time.convert.IntervalConverter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.toString()</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterSet.ConverterSet(org.joda.time.convert.Converter[])</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.Converter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterSet$Entry</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.iConverters</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.iSelectEntries</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.ConverterManager()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.add(org.joda.time.convert.Converter, org.joda.time.convert.Converter[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.remove(int, org.joda.time.convert.Converter[])</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterSet.add(org.joda.time.convert.Converter, org.joda.time.convert.Converter[])</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException()</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.equals(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.Converter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.Converter.getSupportedType()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.ConverterSet(org.joda.time.convert.Converter[])</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.iConverters</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.addDurationConverter(org.joda.time.convert.DurationConverter)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.addInstantConverter(org.joda.time.convert.InstantConverter)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.addIntervalConverter(org.joda.time.convert.IntervalConverter)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterSet.copyInto(org.joda.time.convert.Converter[])</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.Converter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.iConverters</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getDurationConverters()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstantConverters()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getIntervalConverters()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterSet.iConverters</name>
                <outbound type="class" confirmed="yes">org.joda.time.convert.Converter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.ConverterSet(org.joda.time.convert.Converter[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.add(org.joda.time.convert.Converter, org.joda.time.convert.Converter[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.copyInto(org.joda.time.convert.Converter[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.remove(int, org.joda.time.convert.Converter[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.remove(org.joda.time.convert.Converter, org.joda.time.convert.Converter[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.selectSlow(org.joda.time.convert.ConverterSet, java.lang.Class)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.size()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterSet.iSelectEntries</name>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterSet$Entry</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.ConverterSet(org.joda.time.convert.Converter[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.select(java.lang.Class)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterSet.remove(int, org.joda.time.convert.Converter[])</name>
                <outbound type="feature" confirmed="no">java.lang.IndexOutOfBoundsException.IndexOutOfBoundsException()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.Converter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.ConverterSet(org.joda.time.convert.Converter[])</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.iConverters</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.removeDurationConverter(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.removeInstantConverter(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.removeIntervalConverter(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.remove(org.joda.time.convert.Converter, org.joda.time.convert.Converter[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.selectSlow(org.joda.time.convert.ConverterSet, java.lang.Class)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterSet.remove(org.joda.time.convert.Converter, org.joda.time.convert.Converter[])</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.equals(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.Converter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.iConverters</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.remove(int, org.joda.time.convert.Converter[])</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.removeDurationConverter(org.joda.time.convert.DurationConverter)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.removeInstantConverter(org.joda.time.convert.InstantConverter)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.removeIntervalConverter(org.joda.time.convert.IntervalConverter)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterSet.select(java.lang.Class)</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <outbound type="class" confirmed="no">java.lang.IllegalStateException</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.clone()</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.hashCode()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.Converter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.ConverterSet$Entry</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet$Entry.ConverterSet$Entry(java.lang.Class, org.joda.time.convert.Converter)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet$Entry.iConverter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet$Entry.iType</outbound>
                <outbound type="class" confirmed="no">org.joda.time.convert.ConverterSet$Entry[]</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.iSelectEntries</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.selectSlow(org.joda.time.convert.ConverterSet, java.lang.Class)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getDurationConverter(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstantConverter(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getIntervalConverter(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterSet.selectSlow(org.joda.time.convert.ConverterSet, java.lang.Class)</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <outbound type="feature" confirmed="no">java.lang.Class.getName()</outbound>
                <outbound type="feature" confirmed="no">java.lang.Class.isAssignableFrom(java.lang.Class)</outbound>
                <outbound type="feature" confirmed="no">java.lang.IllegalStateException.IllegalStateException(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.getClass()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.Converter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.Converter.getSupportedType()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.iConverters</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.remove(int, org.joda.time.convert.Converter[])</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.select(java.lang.Class)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterSet.size()</name>
                <outbound type="class" confirmed="yes">org.joda.time.convert.Converter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.iConverters</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getDurationConverters()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstantConverters()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getIntervalConverters()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.toString()</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.convert.ConverterSet$Entry</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.ConverterSet(org.joda.time.convert.Converter[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.iSelectEntries</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.select(java.lang.Class)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterSet$Entry.ConverterSet$Entry(java.lang.Class, org.joda.time.convert.Converter)</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.convert.Converter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet$Entry.iConverter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet$Entry.iType</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.select(java.lang.Class)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterSet$Entry.iConverter</name>
                <outbound type="class" confirmed="yes">org.joda.time.convert.Converter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet$Entry.ConverterSet$Entry(java.lang.Class, org.joda.time.convert.Converter)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.select(java.lang.Class)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ConverterSet$Entry.iType</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet$Entry.ConverterSet$Entry(java.lang.Class, org.joda.time.convert.Converter)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.select(java.lang.Class)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>org.joda.time.convert.ConverterSet$Entry[]</name>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterSet.select(java.lang.Class)</inbound>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.convert.DateConverter</name>
            <outbound type="class" confirmed="yes">org.joda.time.convert.AbstractConverter</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.convert.InstantConverter</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.ConverterManager()</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.convert.DateConverter.DateConverter()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.AbstractConverter()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.DateConverter.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.DateConverter.INSTANCE</name>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.ConverterManager()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.DateConverter.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.DateConverter.class$(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <outbound type="feature" confirmed="no">java.lang.Class.forName(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.ClassNotFoundException</outbound>
                <outbound type="feature" confirmed="no">java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.Throwable.getMessage()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.DateConverter.getSupportedType()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.DateConverter.class$java$util$Date</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.DateConverter.getSupportedType()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.DateConverter.getInstantMillis(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.util.Date</outbound>
                <outbound type="feature" confirmed="no">java.util.Date.getTime()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.DateConverter.getSupportedType()</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.DateConverter.class$(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.DateConverter.class$java$util$Date</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.DateConverter.static {}</name>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.DateConverter.DateConverter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.DateConverter.INSTANCE</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.convert.DurationConverter</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.convert.Converter</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.add(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.add(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.add(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.addDurationConverter(org.joda.time.convert.DurationConverter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getDurationConverter(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getDurationConverters()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.removeDurationConverter(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.removeDurationConverter(org.joda.time.convert.DurationConverter)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.convert.LongConverter</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.convert.ReadableDurationConverter</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.convert.StringConverter</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.convert.DurationConverter.getDurationMillis(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.add(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.add(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.add(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.DurationConverter.getDurationType(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.DurationConverter.isPrecise(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.DurationConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableDuration</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.AbstractDuration(org.joda.time.DurationType, java.lang.Object)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.convert.InstantConverter</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.convert.Converter</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.setMillis(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.setMillis(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.getMillisFromObject(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Instant.Instant(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDate(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setTime(java.lang.Object)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.convert.CalendarConverter</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.addInstantConverter(org.joda.time.convert.InstantConverter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstantConverter(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getInstantConverters()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.removeInstantConverter(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.removeInstantConverter(org.joda.time.convert.InstantConverter)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.convert.DateConverter</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.convert.LongConverter</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.convert.ReadableInstantConverter</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.convert.StringConverter</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.convert.InstantConverter.getChronology(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.InstantConverter.getChronology(java.lang.Object, org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object, org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.InstantConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.InstantConverter.getInstantMillis(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.setMillis(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.setMillis(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeComparator.getMillisFromObject(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Instant.Instant(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setDate(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.setTime(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.InstantConverter.getInstantMillis(java.lang.Object, org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.AbstractPartialInstant(java.lang.Object, org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.InstantConverter.getInstantMillis(java.lang.Object, org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.AbstractDateTime(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.convert.IntervalConverter</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.convert.Converter</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.addIntervalConverter(org.joda.time.convert.IntervalConverter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getIntervalConverter(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.getIntervalConverters()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.removeIntervalConverter(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.removeIntervalConverter(org.joda.time.convert.IntervalConverter)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.convert.StringConverter</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.convert.IntervalConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInterval</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.AbstractInterval(java.lang.Object)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.convert.LongConverter</name>
            <outbound type="class" confirmed="yes">org.joda.time.convert.AbstractConverter</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.convert.DurationConverter</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.convert.InstantConverter</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.ConverterManager()</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.convert.LongConverter.INSTANCE</name>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.ConverterManager()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.LongConverter.LongConverter()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.AbstractConverter()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.LongConverter.class$(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <outbound type="feature" confirmed="no">java.lang.Class.forName(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.ClassNotFoundException</outbound>
                <outbound type="feature" confirmed="no">java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.Throwable.getMessage()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.getSupportedType()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.LongConverter.class$java$lang$Long</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.getSupportedType()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.LongConverter.getDurationMillis(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Long</outbound>
                <outbound type="feature" confirmed="no">java.lang.Long.longValue()</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.LongConverter.getDurationType(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.getAverageYearMonthType()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.LongConverter.getInstantMillis(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Long</outbound>
                <outbound type="feature" confirmed="no">java.lang.Long.longValue()</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.LongConverter.getSupportedType()</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.class$(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.class$java$lang$Long</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.LongConverter.isPrecise(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.LongConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Long</outbound>
                <outbound type="feature" confirmed="no">java.lang.Long.longValue()</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadWritableDuration.setTotalMillis(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.LongConverter.static {}</name>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.INSTANCE</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.LongConverter.LongConverter()</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.convert.PartialInstantConverter</name>
            <outbound type="class" confirmed="yes">org.joda.time.convert.ReadableInstantConverter</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.ConverterManager()</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.convert.PartialInstantConverter.INSTANCE</name>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.ConverterManager()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.PartialInstantConverter.PartialInstantConverter()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.ReadableInstantConverter()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.PartialInstantConverter.class$(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <outbound type="feature" confirmed="no">java.lang.Class.forName(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.ClassNotFoundException</outbound>
                <outbound type="feature" confirmed="no">java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.Throwable.getMessage()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.getSupportedType()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.PartialInstantConverter.class$org$joda$time$PartialInstant</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.getSupportedType()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.PartialInstantConverter.getChronology(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.withDateTimeZone(org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.PartialInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.PartialInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.PartialInstantConverter.getInstantMillis(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.getInstantMillis(java.lang.Object, org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.PartialInstantConverter.getInstantMillis(java.lang.Object, org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeZone()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffsetFromLocal(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.PartialInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.PartialInstant.getMillis()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.PartialInstantConverter.getInstantMillis(java.lang.Object, org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefault()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffsetFromLocal(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.PartialInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.PartialInstant.getMillis()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.getInstantMillis(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.PartialInstantConverter.getSupportedType()</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.class$(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.class$org$joda$time$PartialInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.PartialInstantConverter.static {}</name>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.INSTANCE</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.PartialInstantConverter()</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.convert.ReadableDurationConverter</name>
            <outbound type="class" confirmed="yes">org.joda.time.convert.AbstractConverter</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.convert.DurationConverter</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.ConverterManager()</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ReadableDurationConverter.INSTANCE</name>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.ConverterManager()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ReadableDurationConverter.ReadableDurationConverter()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.AbstractConverter()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ReadableDurationConverter.class$(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <outbound type="feature" confirmed="no">java.lang.Class.forName(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.ClassNotFoundException</outbound>
                <outbound type="feature" confirmed="no">java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.Throwable.getMessage()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.getSupportedType()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ReadableDurationConverter.class$org$joda$time$ReadableDuration</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.getSupportedType()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ReadableDurationConverter.getDurationMillis(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getTotalMillis()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ReadableDurationConverter.getDurationType(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getDurationType()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ReadableDurationConverter.getSupportedType()</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.class$(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.class$org$joda$time$ReadableDuration</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ReadableDurationConverter.isPrecise(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.isPrecise()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ReadableDurationConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadWritableDuration.setDuration(org.joda.time.ReadableDuration)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ReadableDurationConverter.static {}</name>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.INSTANCE</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ReadableDurationConverter.ReadableDurationConverter()</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.convert.ReadableInstantConverter</name>
            <outbound type="class" confirmed="yes">org.joda.time.convert.AbstractConverter</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.convert.InstantConverter</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.ConverterManager()</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.convert.PartialInstantConverter</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ReadableInstantConverter.INSTANCE</name>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.ConverterManager()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ReadableInstantConverter.ReadableInstantConverter()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.AbstractConverter()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.PartialInstantConverter.PartialInstantConverter()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ReadableInstantConverter.class$(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <outbound type="feature" confirmed="no">java.lang.Class.forName(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.ClassNotFoundException</outbound>
                <outbound type="feature" confirmed="no">java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.Throwable.getMessage()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.getSupportedType()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ReadableInstantConverter.class$org$joda$time$ReadableInstant</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.getSupportedType()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ReadableInstantConverter.getChronology(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ReadableInstantConverter.getChronology(java.lang.Object, org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeZone()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.withDateTimeZone(org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ReadableInstantConverter.getInstantMillis(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ReadableInstantConverter.getSupportedType()</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.class$(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.class$org$joda$time$ReadableInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ReadableInstantConverter.static {}</name>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.INSTANCE</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ReadableInstantConverter.ReadableInstantConverter()</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.convert.ReadableIntervalConverter</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.convert.DurationConverter</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.convert.IntervalConverter</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.ConverterManager()</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ReadableIntervalConverter.INSTANCE</name>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.ConverterManager()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ReadableIntervalConverter.ReadableIntervalConverter()</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ReadableIntervalConverter.class$(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <outbound type="feature" confirmed="no">java.lang.Class.forName(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.ClassNotFoundException</outbound>
                <outbound type="feature" confirmed="no">java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.Throwable.getMessage()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.getSupportedType()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ReadableIntervalConverter.class$org$joda$time$ReadableInterval</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.getSupportedType()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ReadableIntervalConverter.getDurationMillis(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInterval</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInterval.getDurationMillis()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ReadableIntervalConverter.getDurationType(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.getDurationType()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Duration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInterval</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInterval.getDuration()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ReadableIntervalConverter.getSupportedType()</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.class$(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.class$org$joda$time$ReadableInterval</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ReadableIntervalConverter.isPrecise(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ReadableIntervalConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadWritableDuration.setTotalMillis(long, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInterval</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInterval.getEndMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInterval.getStartMillis()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ReadableIntervalConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInterval</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadWritableInterval.setEndMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadWritableInterval.setStartMillis(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInterval</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInterval.getEndMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInterval.getStartMillis()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.ReadableIntervalConverter.static {}</name>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.INSTANCE</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.ReadableIntervalConverter.ReadableIntervalConverter()</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.convert.StringConverter</name>
            <outbound type="class" confirmed="yes">org.joda.time.convert.AbstractConverter</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.convert.DurationConverter</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.convert.InstantConverter</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.convert.IntervalConverter</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.ConverterManager()</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.convert.StringConverter.INSTANCE</name>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.ConverterManager.ConverterManager()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.StringConverter.StringConverter()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.AbstractConverter()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.StringConverter.class$(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <outbound type="feature" confirmed="no">java.lang.Class.forName(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.ClassNotFoundException</outbound>
                <outbound type="feature" confirmed="no">java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.Throwable.getMessage()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getSupportedType()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.StringConverter.class$java$lang$String</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getSupportedType()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.StringConverter.getDurationMillis(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.lang.UnsupportedOperationException.UnsupportedOperationException()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.StringConverter.getDurationType(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.indexOf(int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.getYearMonthType()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.getYearWeekType()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.StringConverter.getInstantMillis(java.lang.Object, org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.AbstractConverter.getChronology(java.lang.Object, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseMillis(java.lang.String)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.ISODateTimeFormat</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTimeParser()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance(org.joda.time.Chronology)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.StringConverter.getInstantMillis(java.lang.Object, org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseMillis(java.lang.String)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.ISODateTimeFormat</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTimeParser()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance(org.joda.time.Chronology)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.StringConverter.getSupportedType()</name>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.class$(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.class$java$lang$String</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.StringConverter.isPrecise(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.MutableDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getDurationType()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationParser.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationParser.parseMutableDuration(org.joda.time.DurationType, java.lang.String)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.ISODurationFormat</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.getInstance()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.standard()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException()</outbound>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.charAt(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.indexOf(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.substring(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.substring(int, int)</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Duration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInterval</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadWritableInterval.setDurationAfterStart(org.joda.time.ReadableDuration)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadWritableInterval.setDurationBeforeEnd(org.joda.time.ReadableDuration)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadWritableInterval.setEndMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadWritableInterval.setStartMillis(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getDurationType(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseMillis(java.lang.String)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationParser.parseDuration(org.joda.time.DurationType, java.lang.String)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.ISODateTimeFormat</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTimeParser()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstanceUTC()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.ISODurationFormat</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.getInstance()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.standard()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.convert.StringConverter.static {}</name>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.INSTANCE</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.StringConverter()</outbound>
            </feature>
        </class>
    </package>
    <package confirmed="yes">
        <name>org.joda.time.field</name>
        <class confirmed="yes">
            <name>org.joda.time.field.AbstractDateTimeField</name>
            <outbound type="class" confirmed="no">java.io.Serializable</outbound>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.DecoratedDateTimeField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.AbstractDateTimeField(java.lang.String)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.iName</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.BuddhistEraDateTimeField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.CopticEraDateTimeField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$CutoverField.GJChronology$CutoverField(org.joda.time.chrono.GJChronology, org.joda.time.DateTimeField, org.joda.time.DateTimeField, long, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.GJEraDateTimeField(org.joda.time.chrono.AbstractGJChronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.ZonedChronology$ZonedDateTimeField(org.joda.time.DateTimeField, org.joda.time.DateTimeZone, org.joda.time.DurationField, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.DecoratedDateTimeField(org.joda.time.DateTimeField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.ImpreciseDateTimeField(java.lang.String, java.lang.String, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.PreciseDurationDateTimeField(java.lang.String, org.joda.time.DurationField)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.add(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getDurationField()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.add(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.add(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getDurationField()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.add(long, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.addWrapped(long, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getMaximumValue(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getMinimumValue(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.getWrappedValue(int, int, int, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.get(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getAsText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.roundHalfEven(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.getAsShortText(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getAsShortText(long, java.util.Locale)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.getAsShortText(long, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getAsText(long, java.util.Locale)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getAsShortText(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.getAsText(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getAsText(long, java.util.Locale)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.getAsText(long, java.util.Locale)</name>
                <outbound type="feature" confirmed="no">java.lang.Integer.toString(int)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.get(long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getAsText(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.getDifference(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getDifference(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getDurationField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.getDifferenceAsLong(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getDifferenceAsLong(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getDurationField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.getDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getDifferenceAsLong(long, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.getLeapAmount(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.getLeapDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.getMaximumShortTextLength(java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getMaximumTextLength(java.util.Locale)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.getMaximumTextLength(java.util.Locale)</name>
                <outbound type="feature" confirmed="no">java.lang.Integer.toString(int)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getMaximumValue()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getMaximumShortTextLength(java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.getMaximumValue()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getMaximumValue(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.getMaximumValue(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getMaximumValue()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.getMaximumValueForSet(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.getMinimumValue()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getMinimumValue(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.getMinimumValue(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getMinimumValue()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.addWrapped(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.getName()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.iName</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.getRangeDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.iName</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.AbstractDateTimeField(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getName()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.isLeap(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.isLenient()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.isSupported()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.remainder(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.roundFloor(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.roundCeiling(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.roundFloor(long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.roundHalfCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.roundHalfEven(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.roundHalfFloor(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.roundFloor(long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.remainder(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.roundHalfCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.roundHalfEven(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.roundHalfFloor(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.roundHalfCeiling(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.roundCeiling(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.roundFloor(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.roundHalfEven(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.roundCeiling(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.roundFloor(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.roundHalfFloor(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.roundCeiling(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.roundFloor(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.set(long, int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.set(long, java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.set(long, java.lang.String, java.util.Locale)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.set(long, java.lang.String, java.util.Locale)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Integer.parseInt(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.NumberFormatException</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getName()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.set(long, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.set(long, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDateTimeField.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getName()</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.field.AbstractDurationField</name>
            <outbound type="class" confirmed="no">java.io.Serializable</outbound>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.DecoratedDurationField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.PreciseDurationField</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDurationField.AbstractDurationField(java.lang.String)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.iName</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ZonedChronology$ZonedDurationField.ZonedChronology$ZonedDurationField(org.joda.time.DurationField, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.DecoratedDurationField(org.joda.time.DurationField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.ImpreciseDateTimeField$LinkedDurationField(org.joda.time.field.ImpreciseDateTimeField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationField.PreciseDurationField(java.lang.String, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDurationField.add(long, int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDurationField.add(long, long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDurationField.compareTo(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getUnitMillis()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDurationField.getDifference(long, long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getDifferenceAsLong(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.safeToInt(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDurationField.getDifferenceAsLong(long, long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDurationField.getMillis(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getUnitMillis()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDurationField.getMillis(int, long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDurationField.getMillis(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getUnitMillis()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDurationField.getMillis(long, long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDurationField.getName()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.iName</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDurationField.getUnitMillis()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDurationField.getValue(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.getValueAsLong(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.safeToInt(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDurationField.getValue(long, long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getValueAsLong(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.safeToInt(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDurationField.getValueAsLong(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getUnitMillis()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.getValue(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDurationField.getValueAsLong(long, long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDurationField.iName</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.AbstractDurationField(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.getName()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDurationField.isPrecise()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDurationField.isSupported()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDurationField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.AbstractDurationField.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.getName()</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.field.DecoratedDateTimeField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.AbstractDateTimeField</outbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.DividedDateTimeField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.NonZeroDateTimeField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.OffsetDateTimeField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.RemainderDateTimeField</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.field.DecoratedDateTimeField.DecoratedDateTimeField(org.joda.time.DateTimeField, java.lang.String)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.isSupported()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.AbstractDateTimeField(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.iField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.GJYearOfEraDateTimeField(org.joda.time.DateTimeField, org.joda.time.chrono.AbstractGJChronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.ISOYearOfEraDateTimeField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.LimitChronology$LimitDateTimeField(org.joda.time.chrono.LimitChronology, org.joda.time.DateTimeField, org.joda.time.DurationField, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.DateTimeField, java.lang.String, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.field.RemainderDateTimeField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.NonZeroDateTimeField(org.joda.time.DateTimeField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(org.joda.time.DateTimeField, java.lang.String, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(org.joda.time.DateTimeField, java.lang.String, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(org.joda.time.field.DividedDateTimeField, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DecoratedDateTimeField.get(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.iField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.get(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DecoratedDateTimeField.getDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDurationField()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DecoratedDateTimeField.getMaximumValue()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMaximumValue()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DecoratedDateTimeField.getMinimumValue()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMinimumValue()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DecoratedDateTimeField.getRangeDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getRangeDurationField()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DecoratedDateTimeField.getWrappedField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.iField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.getMaximumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.remainder(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.getMaximumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.remainder(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getAsText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getLeapAmount(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getMaximumShortTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.getMinimumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.remainder(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundHalfCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundHalfEven(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.roundHalfFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.field.RemainderDateTimeField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.remainder(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.getLeapAmount(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.getLeapDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.getMaximumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.remainder(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.roundHalfCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.roundHalfEven(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.roundHalfFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.getLeapAmount(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.getLeapDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.remainder(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.roundHalfCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.roundHalfEven(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.roundHalfFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(org.joda.time.field.DividedDateTimeField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.remainder(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.roundHalfCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.roundHalfEven(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.roundHalfFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DecoratedDateTimeField.iField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.DecoratedDateTimeField(org.joda.time.DateTimeField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getMaximumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getMinimumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getRangeDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.isLenient()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DecoratedDateTimeField.isLenient()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.isLenient()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DecoratedDateTimeField.roundFloor(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundFloor(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DecoratedDateTimeField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DecoratedDateTimeField.set(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.iField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.set(long, int)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.field.DecoratedDurationField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.AbstractDurationField</outbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.GJChronology$LinkedDurationField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.ScaledDurationField</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.field.DecoratedDurationField.DecoratedDurationField(org.joda.time.DurationField, java.lang.String)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isSupported()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.AbstractDurationField(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.iField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology$LinkedDurationField.GJChronology$LinkedDurationField(org.joda.time.DurationField, org.joda.time.chrono.GJChronology$ImpreciseCutoverField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.LimitChronology$LimitDurationField(org.joda.time.chrono.LimitChronology, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.ScaledDurationField(org.joda.time.DurationField, java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DecoratedDurationField.add(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DecoratedDurationField.add(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DecoratedDurationField.getDifferenceAsLong(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getDifferenceAsLong(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DecoratedDurationField.getMillis(int, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getMillis(int, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DecoratedDurationField.getMillis(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getMillis(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DecoratedDurationField.getUnitMillis()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getUnitMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DecoratedDurationField.getValueAsLong(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getValueAsLong(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DecoratedDurationField.getWrappedField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.iField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getMillis(int, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getMillis(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getValue(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitDurationField.getValueAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getMillis(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getMillis(int, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getMillis(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getUnitMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getValue(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getValueAsLong(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getValueAsLong(long, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DecoratedDurationField.iField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.DecoratedDurationField(org.joda.time.DurationField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getMillis(int, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getMillis(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getUnitMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getValueAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getWrappedField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.isPrecise()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DecoratedDurationField.isPrecise()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isPrecise()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DecoratedDurationField.serialVersionUID</name>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.field.DelegatedDateTimeField</name>
            <outbound type="class" confirmed="no">java.io.Serializable</outbound>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.JulianChronology$NoYearZeroField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.LenientDateTimeField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.StrictDateTimeField</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.DelegatedDateTimeField(org.joda.time.DateTimeField)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.DelegatedDateTimeField(org.joda.time.DateTimeField, java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoYearZeroField.JulianChronology$NoYearZeroField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.LenientDateTimeField.LenientDateTimeField(org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.StrictDateTimeField.StrictDateTimeField(org.joda.time.DateTimeField)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.DelegatedDateTimeField(org.joda.time.DateTimeField, java.lang.String)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iName</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.DelegatedDateTimeField(org.joda.time.DateTimeField)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.add(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.LenientDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.add(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.addWrapped(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.addWrapped(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.get(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoYearZeroField.get(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.getAsShortText(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getAsShortText(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.getAsShortText(long, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getAsShortText(long, java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.getAsText(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getAsText(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.getAsText(long, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getAsText(long, java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.getDifference(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDifference(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.getDifferenceAsLong(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDifferenceAsLong(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.getDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDurationField()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.getLeapAmount(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getLeapAmount(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.getLeapDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getLeapDurationField()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.getMaximumShortTextLength(java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMaximumShortTextLength(java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.getMaximumTextLength(java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMaximumTextLength(java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.getMaximumValue()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMaximumValue()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoYearZeroField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.getMaximumValue(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMaximumValue(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.LenientDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.StrictDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.getMinimumValue()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMinimumValue()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoYearZeroField.JulianChronology$NoYearZeroField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DateTimeField)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.getMinimumValue(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMinimumValue(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.LenientDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.StrictDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.getName()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getName()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iName</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.getRangeDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getRangeDurationField()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.getWrappedField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.LenientDateTimeField.getInstance(org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.StrictDateTimeField.getInstance(org.joda.time.DateTimeField)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.iField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.DelegatedDateTimeField(org.joda.time.DateTimeField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getAsShortText(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getAsText(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getAsText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getLeapAmount(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getLeapDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getMaximumShortTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getMaximumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getMinimumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getMinimumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getName()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getRangeDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getWrappedField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.isLenient()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.isSupported()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.remainder(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.roundHalfCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.roundHalfEven(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.roundHalfFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.set(long, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.iName</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.DelegatedDateTimeField(org.joda.time.DateTimeField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getName()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.isLeap(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.isLeap(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.isLenient()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.isLenient()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.isSupported()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.isSupported()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.remainder(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.remainder(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.roundCeiling(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundCeiling(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.roundFloor(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundFloor(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.roundHalfCeiling(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundHalfCeiling(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.roundHalfEven(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundHalfEven(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.roundHalfFloor(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundHalfFloor(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.set(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoYearZeroField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.LenientDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.StrictDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.set(long, java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.set(long, java.lang.String, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, java.lang.String, java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDateTimeField.toString()</name>
                <outbound type="feature" confirmed="no">java.lang.Object.toString()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.iName</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.field.DelegatedDurationField</name>
            <outbound type="class" confirmed="no">java.io.Serializable</outbound>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDurationField.DelegatedDurationField(org.joda.time.DurationField)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.DelegatedDurationField(org.joda.time.DurationField, java.lang.String)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDurationField.DelegatedDurationField(org.joda.time.DurationField, java.lang.String)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.iName</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.DelegatedDurationField(org.joda.time.DurationField)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDurationField.add(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDurationField.add(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDurationField.compareTo(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.compareTo(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDurationField.getDifference(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getDifference(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDurationField.getDifferenceAsLong(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getDifferenceAsLong(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDurationField.getMillis(int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getMillis(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDurationField.getMillis(int, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getMillis(int, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDurationField.getMillis(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDurationField.getMillis(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getMillis(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDurationField.getName()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getName()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.iName</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDurationField.getUnitMillis()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getUnitMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDurationField.getValue(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getValue(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDurationField.getValue(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getValue(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDurationField.getValueAsLong(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getValueAsLong(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDurationField.getValueAsLong(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getValueAsLong(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDurationField.getWrappedField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDurationField.iField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.DelegatedDurationField(org.joda.time.DurationField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.compareTo(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getMillis(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getMillis(int, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getMillis(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getName()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getUnitMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getValue(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getValueAsLong(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getValueAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getWrappedField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.isPrecise()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.isSupported()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDurationField.iName</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.DelegatedDurationField(org.joda.time.DurationField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.getName()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDurationField.isPrecise()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isPrecise()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDurationField.isSupported()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isSupported()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDurationField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DelegatedDurationField.toString()</name>
                <outbound type="feature" confirmed="no">java.lang.Object.toString()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDurationField.iName</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.field.DividedDateTimeField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.DecoratedDateTimeField</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(org.joda.time.field.DividedDateTimeField, java.lang.String)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.DateTimeField, java.lang.String, java.lang.String, int)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDurationField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMaximumValue()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMinimumValue()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.DecoratedDateTimeField(org.joda.time.DateTimeField, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.iDivisor</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.iDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.iMax</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.iMin</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.ScaledDurationField(org.joda.time.DurationField, java.lang.String, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.field.RemainderDateTimeField, java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMaximumValue()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMinimumValue()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.DecoratedDateTimeField(org.joda.time.DateTimeField, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.iDivisor</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.iDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.iMax</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.iMin</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.RemainderDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.iDivisor</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.iRangeField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DividedDateTimeField.add(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.iDivisor</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DividedDateTimeField.add(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.iDivisor</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DividedDateTimeField.addWrapped(long, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.iMax</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.iMin</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.getWrappedValue(int, int, int, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DividedDateTimeField.get(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.iDivisor</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.remainder(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.roundFloor(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DividedDateTimeField.getDifference(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDifference(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.iDivisor</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DividedDateTimeField.getDifferenceAsLong(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDifferenceAsLong(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.iDivisor</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DividedDateTimeField.getDivisor()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.iDivisor</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DividedDateTimeField.getDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.iDurationField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DividedDateTimeField.getMaximumValue()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.iMax</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DividedDateTimeField.getMinimumValue()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.iMin</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DividedDateTimeField.getRemainder(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.iDivisor</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DividedDateTimeField.iDivisor</name>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.DateTimeField, java.lang.String, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.field.RemainderDateTimeField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.getDivisor()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.getRemainder(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(org.joda.time.field.DividedDateTimeField, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DividedDateTimeField.iDurationField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.DateTimeField, java.lang.String, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.field.RemainderDateTimeField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.getDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(org.joda.time.field.DividedDateTimeField, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DividedDateTimeField.iMax</name>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.DateTimeField, java.lang.String, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.field.RemainderDateTimeField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.getMaximumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DividedDateTimeField.iMin</name>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.DateTimeField, java.lang.String, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.field.RemainderDateTimeField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.getMinimumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DividedDateTimeField.remainder(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.remainder(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.set(long, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DividedDateTimeField.roundFloor(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundFloor(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.iDivisor</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DividedDateTimeField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.DividedDateTimeField.set(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.getRemainder(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.iDivisor</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.iMax</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.iMin</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeField, int, int, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.remainder(long)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.field.FieldUtils</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.field.FieldUtils.FieldUtils()</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.FieldUtils.getWrappedValue(int, int, int)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.getWrappedValue(int, int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.FieldUtils.getWrappedValue(int, int, int, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.getWrappedValue(int, int, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.addWrapped(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.FieldUtils.safeAdd(long, long)</name>
                <outbound type="feature" confirmed="no">java.lang.ArithmeticException.ArithmeticException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(long)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.FieldUtils.safeMultiply(long, long)</name>
                <outbound type="feature" confirmed="no">java.lang.ArithmeticException.ArithmeticException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(long)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.FieldUtils.safeToInt(long)</name>
                <outbound type="feature" confirmed="no">java.lang.ArithmeticException.ArithmeticException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(long)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.getValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.getValue(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.MillisDurationField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.MillisDurationField.getValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.MillisDurationField.getValue(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.getDifference(long, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.FieldUtils.verifyValueBounds(java.lang.String, int, int, int)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateOnlyMillis(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getDateTimeMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.getTimeOnlyMillis(int, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.getDateOnlyMillis(int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeField, int, int, int)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getName()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearOfEraDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOYearOfEraDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.JulianChronology$NoYearZeroField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.StrictDateTimeField.set(long, int)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.field.ImpreciseDateTimeField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.AbstractDateTimeField</outbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.ImpreciseDateTimeField$LinkedDurationField(org.joda.time.field.ImpreciseDateTimeField, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.add(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.add(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getDifference(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getDifferenceAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getMillis(int, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getMillis(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getUnitMillis()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getValue(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getValueAsLong(long, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.this$0</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.field.ImpreciseDateTimeField.ImpreciseDateTimeField(java.lang.String, java.lang.String, long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.AbstractDateTimeField(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.ImpreciseDateTimeField$LinkedDurationField(org.joda.time.field.ImpreciseDateTimeField, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.iDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.iUnitMillis</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.CopticYearDateTimeField(org.joda.time.chrono.AbstractGJChronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.GJMonthOfYearDateTimeField(org.joda.time.chrono.AbstractGJChronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.GJWeekyearDateTimeField(org.joda.time.chrono.AbstractGJChronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.GJYearDateTimeField(org.joda.time.chrono.AbstractGJChronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ImpreciseDateTimeField.add(long, int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getMillis(int, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ImpreciseDateTimeField.add(long, long)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getMillis(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.getDifferenceAsLong(long, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ImpreciseDateTimeField.get(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ImpreciseDateTimeField.getDifference(long, long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.safeToInt(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.getDifferenceAsLong(long, long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticYearDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJMonthOfYearDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekyearDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJYearDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getValue(long, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ImpreciseDateTimeField.getDifferenceAsLong(long, long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.add(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.iUnitMillis</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getValueAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.getDifference(long, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ImpreciseDateTimeField.getDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.iDurationField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ImpreciseDateTimeField.getDurationUnitMillis()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.iUnitMillis</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ImpreciseDateTimeField.getRangeDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ImpreciseDateTimeField.iDurationField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.ImpreciseDateTimeField(java.lang.String, java.lang.String, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.getDurationField()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ImpreciseDateTimeField.iUnitMillis</name>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getUnitMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.ImpreciseDateTimeField(java.lang.String, java.lang.String, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.getDurationUnitMillis()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ImpreciseDateTimeField.roundFloor(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ImpreciseDateTimeField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ImpreciseDateTimeField.set(long, int)</name>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.AbstractDurationField</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.ImpreciseDateTimeField$LinkedDurationField(org.joda.time.field.ImpreciseDateTimeField, java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.AbstractDurationField(java.lang.String)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.this$0</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.ImpreciseDateTimeField(java.lang.String, java.lang.String, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.add(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.add(long, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.add(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.add(long, long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getDifference(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.getDifference(long, long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getDifferenceAsLong(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.getDifferenceAsLong(long, long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getMillis(int, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.add(long, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getMillis(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.add(long, long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getUnitMillis()</name>
                <outbound type="class" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.iUnitMillis</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getValue(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.getDifference(long, long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getValueAsLong(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField.getDifferenceAsLong(long, long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.isPrecise()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.this$0</name>
                <outbound type="class" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.ImpreciseDateTimeField$LinkedDurationField(org.joda.time.field.ImpreciseDateTimeField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getMillis(int, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getMillis(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getUnitMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getValue(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getValueAsLong(long, long)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.field.LenientDateTimeField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.DelegatedDateTimeField</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.StrictDateTimeField.getInstance(org.joda.time.DateTimeField)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.field.LenientDateTimeField.LenientDateTimeField(org.joda.time.DateTimeField)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.DelegatedDateTimeField(org.joda.time.DateTimeField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.LenientDateTimeField.getInstance(org.joda.time.DateTimeField)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.LenientDateTimeField.getInstance(org.joda.time.DateTimeField)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.isLenient()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getWrappedField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.LenientDateTimeField.LenientDateTimeField(org.joda.time.DateTimeField)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.StrictDateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.convertField(org.joda.time.DateTimeField)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.LenientDateTimeField.isLenient()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.LenientDateTimeField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.LenientDateTimeField.set(long, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getMaximumValue(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getMinimumValue(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.set(long, int)</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.field.MillisDurationField</name>
            <outbound type="class" confirmed="no">java.io.Serializable</outbound>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.field.MillisDurationField.INSTANCE</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MillisType.millis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.MillisDurationField.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.MillisDurationField.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.MillisDurationField.MillisDurationField()</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.MillisDurationField.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.MillisDurationField.add(long, int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.MillisDurationField.add(long, long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.MillisDurationField.compareTo(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getUnitMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.MillisDurationField.getUnitMillis()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.MillisDurationField.getDifference(long, long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.safeToInt(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.MillisDurationField.getDifferenceAsLong(long, long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.MillisDurationField.getMillis(int)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.MillisDurationField.getMillis(int, long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.MillisDurationField.getMillis(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.MillisDurationField.getMillis(long, long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.MillisDurationField.getName()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.MillisDurationField.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.MillisDurationField.getUnitMillis()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.field.MillisDurationField.compareTo(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.MillisDurationField.getValue(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.safeToInt(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.MillisDurationField.getValue(long, long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.safeToInt(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.MillisDurationField.getValueAsLong(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.MillisDurationField.getValueAsLong(long, long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.MillisDurationField.isPrecise()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.MillisDurationField.isSupported()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.MillisDurationField.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.MillisDurationField.INSTANCE</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.MillisDurationField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.MillisDurationField.static {}</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.MillisDurationField.INSTANCE</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.MillisDurationField.MillisDurationField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.MillisDurationField.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.MillisDurationField.getName()</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.field.NonZeroDateTimeField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.DecoratedDateTimeField</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.field.NonZeroDateTimeField.NonZeroDateTimeField(org.joda.time.DateTimeField, java.lang.String)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMinimumValue()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.DecoratedDateTimeField(org.joda.time.DateTimeField, java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.NonZeroDateTimeField.add(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.NonZeroDateTimeField.add(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.NonZeroDateTimeField.addWrapped(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.addWrapped(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.NonZeroDateTimeField.get(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.getMaximumValue()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.NonZeroDateTimeField.getDifference(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDifference(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.NonZeroDateTimeField.getDifferenceAsLong(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDifferenceAsLong(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.NonZeroDateTimeField.getLeapAmount(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getLeapAmount(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.NonZeroDateTimeField.getLeapDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getLeapDurationField()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.NonZeroDateTimeField.getMaximumValue()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMaximumValue()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.NonZeroDateTimeField.getMaximumValue(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMaximumValue(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.NonZeroDateTimeField.getMinimumValue()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.NonZeroDateTimeField.getMinimumValue(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.NonZeroDateTimeField.isLeap(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.isLeap(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.NonZeroDateTimeField.remainder(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.remainder(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.NonZeroDateTimeField.roundCeiling(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundCeiling(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.NonZeroDateTimeField.roundFloor(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundFloor(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.NonZeroDateTimeField.roundHalfCeiling(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundHalfCeiling(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.NonZeroDateTimeField.roundHalfEven(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundHalfEven(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.NonZeroDateTimeField.roundHalfFloor(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundHalfFloor(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.NonZeroDateTimeField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.NonZeroDateTimeField.set(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeField, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.NonZeroDateTimeField.getMaximumValue()</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.field.OffsetDateTimeField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.DecoratedDateTimeField</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(org.joda.time.DateTimeField, java.lang.String, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(org.joda.time.DateTimeField, java.lang.String, int, int, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(org.joda.time.DateTimeField, java.lang.String, int, int, int)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMaximumValue()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMinimumValue()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.DecoratedDateTimeField(org.joda.time.DateTimeField, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.iMax</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.iMin</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.iOffset</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(org.joda.time.DateTimeField, java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.OffsetDateTimeField.add(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeField, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.iMax</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.iMin</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.OffsetDateTimeField.add(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.add(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeField, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.iMax</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.iMin</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.OffsetDateTimeField.addWrapped(long, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.getWrappedValue(int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.iMax</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.iMin</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.set(long, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.OffsetDateTimeField.get(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.iOffset</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.addWrapped(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.OffsetDateTimeField.getLeapAmount(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getLeapAmount(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.OffsetDateTimeField.getLeapDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getLeapDurationField()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.OffsetDateTimeField.getMaximumValue()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.iMax</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.OffsetDateTimeField.getMinimumValue()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.iMin</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.OffsetDateTimeField.getOffset()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.iOffset</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.OffsetDateTimeField.iMax</name>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(org.joda.time.DateTimeField, java.lang.String, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.getMaximumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.OffsetDateTimeField.iMin</name>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(org.joda.time.DateTimeField, java.lang.String, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.getMinimumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.OffsetDateTimeField.iOffset</name>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(org.joda.time.DateTimeField, java.lang.String, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.getOffset()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.OffsetDateTimeField.isLeap(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.isLeap(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.OffsetDateTimeField.remainder(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.remainder(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.OffsetDateTimeField.roundCeiling(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundCeiling(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.OffsetDateTimeField.roundFloor(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundFloor(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.OffsetDateTimeField.roundHalfCeiling(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundHalfCeiling(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.OffsetDateTimeField.roundHalfEven(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundHalfEven(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.OffsetDateTimeField.roundHalfFloor(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundHalfFloor(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.OffsetDateTimeField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.OffsetDateTimeField.set(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeField, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.iMax</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.iMin</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.iOffset</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.OffsetDateTimeField.addWrapped(long, int)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.field.PreciseDateTimeField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField</outbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$HalfdayField</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDateTimeField.PreciseDateTimeField(java.lang.String, org.joda.time.DurationField, org.joda.time.DurationField)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getUnitMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isPrecise()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.iRange</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.iRangeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.PreciseDurationDateTimeField(java.lang.String, org.joda.time.DurationField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.getUnitMillis()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$HalfdayField.AbstractGJChronology$HalfdayField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDateTimeField.addWrapped(long, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.getWrappedValue(int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.getMaximumValue()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.getMinimumValue()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.getUnitMillis()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDateTimeField.get(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.iRange</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.getUnitMillis()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$HalfdayField.getAsText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDateTimeField.getMaximumValue()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.iRange</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDateTimeField.getRange()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.iRange</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDateTimeField.getRangeDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.iRangeField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDateTimeField.iRange</name>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.PreciseDateTimeField(java.lang.String, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.getMaximumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.getRange()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDateTimeField.iRangeField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.PreciseDateTimeField(java.lang.String, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.getRangeDurationField()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDateTimeField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDateTimeField.set(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeField, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.getMaximumValue()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.getMinimumValue()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.iUnitMillis</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology$HalfdayField.set(long, java.lang.String, java.util.Locale)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.field.PreciseDurationDateTimeField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.AbstractDateTimeField</outbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.CopticDayOfMonthDateTimeField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.GJDayOfMonthDateTimeField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.GJDayOfYearDateTimeField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.field.PreciseDateTimeField</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDurationDateTimeField.PreciseDurationDateTimeField(java.lang.String, org.joda.time.DurationField)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getUnitMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isPrecise()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.AbstractDateTimeField(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.iUnitField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.iUnitMillis</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticDayOfMonthDateTimeField.CopticDayOfMonthDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.CopticMonthOfYearDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfMonthDateTimeField.GJDayOfMonthDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.GJDayOfWeekDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfYearDateTimeField.GJDayOfYearDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.GJWeekOfWeekyearDateTimeField(org.joda.time.chrono.AbstractGJChronology, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.PreciseDateTimeField(java.lang.String, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDurationDateTimeField.add(long, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.iUnitMillis</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDurationDateTimeField.add(long, long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.iUnitMillis</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDurationDateTimeField.getDifference(long, long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.safeToInt(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.getDifferenceAsLong(long, long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDurationDateTimeField.getDifferenceAsLong(long, long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.iUnitMillis</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.getDifference(long, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDurationDateTimeField.getDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.iUnitField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDurationDateTimeField.getMaximumValueForSet(long, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.getMaximumValue(long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDurationDateTimeField.getMinimumValue()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDurationDateTimeField.getUnitMillis()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.iUnitMillis</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.PreciseDateTimeField(java.lang.String, org.joda.time.DurationField, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.get(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDurationDateTimeField.iUnitField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.PreciseDurationDateTimeField(java.lang.String, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.getDurationField()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDurationDateTimeField.iUnitMillis</name>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.PreciseDurationDateTimeField(java.lang.String, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.getUnitMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.remainder(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDurationDateTimeField.isLenient()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDurationDateTimeField.remainder(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.iUnitMillis</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.remainder(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDurationDateTimeField.roundCeiling(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.iUnitMillis</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.roundCeiling(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDurationDateTimeField.roundFloor(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.iUnitMillis</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJWeekOfWeekyearDateTimeField.roundFloor(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDurationDateTimeField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDurationDateTimeField.set(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeField, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.getMaximumValueForSet(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.getMinimumValue()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationDateTimeField.iUnitMillis</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticMonthOfYearDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJDayOfWeekDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.field.PreciseDurationField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.AbstractDurationField</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDurationField.PreciseDurationField(java.lang.String, long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.AbstractDurationField.AbstractDurationField(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationField.iUnitMillis</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$AverageYearMonthType.DurationType$AverageYearMonthType(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticChronology.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDurationField.add(long, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationField.iUnitMillis</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDurationField.add(long, long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationField.iUnitMillis</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDurationField.getDifferenceAsLong(long, long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationField.iUnitMillis</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDurationField.getMillis(int, long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationField.iUnitMillis</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDurationField.getMillis(long, long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationField.iUnitMillis</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDurationField.getUnitMillis()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationField.iUnitMillis</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDurationField.getValueAsLong(long, long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationField.iUnitMillis</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDurationField.iUnitMillis</name>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationField.PreciseDurationField(java.lang.String, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationField.getMillis(int, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationField.getMillis(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationField.getUnitMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.PreciseDurationField.getValueAsLong(long, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDurationField.isPrecise()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.PreciseDurationField.serialVersionUID</name>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.field.RemainderDateTimeField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.DecoratedDateTimeField</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.field.RemainderDateTimeField, java.lang.String)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(org.joda.time.DateTimeField, java.lang.String, java.lang.String, int)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDurationField()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.DecoratedDateTimeField(org.joda.time.DateTimeField, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.iDivisor</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.iRangeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.ScaledDurationField(org.joda.time.DurationField, java.lang.String, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(org.joda.time.field.DividedDateTimeField, java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.DecoratedDateTimeField(org.joda.time.DateTimeField, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.DividedDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.iDivisor</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.iDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.iDivisor</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.iRangeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractGJChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.assemble(org.joda.time.chrono.AssembledChronology$Fields)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.RemainderDateTimeField.addWrapped(long, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.getWrappedValue(int, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.iDivisor</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.set(long, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.RemainderDateTimeField.get(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.iDivisor</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.addWrapped(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.RemainderDateTimeField.getDivided(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.iDivisor</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.RemainderDateTimeField.getDivisor()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.iDivisor</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.RemainderDateTimeField.getMaximumValue()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.iDivisor</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.RemainderDateTimeField.getMinimumValue()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.RemainderDateTimeField.getRangeDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.iRangeField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.RemainderDateTimeField.iDivisor</name>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.field.RemainderDateTimeField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(org.joda.time.DateTimeField, java.lang.String, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(org.joda.time.field.DividedDateTimeField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.getDivided(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.getDivisor()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.getMaximumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.set(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.RemainderDateTimeField.iRangeField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.field.RemainderDateTimeField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(org.joda.time.DateTimeField, java.lang.String, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(org.joda.time.field.DividedDateTimeField, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.getRangeDurationField()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.RemainderDateTimeField.remainder(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.remainder(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.RemainderDateTimeField.roundCeiling(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundCeiling(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.RemainderDateTimeField.roundFloor(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundFloor(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.RemainderDateTimeField.roundHalfCeiling(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundHalfCeiling(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.RemainderDateTimeField.roundHalfEven(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundHalfEven(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.RemainderDateTimeField.roundHalfFloor(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundHalfFloor(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.RemainderDateTimeField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.RemainderDateTimeField.set(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDateTimeField.getWrappedField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeField, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.getDivided(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.iDivisor</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.addWrapped(long, int)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.field.ScaledDurationField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.DecoratedDurationField</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.field.ScaledDurationField.ScaledDurationField(org.joda.time.DurationField, java.lang.String, int)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.DecoratedDurationField(org.joda.time.DurationField, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.iScalar</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearMonthType.DurationType$PreciseYearMonthType(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$PreciseYearWeekType.DurationType$PreciseYearWeekType(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.DividedDateTimeField.DividedDateTimeField(org.joda.time.DateTimeField, java.lang.String, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(org.joda.time.DateTimeField, java.lang.String, java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ScaledDurationField.add(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getWrappedField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.iScalar</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ScaledDurationField.add(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getWrappedField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.iScalar</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ScaledDurationField.getDifference(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getDifference(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getWrappedField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.iScalar</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ScaledDurationField.getDifferenceAsLong(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getDifferenceAsLong(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getWrappedField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.iScalar</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ScaledDurationField.getMillis(int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getMillis(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getWrappedField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.iScalar</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ScaledDurationField.getMillis(int, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getMillis(int, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getWrappedField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.iScalar</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ScaledDurationField.getMillis(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getWrappedField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.iScalar</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ScaledDurationField.getMillis(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getMillis(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getWrappedField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.iScalar</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ScaledDurationField.getScalar()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.iScalar</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ScaledDurationField.getUnitMillis()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getUnitMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getWrappedField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.iScalar</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ScaledDurationField.getValue(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getValue(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getWrappedField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.iScalar</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ScaledDurationField.getValue(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getValue(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getWrappedField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.iScalar</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ScaledDurationField.getValueAsLong(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getValueAsLong(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getWrappedField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.iScalar</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ScaledDurationField.getValueAsLong(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getValueAsLong(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DecoratedDurationField.getWrappedField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.iScalar</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ScaledDurationField.iScalar</name>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.ScaledDurationField(org.joda.time.DurationField, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getMillis(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getMillis(int, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getMillis(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getScalar()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getUnitMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getValue(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getValueAsLong(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.ScaledDurationField.getValueAsLong(long, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.ScaledDurationField.serialVersionUID</name>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.field.StrictDateTimeField</name>
            <outbound type="class" confirmed="yes">org.joda.time.field.DelegatedDateTimeField</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.LenientDateTimeField.getInstance(org.joda.time.DateTimeField)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.field.StrictDateTimeField.StrictDateTimeField(org.joda.time.DateTimeField)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.DelegatedDateTimeField(org.joda.time.DateTimeField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.StrictDateTimeField.getInstance(org.joda.time.DateTimeField)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.StrictDateTimeField.getInstance(org.joda.time.DateTimeField)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.isLenient()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getWrappedField()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.LenientDateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.StrictDateTimeField.StrictDateTimeField(org.joda.time.DateTimeField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.StrictChronology.convertField(org.joda.time.DateTimeField)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.StrictDateTimeField.isLenient()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.StrictDateTimeField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.StrictDateTimeField.set(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getMaximumValue(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.getMinimumValue(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.DelegatedDateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeField, int, int, int)</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.field.UnsupportedDateTimeField</name>
            <outbound type="class" confirmed="no">java.io.Serializable</outbound>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.centuryOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.clockhourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.clockhourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.dayOfMonth()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.dayOfWeek()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.dayOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.era()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.halfdayOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.hourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.hourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.millisOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.millisOfSecond()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.minuteOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.minuteOfHour()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.monthOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.secondOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.secondOfMinute()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.weekOfWeekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.weekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.year()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.yearOfCentury()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.yearOfEra()</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.INSTANCE</name>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.UnsupportedDateTimeField(java.lang.String, org.joda.time.DurationField)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException()</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.iDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.iName</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.add(long, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getDurationField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.add(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.add(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getDurationField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.addWrapped(long, int)</name>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.cCache</name>
                <outbound type="class" confirmed="no">java.util.HashMap</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.get(long)</name>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.getAsShortText(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.getAsShortText(long, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.getAsText(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.getAsText(long, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.getDifference(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getDifference(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getDurationField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.getDifferenceAsLong(long, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getDifferenceAsLong(long, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getDurationField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.getDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.iDurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.HashMap</outbound>
                <outbound type="feature" confirmed="no">java.util.HashMap.HashMap(int)</outbound>
                <outbound type="feature" confirmed="no">java.util.HashMap.get(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.HashMap.put(java.lang.Object, java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.UnsupportedDateTimeField(java.lang.String, org.joda.time.DurationField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.cCache</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getDurationField()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.centuryOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.clockhourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.clockhourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.dayOfMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.dayOfWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.dayOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.era()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.halfdayOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.hourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.hourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.millisOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.millisOfSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.minuteOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.minuteOfHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.monthOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.secondOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.secondOfMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.weekOfWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.weekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.year()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.yearOfCentury()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.yearOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.getLeapAmount(long)</name>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.getLeapDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.getMaximumShortTextLength(java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.getMaximumTextLength(java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.getMaximumValue()</name>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.getMaximumValue(long)</name>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.getMinimumValue()</name>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.getMinimumValue(long)</name>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.getName()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.iName</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.getRangeDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.iDurationField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.UnsupportedDateTimeField(java.lang.String, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.readResolve()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.iName</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.UnsupportedDateTimeField(java.lang.String, org.joda.time.DurationField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getName()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.unsupported()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.isLeap(long)</name>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.isLenient()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.isSupported()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.iDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.iName</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.remainder(long)</name>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.roundCeiling(long)</name>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.roundFloor(long)</name>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.roundHalfCeiling(long)</name>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.roundHalfEven(long)</name>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.roundHalfFloor(long)</name>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.set(long, int)</name>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.set(long, java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.set(long, java.lang.String, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.static {}</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.INSTANCE</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getInstance(java.lang.String, org.joda.time.DurationField)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.field.UnsupportedDurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.INSTANCE</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDateTimeField.unsupported()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="no">java.lang.UnsupportedOperationException.UnsupportedOperationException(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.iName</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.addWrapped(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.get(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getAsShortText(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getAsShortText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getAsText(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getAsText(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getLeapAmount(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getMaximumShortTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getMaximumTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getMaximumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getMaximumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getMinimumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.getMinimumValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.isLeap(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.remainder(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.roundCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.roundFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.roundHalfCeiling(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.roundHalfEven(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.roundHalfFloor(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.set(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.set(long, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.set(long, java.lang.String, java.util.Locale)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.field.UnsupportedDurationField</name>
            <outbound type="class" confirmed="no">java.io.Serializable</outbound>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.days()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.hours()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.millis()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.minutes()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.months()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.seconds()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.weeks()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.years()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.days()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.hours()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.millis()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.minutes()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.months()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.seconds()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.weeks()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DurationType.years()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.centuries()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.days()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.eras()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.halfdayOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.hours()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.millis()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.minutes()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.months()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.seconds()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.weeks()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.weekyears()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.years()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.getDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.getDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.getDurationField()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.static {}</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDurationField.INSTANCE</name>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.days()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.hours()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.millis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.minutes()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.months()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.seconds()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.weeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType$MaskedType.years()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.days()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.hours()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.millis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.minutes()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.months()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.seconds()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.weeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DurationType.years()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.BuddhistEraDateTimeField.getDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.CopticEraDateTimeField.getDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJEraDateTimeField.getDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDateTimeField.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDurationField.UnsupportedDurationField(java.lang.String)</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.iName</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getInstance(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDurationField.add(long, int)</name>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDurationField.add(long, long)</name>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDurationField.cCache</name>
                <outbound type="class" confirmed="no">java.util.HashMap</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getInstance(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDurationField.compareTo(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDurationField.getDifference(long, long)</name>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDurationField.getDifferenceAsLong(long, long)</name>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDurationField.getInstance(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.HashMap</outbound>
                <outbound type="feature" confirmed="no">java.util.HashMap.HashMap(int)</outbound>
                <outbound type="feature" confirmed="no">java.util.HashMap.get(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.HashMap.put(java.lang.Object, java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.UnsupportedDurationField(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.cCache</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.centuries()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.days()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.eras()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.halfdayOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.hours()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.millis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.minutes()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.months()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.seconds()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.weeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.weekyears()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.AbstractChronology.years()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDurationField.getMillis(int)</name>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDurationField.getMillis(int, long)</name>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDurationField.getMillis(long)</name>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDurationField.getMillis(long, long)</name>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDurationField.getName()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.iName</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDurationField.getUnitMillis()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDurationField.getValue(long)</name>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDurationField.getValue(long, long)</name>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDurationField.getValueAsLong(long)</name>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDurationField.getValueAsLong(long, long)</name>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDurationField.iName</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.UnsupportedDurationField(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getName()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.readResolve()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.unsupported()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDurationField.isPrecise()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDurationField.isSupported()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDurationField.readResolve()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getInstance(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.iName</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDurationField.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDurationField.static {}</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.INSTANCE</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getInstance(java.lang.String)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDurationField.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.field.UnsupportedDurationField.unsupported()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="no">java.lang.UnsupportedOperationException.UnsupportedOperationException(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.iName</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.add(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.add(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getDifference(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getDifferenceAsLong(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getMillis(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getMillis(int, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getMillis(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getMillis(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getValue(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getValue(long, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getValueAsLong(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.field.UnsupportedDurationField.getValueAsLong(long, long)</inbound>
            </feature>
        </class>
    </package>
    <package confirmed="yes">
        <name>org.joda.time.format</name>
        <class confirmed="yes">
            <name>org.joda.time.format.AbstractDateTimeFormatter</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$AbstractFormatter</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.AbstractDateTimeFormatter.AbstractDateTimeFormatter()</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$AbstractFormatter.DateTimeFormatterBuilder$AbstractFormatter(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.AbstractDateTimeFormatter.createBucket(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeZone()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.getChronology()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParserBucket</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.DateTimeParserBucket(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.setDateTimeZone(org.joda.time.DateTimeZone)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseMillis(java.lang.String, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.AbstractDateTimeFormatter.createErrorMessage(java.lang.String, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.concat(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.substring(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.substring(int, int)</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseMillis(java.lang.String, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.parseMutableDuration(org.joda.time.DurationType, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.AbstractDateTimeFormatter.getChronology()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.createBucket(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.getDateTimeZone()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseDateTime(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseMutableDateTime(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseMutableDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.AbstractDateTimeFormatter.getDateTimeZone()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeZone()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.getChronology()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.print(long, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.print(long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.AbstractDateTimeFormatter.getInstantLocal(org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getDateTimeZone()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseMutableDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.AbstractDateTimeFormatter.parseDateTime(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(long, org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseMillis(java.lang.String)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.AbstractDateTimeFormatter.parseDateTime(java.lang.String, org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.getInstantLocal(org.joda.time.ReadableInstant)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseMillis(java.lang.String, long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.AbstractDateTimeFormatter.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeZone()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadWritableInstant.setMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.createBucket(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParserBucket</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.computeMillis()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.AbstractDateTimeFormatter.parseMillis(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseMillis(java.lang.String, long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseDateTime(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseMutableDateTime(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.AbstractDateTimeFormatter.parseMillis(java.lang.String, long)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.createBucket(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.createErrorMessage(java.lang.String, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParserBucket</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.computeMillis()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseMillis(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseMutableDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.AbstractDateTimeFormatter.parseMutableDateTime(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.MutableDateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(long, org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseMillis(java.lang.String)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.AbstractDateTimeFormatter.parseMutableDateTime(java.lang.String, org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.MutableDateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.getInstantLocal(org.joda.time.ReadableInstant)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseMillis(java.lang.String, long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.AbstractDateTimeFormatter.print(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.print(long, org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.AbstractDateTimeFormatter.print(long, org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.getDateTimeZone()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.print(long, org.joda.time.DateTimeZone, long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.print(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.print(org.joda.time.ReadableInstant)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.AbstractDateTimeFormatter.print(long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.estimatePrintedLength()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.print(long, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.AbstractDateTimeFormatter.print(org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeZone()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.print(long, org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.AbstractDateTimeFormatter.printTo(java.io.Writer, long)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.AbstractDateTimeFormatter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.getDateTimeZone()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.io.Writer, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.io.Writer, org.joda.time.ReadableInstant)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.AbstractDateTimeFormatter.printTo(java.io.Writer, org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeZone()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.AbstractDateTimeFormatter.printTo(java.lang.StringBuffer, long)</name>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.AbstractDateTimeFormatter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.getDateTimeZone()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.lang.StringBuffer, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.AbstractDateTimeFormatter.printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeZone()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getChronology()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone)</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.AbstractDurationFormatter</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.AbstractDurationFormatter.AbstractDurationFormatter()</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.DurationFormatterBuilder$AlternateSelector(org.joda.time.format.DurationFormatter, java.util.List, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.DurationFormatterBuilder$Composite(java.util.List)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(int, int, int, boolean, int, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(org.joda.time.format.DurationFormatterBuilder$FieldFormatter, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(org.joda.time.format.DurationFormatterBuilder$FieldFormatter, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal.DurationFormatterBuilder$Literal(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.DurationFormatterBuilder$Separator(java.lang.String, java.lang.String, org.joda.time.format.DurationFormatter, org.joda.time.format.DurationFormatter)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.AbstractDurationFormatter.countFieldsToPrint(org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationPrinter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationPrinter.countFieldsToPrint(org.joda.time.ReadableDuration, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.AbstractDurationFormatter.parseDuration(org.joda.time.DurationType, java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.toDuration()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Duration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.MutableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.parseMutableDuration(org.joda.time.DurationType, java.lang.String)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.AbstractDurationFormatter.parseMutableDuration(org.joda.time.DurationType, java.lang.String)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.MutableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDuration.MutableDuration(org.joda.time.DurationType, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.createErrorMessage(java.lang.String, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationParser</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationParser.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.parseDuration(org.joda.time.DurationType, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.AbstractDurationFormatter.print(org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationPrinter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationPrinter.calculatePrintedLength(org.joda.time.ReadableDuration)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationPrinter.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DateTimeFormat</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.toString(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.toString(java.lang.String, java.util.Locale)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat.DateTimeFormat(org.joda.time.Chronology, java.util.Locale)</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="feature" confirmed="no">java.util.HashMap.HashMap(int)</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.iChrono</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.iLocale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.iPatternedCache</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.iStyledCache</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.Chronology, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.String(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.charAt(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.substring(int)</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weekyear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.withUTC()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.year()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.yearOfEra()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(org.joda.time.DateTimeField, java.lang.String, java.lang.String, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.isNumericToken(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.parseToken(java.lang.String, int[])</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendCenturyOfEra(int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendClockhourOfDay(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendClockhourOfHalfday(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfMonth(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfWeek(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfWeekShortText()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfWeekText()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfYear(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDecimal(org.joda.time.DateTimeField, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendEraText()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfSecond(int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendHalfdayOfDayText()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendHourOfDay(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(char)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMinuteOfHour(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMonthOfYear(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMonthOfYearShortText()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMonthOfYearText()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendSecondOfMinute(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneName()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneOffset(java.lang.String, boolean, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneShortName()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendWeekOfWeekyear(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendWeekyear(int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendYear(int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendYearOfEra(int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.getChronology()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendPattern(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat.cInstanceCache</name>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.Chronology, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="feature" confirmed="no">java.lang.UnsupportedOperationException.UnsupportedOperationException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.get(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.put(java.lang.Object, java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.DateTimeFormat$FParser(org.joda.time.format.DateTimeParser)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.DateTimeFormat$FPrinter(org.joda.time.format.DateTimePrinter)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.iChrono</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.iLocale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.iPatternedCache</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology, java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.canBuildFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.canBuildParser()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.canBuildPrinter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toParser()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toPrinter()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.toString(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.toString(java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forStyle(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat.forStyle(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.get(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.put(java.lang.Object, java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getPatternForStyle(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.iStyledCache</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat.getDatePattern(char)</name>
                <outbound type="class" confirmed="no">java.lang.ClassCastException</outbound>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="no">java.text.DateFormat</outbound>
                <outbound type="feature" confirmed="no">java.text.DateFormat.getDateInstance(int, java.util.Locale)</outbound>
                <outbound type="class" confirmed="no">java.text.SimpleDateFormat</outbound>
                <outbound type="feature" confirmed="no">java.text.SimpleDateFormat.toPattern()</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.iLocale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.selectStyle(char)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getPatternForStyle(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat.getDateTimePattern(char, char)</name>
                <outbound type="class" confirmed="no">java.lang.ClassCastException</outbound>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="no">java.text.DateFormat</outbound>
                <outbound type="feature" confirmed="no">java.text.DateFormat.getDateTimeInstance(int, int, java.util.Locale)</outbound>
                <outbound type="class" confirmed="no">java.text.SimpleDateFormat</outbound>
                <outbound type="feature" confirmed="no">java.text.SimpleDateFormat.toPattern()</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.iLocale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.selectStyle(char)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getPatternForStyle(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat.getInstance()</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="no">java.util.Locale.getDefault()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.Chronology, java.util.Locale)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="no">java.util.Locale.getDefault()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.Chronology, java.util.Locale)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.toString(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.Chronology, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.util.HashMap.HashMap(int)</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="no">java.util.Locale.getDefault()</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.get(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.put(java.lang.Object, java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.DateTimeFormat(org.joda.time.Chronology, java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.cInstanceCache</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.toString(java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.DateTimeZone, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstanceUTC()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="no">java.util.Locale.getDefault()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.Chronology, java.util.Locale)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.DateTimeZone, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.Chronology, java.util.Locale)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat.getInstanceUTC()</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="no">java.util.Locale.getDefault()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getInstance(org.joda.time.Chronology, java.util.Locale)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat.getPatternForStyle(java.lang.String)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.charAt(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDatePattern(char)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDateTimePattern(char, char)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getTimePattern(char)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forStyle(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat.getTimePattern(char)</name>
                <outbound type="class" confirmed="no">java.lang.ClassCastException</outbound>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="no">java.text.DateFormat</outbound>
                <outbound type="feature" confirmed="no">java.text.DateFormat.getTimeInstance(int, java.util.Locale)</outbound>
                <outbound type="class" confirmed="no">java.text.SimpleDateFormat</outbound>
                <outbound type="feature" confirmed="no">java.text.SimpleDateFormat.toPattern()</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.iLocale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.selectStyle(char)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getPatternForStyle(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat.iChrono</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.DateTimeFormat(org.joda.time.Chronology, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat.iLocale</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.DateTimeFormat(org.joda.time.Chronology, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDatePattern(char)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDateTimePattern(char, char)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getTimePattern(char)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat.iPatternedCache</name>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.DateTimeFormat(org.joda.time.Chronology, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat.iStyledCache</name>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.DateTimeFormat(org.joda.time.Chronology, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forStyle(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat.isNumericToken(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.charAt(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat.parseToken(java.lang.String, int[])</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.charAt(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat.selectStyle(char)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDatePattern(char)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getDateTimePattern(char, char)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.getTimePattern(char)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat.static {}</name>
                <outbound type="feature" confirmed="no">java.util.HashMap.HashMap(int)</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.cInstanceCache</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DateTimeFormat$FParser</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FParser.DateTimeFormat$FParser(org.joda.time.format.DateTimeParser)</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.mParser</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FParser.estimateParsedLength()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.mParser</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.estimateParsedLength()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FParser.estimatePrintedLength()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FParser.getChronology()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.mParser</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.getChronology()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FParser.mParser</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.DateTimeFormat$FParser(org.joda.time.format.DateTimeParser)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.estimateParsedLength()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.getChronology()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseDateTime(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseMillis(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseMillis(java.lang.String, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseMutableDateTime(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseMutableDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FParser.parseDateTime(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.mParser</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseDateTime(java.lang.String)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FParser.parseDateTime(java.lang.String, org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.mParser</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseDateTime(java.lang.String, org.joda.time.ReadableInstant)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FParser.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.mParser</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FParser.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.mParser</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParserBucket</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FParser.parseMillis(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.mParser</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseMillis(java.lang.String)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FParser.parseMillis(java.lang.String, long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.mParser</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseMillis(java.lang.String, long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FParser.parseMutableDateTime(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.MutableDateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.mParser</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseMutableDateTime(java.lang.String)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FParser.parseMutableDateTime(java.lang.String, org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.MutableDateTime</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.mParser</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseMutableDateTime(java.lang.String, org.joda.time.ReadableInstant)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FParser.print(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FParser.print(long, org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FParser.print(long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FParser.print(org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FParser.printTo(java.io.Writer, long)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FParser.printTo(java.io.Writer, long, org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FParser.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FParser.printTo(java.io.Writer, org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FParser.printTo(java.lang.StringBuffer, long)</name>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FParser.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FParser.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FParser.printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FParser.unsupported()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="no">java.lang.UnsupportedOperationException.UnsupportedOperationException(java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.print(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.print(long, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.print(long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.print(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.printTo(java.io.Writer, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.printTo(java.io.Writer, long, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.printTo(java.io.Writer, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.printTo(java.lang.StringBuffer, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DateTimeFormat$FPrinter</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FPrinter.DateTimeFormat$FPrinter(org.joda.time.format.DateTimePrinter)</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.mPrinter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FPrinter.estimateParsedLength()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FPrinter.estimatePrintedLength()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.mPrinter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.estimatePrintedLength()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FPrinter.getChronology()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.mPrinter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.getChronology()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FPrinter.mPrinter</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.DateTimeFormat$FPrinter(org.joda.time.format.DateTimePrinter)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.estimatePrintedLength()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.getChronology()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.print(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.print(long, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.print(long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.print(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.io.Writer, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.io.Writer, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.lang.StringBuffer, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FPrinter.parseDateTime(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FPrinter.parseDateTime(java.lang.String, org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FPrinter.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FPrinter.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.unsupported()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParserBucket</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FPrinter.parseMillis(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FPrinter.parseMillis(java.lang.String, long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FPrinter.parseMutableDateTime(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.MutableDateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FPrinter.parseMutableDateTime(java.lang.String, org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.MutableDateTime</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.unsupported()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FPrinter.print(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.mPrinter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.print(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FPrinter.print(long, org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.mPrinter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.print(long, org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FPrinter.print(long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.mPrinter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.print(long, org.joda.time.DateTimeZone, long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FPrinter.print(org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.mPrinter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.print(org.joda.time.ReadableInstant)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.io.Writer, long)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.mPrinter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.io.Writer, long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.mPrinter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.mPrinter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.io.Writer, org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.mPrinter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.io.Writer, org.joda.time.ReadableInstant)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.lang.StringBuffer, long)</name>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.mPrinter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.lang.StringBuffer, long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.mPrinter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.mPrinter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.mPrinter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormat$FPrinter.unsupported()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="no">java.lang.UnsupportedOperationException.UnsupportedOperationException(java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.parseDateTime(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.parseDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.parseMillis(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.parseMillis(java.lang.String, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.parseMutableDateTime(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.parseMutableDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DateTimeFormatter</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.toString(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.toString(java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.cOffsetFormatter</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.util.TimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getName(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getShortName(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.offsetFormatter()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Instant.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.getMessage()</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forStyle(java.lang.String)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeFormatter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.isFormatter(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicDate()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicDateTime()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicTime()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicWeekDate()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicWeekDateTime()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.bd</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.bdt</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.bt</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.bwd</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.bwdt</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.date()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateElementParser()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHour()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinute()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinuteSecond()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinuteSecondFraction()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateParser()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTime()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTimeParser()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dayOfMonthElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dayOfWeekElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dayOfYearElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dh</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dhm</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dhms</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dhmsf</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dme</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dt</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dwe</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dye</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.fractionElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.fse</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hde</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hm</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hms</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hmsf</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hour()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinute()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinuteSecond()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinuteSecondFraction()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.mhe</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.minuteElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.monthElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.mye</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.offsetElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.secondElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.sme</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.t</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.time()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeElementParser()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeParser()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.wdt</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.we</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekDate()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekDateTime()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearWeek()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearWeekDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.ww</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.wwd</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.wwe</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.ye</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.year()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearMonth()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearMonthDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.ym</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.ymd</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.ze</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseTime(java.lang.String)</inbound>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DateTimeFormatterBuilder</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.offsetFormatter()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicDate()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicDateTime()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicTime()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicWeekDate()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicWeekDateTime()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateElementParser()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHour()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinute()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinuteSecond()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinuteSecondFraction()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateParser()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTime()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTimeParser()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dayOfMonthElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dayOfWeekElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dayOfYearElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.fractionElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinute()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinuteSecond()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinuteSecondFraction()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.minuteElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.monthElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.offsetElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.secondElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.time()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeElementParser()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeParser()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekDateTime()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearWeek()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearWeekDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearElement()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearMonth()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearMonthDay()</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="no">java.util.Locale.getDefault()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology, java.util.Locale)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicDate()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicDateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicWeekDate()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicWeekDateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateElementParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinuteSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinuteSecondFraction()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTimeParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dayOfMonthElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dayOfWeekElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dayOfYearElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.fractionElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinuteSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinuteSecondFraction()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.minuteElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.monthElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.offsetElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.secondElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.time()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeElementParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekDateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearWeekDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearMonthDay()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology, java.util.Locale)</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="no">java.util.ArrayList</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.ArrayList()</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="no">java.util.Locale.getDefault()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.getDateTimeZone()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.withUTC()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChrono</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iElementPairs</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iLocale</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.DateTimeZone, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.offsetFormatter()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.DateTimeZone, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology, java.util.Locale)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeFormatter)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append0(java.lang.Object)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicDateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicWeekDateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateElementParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinuteSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinuteSecondFraction()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTimeParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinuteSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinuteSecondFraction()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.time()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeElementParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekDateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearWeekDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearMonthDay()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeParser)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append0(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTimeParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeElementParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeParser()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimePrinter)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append0(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append0(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser[])</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$MatchingParser.DateTimeFormatterBuilder$MatchingParser(org.joda.time.Chronology, org.joda.time.format.DateTimeParser[])</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append0(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChrono</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateElementParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTimeParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeElementParser()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.append0(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.util.ArrayList</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.add(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iElementPairs</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeFormatter)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDecimal(org.joda.time.DateTimeField, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFraction(org.joda.time.DateTimeField, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(char)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendShortText(org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendSignedDecimal(org.joda.time.DateTimeField, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendText(org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneOffset(java.lang.String, boolean, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.append0(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.util.ArrayList</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.add(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iElementPairs</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeParser)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimePrinter)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendOptional(org.joda.time.format.DateTimeParser)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneName()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneShortName()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendCenturyOfEra(int, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.centuryOfEra()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendSignedDecimal(org.joda.time.DateTimeField, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendClockhourOfDay(int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.clockhourOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDecimal(org.joda.time.DateTimeField, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendClockhourOfHalfday(int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.clockhourOfHalfday()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDecimal(org.joda.time.DateTimeField, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendDayOfMonth(int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfMonth()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDecimal(org.joda.time.DateTimeField, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicDate()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dayOfMonthElement()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendDayOfWeek(int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfWeek()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDecimal(org.joda.time.DateTimeField, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicWeekDate()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dayOfWeekElement()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendDayOfWeekShortText()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfWeek()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendShortText(org.joda.time.DateTimeField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendDayOfWeekText()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfWeek()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendText(org.joda.time.DateTimeField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendDayOfYear(int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfYear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDecimal(org.joda.time.DateTimeField, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dayOfYearElement()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendDecimal(org.joda.time.DateTimeField, int, int)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException()</outbound>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.DateTimeFormatterBuilder$PaddedNumber(org.joda.time.Chronology, org.joda.time.DateTimeField, int, boolean, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber.DateTimeFormatterBuilder$UnpaddedNumber(org.joda.time.Chronology, org.joda.time.DateTimeField, int, boolean)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append0(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChrono</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendClockhourOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendClockhourOfHalfday(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfMonth(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfWeek(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendHourOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendHourOfHalfday(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMillisOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMillisOfSecond(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMinuteOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMinuteOfHour(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMonthOfYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendSecondOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendSecondOfMinute(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendWeekOfWeekyear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendYearOfCentury(int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendYearOfEra(int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendEraText()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.era()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendText(org.joda.time.DateTimeField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendFraction(org.joda.time.DateTimeField, int, int)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException()</outbound>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDurationField()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isPrecise()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.DateTimeFormatterBuilder$Fraction(org.joda.time.Chronology, org.joda.time.DateTimeField, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append0(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChrono</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfDay(int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfHour(int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfMinute(int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfSecond(int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfDay(int, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfYear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFraction(org.joda.time.DateTimeField, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfHour(int, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.hourOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFraction(org.joda.time.DateTimeField, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeElementParser()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfMinute(int, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.minuteOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFraction(org.joda.time.DateTimeField, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeElementParser()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfSecond(int, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.secondOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFraction(org.joda.time.DateTimeField, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.fractionElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeElementParser()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendHalfdayOfDayText()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.halfdayOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendText(org.joda.time.DateTimeField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendHourOfDay(int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.hourOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDecimal(org.joda.time.DateTimeField, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourElement()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendHourOfHalfday(int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.hourOfHalfday()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDecimal(org.joda.time.DateTimeField, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(char)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.DateTimeFormatterBuilder$CharacterLiteral(org.joda.time.Chronology, char)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append0(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChrono</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicDateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicWeekDate()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicWeekDateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinuteSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinuteSecondFraction()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTimeParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dayOfMonthElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dayOfWeekElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dayOfYearElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.fractionElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.minuteElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.monthElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.secondElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeElementParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekDateTime()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(java.lang.String)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.DateTimeFormatterBuilder$StringLiteral(org.joda.time.Chronology, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append0(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChrono</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekElement()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendMillisOfDay(int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millisOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDecimal(org.joda.time.DateTimeField, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendMillisOfSecond(int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millisOfSecond()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDecimal(org.joda.time.DateTimeField, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendMinuteOfDay(int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.minuteOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDecimal(org.joda.time.DateTimeField, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendMinuteOfHour(int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.minuteOfHour()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDecimal(org.joda.time.DateTimeField, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.minuteElement()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendMonthOfYear(int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.monthOfYear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDecimal(org.joda.time.DateTimeField, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicDate()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.monthElement()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendMonthOfYearShortText()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.monthOfYear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendShortText(org.joda.time.DateTimeField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendMonthOfYearText()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.monthOfYear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendText(org.joda.time.DateTimeField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendOptional(org.joda.time.format.DateTimeParser)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$MatchingParser.DateTimeFormatterBuilder$MatchingParser(org.joda.time.Chronology, org.joda.time.format.DateTimeParser[])</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append0(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChrono</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateElementParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTimeParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeElementParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeParser()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendPattern(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendSecondOfDay(int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.secondOfDay()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDecimal(org.joda.time.DateTimeField, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendSecondOfMinute(int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.secondOfMinute()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDecimal(org.joda.time.DateTimeField, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.secondElement()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendShortText(org.joda.time.DateTimeField)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.DateTimeFormatterBuilder$TextField(org.joda.time.Chronology, org.joda.time.DateTimeField, java.util.Locale, boolean)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append0(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChrono</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iLocale</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfWeekShortText()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMonthOfYearShortText()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendSignedDecimal(org.joda.time.DateTimeField, int, int)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException()</outbound>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.DateTimeFormatterBuilder$PaddedNumber(org.joda.time.Chronology, org.joda.time.DateTimeField, int, boolean, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber.DateTimeFormatterBuilder$UnpaddedNumber(org.joda.time.Chronology, org.joda.time.DateTimeField, int, boolean)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append0(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChrono</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendCenturyOfEra(int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendWeekyear(int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendYear(int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendText(org.joda.time.DateTimeField)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.DateTimeFormatterBuilder$TextField(org.joda.time.Chronology, org.joda.time.DateTimeField, java.util.Locale, boolean)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append0(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChrono</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iLocale</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfWeekText()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendEraText()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendHalfdayOfDayText()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMonthOfYearText()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneName()</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.DateTimeFormatterBuilder$TimeZonePrinter(org.joda.time.Chronology, java.util.Locale, boolean)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append0(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChrono</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iLocale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneOffset(java.lang.String, boolean, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.DateTimeFormatterBuilder$TimeZoneOffsetFormatter(org.joda.time.Chronology, java.lang.String, boolean, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append0(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChrono</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.offsetFormatter()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.offsetElement()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneShortName()</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.DateTimeFormatterBuilder$TimeZonePrinter(org.joda.time.Chronology, java.util.Locale, boolean)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append0(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChrono</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iLocale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendWeekOfWeekyear(int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weekOfWeekyear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDecimal(org.joda.time.DateTimeField, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicWeekDate()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekElement()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendWeekyear(int, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.weekyear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendSignedDecimal(org.joda.time.DateTimeField, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicWeekDate()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearElement()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendYear(int, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.year()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendSignedDecimal(org.joda.time.DateTimeField, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicDate()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearElement()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendYearOfCentury(int, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.yearOfCentury()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDecimal(org.joda.time.DateTimeField, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.appendYearOfEra(int, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.yearOfEra()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDecimal(org.joda.time.DateTimeField, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.canBuildFormatter()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.getFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.isFormatter(java.lang.Object)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.canBuildParser()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.getFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.isParser(java.lang.Object)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.canBuildPrinter()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.getFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.isPrinter(java.lang.Object)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.clear()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.util.ArrayList</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.clear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iElementPairs</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iFormatter</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.getChronology()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChrono</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.appendPatternTo(org.joda.time.format.DateTimeFormatterBuilder, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.getFormatter()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.util.ArrayList</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.get(int)</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.size()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.DateTimeFormatterBuilder$Composite(org.joda.time.Chronology, java.util.ArrayList)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iChrono</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iElementPairs</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.canBuildFormatter()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.canBuildParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.canBuildPrinter()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toPrinter()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.getLocale()</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.iLocale</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.iChrono</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDecimal(org.joda.time.DateTimeField, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFraction(org.joda.time.DateTimeField, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(char)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendOptional(org.joda.time.format.DateTimeParser)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendShortText(org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendSignedDecimal(org.joda.time.DateTimeField, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendText(org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneName()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneOffset(java.lang.String, boolean, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneShortName()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.getChronology()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.getFormatter()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.iChronoUTC</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendCenturyOfEra(int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendClockhourOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendClockhourOfHalfday(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfMonth(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfWeek(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfWeekShortText()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfWeekText()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendEraText()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfDay(int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfHour(int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfMinute(int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfSecond(int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendHalfdayOfDayText()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendHourOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendHourOfHalfday(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMillisOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMillisOfSecond(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMinuteOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMinuteOfHour(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMonthOfYear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMonthOfYearShortText()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMonthOfYearText()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendSecondOfDay(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendSecondOfMinute(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendWeekOfWeekyear(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendWeekyear(int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendYear(int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendYearOfCentury(int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendYearOfEra(int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.iElementPairs</name>
                <outbound type="class" confirmed="no">java.util.ArrayList</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append0(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append0(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.clear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.getFormatter()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.iFormatter</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append0(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append0(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.clear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.getFormatter()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.iLocale</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendShortText(org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendText(org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneName()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneShortName()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.getLocale()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.isFormatter(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.isParser()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.isPrinter()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.canBuildFormatter()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.isParser(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.isParser()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.canBuildParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toParser()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.isPrinter(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.isPrinter()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.canBuildPrinter()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toPrinter()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="no">java.lang.UnsupportedOperationException.UnsupportedOperationException(java.lang.String)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.getFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.isFormatter(java.lang.Object)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.offsetFormatter()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicDate()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicDateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicWeekDate()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicWeekDateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinuteSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinuteSecondFraction()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dayOfMonthElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dayOfWeekElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dayOfYearElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.fractionElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinuteSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinuteSecondFraction()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.minuteElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.monthElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.offsetElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.secondElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.time()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekDateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearWeekDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearMonthDay()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.toParser()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="no">java.lang.UnsupportedOperationException.UnsupportedOperationException(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.getFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.isParser(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateElementParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTimeParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeElementParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeParser()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder.toPrinter()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.UnsupportedOperationException</outbound>
                <outbound type="feature" confirmed="no">java.lang.UnsupportedOperationException.UnsupportedOperationException(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.getFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.isPrinter(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DateTimeFormatterBuilder$AbstractFormatter</name>
            <outbound type="class" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter</outbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$MatchingParser</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$AbstractFormatter.DateTimeFormatterBuilder$AbstractFormatter(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.AbstractDateTimeFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$AbstractFormatter.iChrono</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.DateTimeFormatterBuilder$CharacterLiteral(org.joda.time.Chronology, char)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.DateTimeFormatterBuilder$Composite(org.joda.time.Chronology, java.util.ArrayList)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.DateTimeFormatterBuilder$Fraction(org.joda.time.Chronology, org.joda.time.DateTimeField, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$MatchingParser.DateTimeFormatterBuilder$MatchingParser(org.joda.time.Chronology, org.joda.time.format.DateTimeParser[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.DateTimeFormatterBuilder$NumberFormatter(org.joda.time.Chronology, org.joda.time.DateTimeField, int, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.DateTimeFormatterBuilder$StringLiteral(org.joda.time.Chronology, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.DateTimeFormatterBuilder$TextField(org.joda.time.Chronology, org.joda.time.DateTimeField, java.util.Locale, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.DateTimeFormatterBuilder$TimeZoneOffsetFormatter(org.joda.time.Chronology, java.lang.String, boolean, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.DateTimeFormatterBuilder$TimeZonePrinter(org.joda.time.Chronology, java.util.Locale, boolean)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$AbstractFormatter.getChronology()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$AbstractFormatter.iChrono</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$AbstractFormatter.iChrono</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$AbstractFormatter.DateTimeFormatterBuilder$AbstractFormatter(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$AbstractFormatter.getChronology()</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral</name>
            <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$AbstractFormatter</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.DateTimeFormatterBuilder$CharacterLiteral(org.joda.time.Chronology, char)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$AbstractFormatter.DateTimeFormatterBuilder$AbstractFormatter(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.iValue</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(char)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.estimateParsedLength()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.estimatePrintedLength()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.iValue</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.DateTimeFormatterBuilder$CharacterLiteral(org.joda.time.Chronology, char)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.print(long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</name>
                <outbound type="feature" confirmed="no">java.lang.Character.toLowerCase(char)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Character.toUpperCase(char)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.charAt(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.iValue</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParserBucket</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.print(long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.valueOf(char)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.iValue</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="feature" confirmed="no">java.io.Writer.write(int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.iValue</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.iValue</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DateTimeFormatterBuilder$Composite</name>
            <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$AbstractFormatter</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.isFormatter(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.isParser(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.isPrinter(java.lang.Object)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$Composite.DateTimeFormatterBuilder$Composite(org.joda.time.Chronology, java.util.ArrayList)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.util.ArrayList</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.get(int)</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.size()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$AbstractFormatter.DateTimeFormatterBuilder$AbstractFormatter(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.iParsedLengthEstimate</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.iParsers</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.iPrintedLengthEstimate</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.iPrinters</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.estimateParsedLength()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.estimatePrintedLength()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.getFormatter()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$Composite.estimateParsedLength()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.iParsedLengthEstimate</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$Composite.estimatePrintedLength()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.iPrintedLengthEstimate</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$Composite.iParsedLengthEstimate</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.DateTimeFormatterBuilder$Composite(org.joda.time.Chronology, java.util.ArrayList)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.estimateParsedLength()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$Composite.iParsers</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.DateTimeFormatterBuilder$Composite(org.joda.time.Chronology, java.util.ArrayList)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.isParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$Composite.iPrintedLengthEstimate</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.DateTimeFormatterBuilder$Composite(org.joda.time.Chronology, java.util.ArrayList)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.estimatePrintedLength()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$Composite.iPrinters</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.DateTimeFormatterBuilder$Composite(org.joda.time.Chronology, java.util.ArrayList)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.isPrinter()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$Composite.isParser()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.iParsers</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.isFormatter(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.isParser(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$Composite.isPrinter()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.iPrinters</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.isFormatter(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.isPrinter(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$Composite.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.UnsupportedOperationException.UnsupportedOperationException()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.iParsers</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParserBucket</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$Composite.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="feature" confirmed="no">java.lang.UnsupportedOperationException.UnsupportedOperationException()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.iPrinters</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$Composite.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.UnsupportedOperationException.UnsupportedOperationException()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.iPrinters</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimePrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DateTimeFormatterBuilder$Fraction</name>
            <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$AbstractFormatter</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$Fraction.DateTimeFormatterBuilder$Fraction(org.joda.time.Chronology, org.joda.time.DateTimeField, int, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDurationField()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.getUnitMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$AbstractFormatter.DateTimeFormatterBuilder$AbstractFormatter(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.iMaxDigits</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.iMinDigits</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.iRangeMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.iScalar</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFraction(org.joda.time.DateTimeField, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$Fraction.estimateParsedLength()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.iMaxDigits</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$Fraction.estimatePrintedLength()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.iMaxDigits</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$Fraction.iField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.DateTimeFormatterBuilder$Fraction(org.joda.time.Chronology, org.joda.time.DateTimeField, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.lang.StringBuffer, java.io.Writer, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$Fraction.iMaxDigits</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.DateTimeFormatterBuilder$Fraction(org.joda.time.Chronology, org.joda.time.DateTimeField, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.estimateParsedLength()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.estimatePrintedLength()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.lang.StringBuffer, java.io.Writer, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$Fraction.iMinDigits</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.DateTimeFormatterBuilder$Fraction(org.joda.time.Chronology, org.joda.time.DateTimeField, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.lang.StringBuffer, java.io.Writer, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$Fraction.iParseField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$Fraction.iRangeMillis</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.DateTimeFormatterBuilder$Fraction(org.joda.time.Chronology, org.joda.time.DateTimeField, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.lang.StringBuffer, java.io.Writer, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$Fraction.iScalar</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.DateTimeFormatterBuilder$Fraction(org.joda.time.Chronology, org.joda.time.DateTimeField, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.lang.StringBuffer, java.io.Writer, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$Fraction.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</name>
                <outbound type="feature" confirmed="no">java.lang.Math.min(int, int)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.charAt(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDurationField()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.MillisDurationField.INSTANCE</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.field.PreciseDateTimeField.PreciseDateTimeField(java.lang.String, org.joda.time.DurationField, org.joda.time.DurationField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.iMaxDigits</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.iParseField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.iRangeMillis</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParserBucket</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.saveField(org.joda.time.DateTimeField, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.lang.StringBuffer, java.io.Writer, long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.lang.StringBuffer, java.io.Writer, long)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="feature" confirmed="no">java.io.Writer.write(int)</outbound>
                <outbound type="feature" confirmed="no">java.io.Writer.write(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Integer.toString(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Long.toString(long)</outbound>
                <outbound type="class" confirmed="no">java.lang.RuntimeException</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.charAt(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.remainder(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.iMaxDigits</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.iMinDigits</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.iRangeMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.iScalar</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.printTo(java.lang.StringBuffer, java.io.Writer, long)</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DateTimeFormatterBuilder$MatchingParser</name>
            <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$AbstractFormatter</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$MatchingParser.DateTimeFormatterBuilder$MatchingParser(org.joda.time.Chronology, org.joda.time.format.DateTimeParser[])</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$AbstractFormatter.DateTimeFormatterBuilder$AbstractFormatter(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$MatchingParser.iParsedLengthEstimate</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$MatchingParser.iParsers</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.estimateParsedLength()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendOptional(org.joda.time.format.DateTimeParser)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$MatchingParser.estimateParsedLength()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$MatchingParser.iParsedLengthEstimate</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$MatchingParser.iParsedLengthEstimate</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$MatchingParser.DateTimeFormatterBuilder$MatchingParser(org.joda.time.Chronology, org.joda.time.format.DateTimeParser[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$MatchingParser.estimateParsedLength()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$MatchingParser.iParsers</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$MatchingParser.DateTimeFormatterBuilder$MatchingParser(org.joda.time.Chronology, org.joda.time.format.DateTimeParser[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$MatchingParser.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$MatchingParser.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$MatchingParser.iParsers</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParserBucket</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.restoreState(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.saveState()</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter</name>
            <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$AbstractFormatter</outbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.DateTimeFormatterBuilder$NumberFormatter(org.joda.time.Chronology, org.joda.time.DateTimeField, int, boolean)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$AbstractFormatter.DateTimeFormatterBuilder$AbstractFormatter(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.iMaxParsedDigits</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.iSigned</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.DateTimeFormatterBuilder$PaddedNumber(org.joda.time.Chronology, org.joda.time.DateTimeField, int, boolean, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber.DateTimeFormatterBuilder$UnpaddedNumber(org.joda.time.Chronology, org.joda.time.DateTimeField, int, boolean)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.estimateParsedLength()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.iMaxParsedDigits</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.estimatePrintedLength()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.iField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.DateTimeFormatterBuilder$NumberFormatter(org.joda.time.Chronology, org.joda.time.DateTimeField, int, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.iMaxParsedDigits</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.DateTimeFormatterBuilder$NumberFormatter(org.joda.time.Chronology, org.joda.time.DateTimeField, int, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.estimateParsedLength()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.estimatePrintedLength()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber.estimatePrintedLength()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.iSigned</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.DateTimeFormatterBuilder$NumberFormatter(org.joda.time.Chronology, org.joda.time.DateTimeField, int, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</name>
                <outbound type="feature" confirmed="no">java.lang.Integer.parseInt(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Math.min(int, int)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.charAt(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.substring(int, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.iMaxParsedDigits</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.iSigned</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParserBucket</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.saveField(org.joda.time.DateTimeField, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber</name>
            <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.DateTimeFormatterBuilder$PaddedNumber(org.joda.time.Chronology, org.joda.time.DateTimeField, int, boolean, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.DateTimeFormatterBuilder$NumberFormatter(org.joda.time.Chronology, org.joda.time.DateTimeField, int, boolean)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.iMinPrintedDigits</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDecimal(org.joda.time.DateTimeField, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendSignedDecimal(org.joda.time.DateTimeField, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.estimatePrintedLength()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.iMaxParsedDigits</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.iMinPrintedDigits</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.DateTimeFormatterBuilder$PaddedNumber(org.joda.time.Chronology, org.joda.time.DateTimeField, int, boolean, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="feature" confirmed="no">java.io.Writer.write(int)</outbound>
                <outbound type="class" confirmed="no">java.lang.RuntimeException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.iMinPrintedDigits</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writePaddedInteger(java.io.Writer, int, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.lang.RuntimeException</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.iMinPrintedDigits</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.appendPaddedInteger(java.lang.StringBuffer, int, int)</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DateTimeFormatterBuilder$StringLiteral</name>
            <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$AbstractFormatter</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.DateTimeFormatterBuilder$StringLiteral(org.joda.time.Chronology, java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$AbstractFormatter.DateTimeFormatterBuilder$AbstractFormatter(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.iValue</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.estimateParsedLength()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.iValue</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.estimatePrintedLength()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.iValue</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.iValue</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.DateTimeFormatterBuilder$StringLiteral(org.joda.time.Chronology, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.estimateParsedLength()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.estimatePrintedLength()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.print(long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.regionMatches(boolean, int, java.lang.String, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.iValue</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParserBucket</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.print(long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.iValue</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="feature" confirmed="no">java.io.Writer.write(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.iValue</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.iValue</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DateTimeFormatterBuilder$TextField</name>
            <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$AbstractFormatter</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$TextField.DateTimeFormatterBuilder$TextField(org.joda.time.Chronology, org.joda.time.DateTimeField, java.util.Locale, boolean)</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$AbstractFormatter.DateTimeFormatterBuilder$AbstractFormatter(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.iLocale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.iShort</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendShortText(org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendText(org.joda.time.DateTimeField)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$TextField.estimateParsedLength()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.estimatePrintedLength()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$TextField.estimatePrintedLength()</name>
                <outbound type="class" confirmed="no">java.lang.RuntimeException</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMaximumShortTextLength(java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMaximumTextLength(java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.iLocale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.iShort</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.estimateParsedLength()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$TextField.iField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.DateTimeFormatterBuilder$TextField(org.joda.time.Chronology, org.joda.time.DateTimeField, java.util.Locale, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.estimatePrintedLength()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.print(long, org.joda.time.DateTimeZone, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$TextField.iLocale</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.DateTimeFormatterBuilder$TextField(org.joda.time.Chronology, org.joda.time.DateTimeField, java.util.Locale, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.estimatePrintedLength()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.print(long, org.joda.time.DateTimeZone, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$TextField.iShort</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.DateTimeFormatterBuilder$TextField(org.joda.time.Chronology, org.joda.time.DateTimeField, java.util.Locale, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.estimatePrintedLength()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.print(long, org.joda.time.DateTimeZone, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$TextField.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</name>
                <outbound type="feature" confirmed="no">java.lang.Character.isLetter(char)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.charAt(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.substring(int, int)</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.iLocale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParserBucket</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.saveField(org.joda.time.DateTimeField, java.lang.String, java.util.Locale)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$TextField.print(long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getAsShortText(long, java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getAsText(long, java.util.Locale)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.iLocale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.iShort</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$TextField.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="feature" confirmed="no">java.io.Writer.write(int)</outbound>
                <outbound type="feature" confirmed="no">java.io.Writer.write(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.RuntimeException</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.print(long, org.joda.time.DateTimeZone, long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$TextField.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.lang.RuntimeException</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.print(long, org.joda.time.DateTimeZone, long)</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter</name>
            <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$AbstractFormatter</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.DateTimeFormatterBuilder$TimeZoneOffsetFormatter(org.joda.time.Chronology, java.lang.String, boolean, int, int)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$AbstractFormatter.DateTimeFormatterBuilder$AbstractFormatter(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.iMaxFields</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.iMinFields</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.iShowSeparators</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.iZeroOffsetText</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneOffset(java.lang.String, boolean, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.digitCount(java.lang.String, int, int)</name>
                <outbound type="feature" confirmed="no">java.lang.Math.min(int, int)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.charAt(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.estimateParsedLength()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.estimatePrintedLength()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.estimatePrintedLength()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.iMinFields</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.iShowSeparators</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.iZeroOffsetText</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.estimateParsedLength()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.iMaxFields</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.DateTimeFormatterBuilder$TimeZoneOffsetFormatter(org.joda.time.Chronology, java.lang.String, boolean, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.iMinFields</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.DateTimeFormatterBuilder$TimeZoneOffsetFormatter(org.joda.time.Chronology, java.lang.String, boolean, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.estimatePrintedLength()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.iShowSeparators</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.DateTimeFormatterBuilder$TimeZoneOffsetFormatter(org.joda.time.Chronology, java.lang.String, boolean, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.estimatePrintedLength()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.iZeroOffsetText</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.DateTimeFormatterBuilder$TimeZoneOffsetFormatter(org.joda.time.Chronology, java.lang.String, boolean, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.estimatePrintedLength()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.charAt(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.regionMatches(boolean, int, java.lang.String, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.digitCount(java.lang.String, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.iZeroOffsetText</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParserBucket</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.setOffset(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.parseTwoDigits(java.lang.String, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="feature" confirmed="no">java.io.Writer.write(int)</outbound>
                <outbound type="feature" confirmed="no">java.io.Writer.write(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.iMaxFields</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.iMinFields</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.iShowSeparators</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.iZeroOffsetText</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writePaddedInteger(java.io.Writer, int, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.iMaxFields</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.iMinFields</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.iShowSeparators</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.iZeroOffsetText</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.appendPaddedInteger(java.lang.StringBuffer, int, int)</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter</name>
            <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$AbstractFormatter</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.DateTimeFormatterBuilder$TimeZonePrinter(org.joda.time.Chronology, java.util.Locale, boolean)</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$AbstractFormatter.DateTimeFormatterBuilder$AbstractFormatter(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.iLocale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.iShortFormat</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneName()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneShortName()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.estimatePrintedLength()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.iShortFormat</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.iLocale</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.DateTimeFormatterBuilder$TimeZonePrinter(org.joda.time.Chronology, java.util.Locale, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.print(long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.iShortFormat</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.DateTimeFormatterBuilder$TimeZonePrinter(org.joda.time.Chronology, java.util.Locale, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.estimatePrintedLength()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.print(long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.print(long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getName(long, java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getShortName(long, java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.getDateTimeZone()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.iLocale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.iShortFormat</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="feature" confirmed="no">java.io.Writer.write(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getName(long, java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getShortName(long, java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.getDateTimeZone()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.iLocale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.iShortFormat</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getName(long, java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getShortName(long, java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.getDateTimeZone()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.iLocale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter.iShortFormat</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber</name>
            <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber.DateTimeFormatterBuilder$UnpaddedNumber(org.joda.time.Chronology, org.joda.time.DateTimeField, int, boolean)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.DateTimeFormatterBuilder$NumberFormatter(org.joda.time.Chronology, org.joda.time.DateTimeField, int, boolean)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDecimal(org.joda.time.DateTimeField, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendSignedDecimal(org.joda.time.DateTimeField, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber.estimatePrintedLength()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.iMaxParsedDigits</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="feature" confirmed="no">java.io.Writer.write(int)</outbound>
                <outbound type="class" confirmed="no">java.lang.RuntimeException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writeUnpaddedInteger(java.io.Writer, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.lang.RuntimeException</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.appendUnpaddedInteger(java.lang.StringBuffer, int)</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DateTimeParser</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getInstantMillis(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getInstantMillis(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseMillis(java.lang.String, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.DateTimeFormat$FParser(org.joda.time.format.DateTimeParser)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.estimateParsedLength()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.getChronology()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.mParser</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseDateTime(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseMillis(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseMillis(java.lang.String, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseMutableDateTime(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseMutableDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.DateTimeFormatterBuilder$Composite(org.joda.time.Chronology, java.util.ArrayList)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.iParsers</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.isParser()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$MatchingParser</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$MatchingParser.DateTimeFormatterBuilder$MatchingParser(org.joda.time.Chronology, org.joda.time.format.DateTimeParser[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$MatchingParser.iParsers</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$MatchingParser.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeParser)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimePrinter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append0(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendOptional(org.joda.time.format.DateTimeParser)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneName()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneShortName()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.isParser(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toParser()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateElementParser()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateParser()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTimeParser()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dp</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dpe</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dtp</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeElementParser()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeParser()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.tp</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.tpe</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParser.estimateParsedLength()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.estimateParsedLength()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.DateTimeFormatterBuilder$Composite(org.joda.time.Chronology, java.util.ArrayList)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$MatchingParser.DateTimeFormatterBuilder$MatchingParser(org.joda.time.Chronology, org.joda.time.format.DateTimeParser[])</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParser.getChronology()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.getChronology()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParser.parseDateTime(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseDateTime(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParser.parseDateTime(java.lang.String, org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParser.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseTime(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParser.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParserBucket</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseMillis(java.lang.String, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$MatchingParser.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParser.parseMillis(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.util.TimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getInstantMillis(java.lang.Object, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getInstantMillis(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseMillis(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParser.parseMillis(java.lang.String, long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseMillis(java.lang.String, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParser.parseMutableDateTime(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.MutableDateTime</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseMutableDateTime(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParser.parseMutableDateTime(java.lang.String, org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.MutableDateTime</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseMutableDateTime(java.lang.String, org.joda.time.ReadableInstant)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DateTimeParserBucket</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.createBucket(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseMillis(java.lang.String, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FParser.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$MatchingParser.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$StringLiteral.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.DateTimeParserBucket$SavedState(org.joda.time.format.DateTimeParserBucket)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.restoreState(org.joda.time.format.DateTimeParserBucket)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.this$0</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket.DateTimeParserBucket(long)</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iSavedFields</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.createBucket(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket.computeMillis()</name>
                <outbound type="class" confirmed="no">java.lang.Comparable</outbound>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.clone()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffsetFromLocal(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.set(long)</outbound>
                <outbound type="class" confirmed="no">org.joda.time.format.DateTimeParserBucket$SavedField[]</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iOffset</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iSavedFields</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iSavedFieldsCount</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iSavedFieldsShared</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.sort(java.lang.Comparable[], int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.parseMillis(java.lang.String, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket.getDateTimeZone()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket.getOffset()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iOffset</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket.iMillis</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.DateTimeParserBucket(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.computeMillis()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket.iOffset</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.DateTimeParserBucket$SavedState(org.joda.time.format.DateTimeParserBucket)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.restoreState(org.joda.time.format.DateTimeParserBucket)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.computeMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.getOffset()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.setDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.setOffset(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket.iSavedFields</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.DateTimeParserBucket$SavedState(org.joda.time.format.DateTimeParserBucket)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.restoreState(org.joda.time.format.DateTimeParserBucket)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.DateTimeParserBucket(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.computeMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.saveField(org.joda.time.format.DateTimeParserBucket$SavedField)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket.iSavedFieldsCount</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.DateTimeParserBucket$SavedState(org.joda.time.format.DateTimeParserBucket)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.restoreState(org.joda.time.format.DateTimeParserBucket)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.computeMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.saveField(org.joda.time.format.DateTimeParserBucket$SavedField)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket.iSavedFieldsShared</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.restoreState(org.joda.time.format.DateTimeParserBucket)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.computeMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.saveField(org.joda.time.format.DateTimeParserBucket$SavedField)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket.iSavedState</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.restoreState(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.saveField(org.joda.time.format.DateTimeParserBucket$SavedField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.saveState()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.setDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.setOffset(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket.iZone</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.DateTimeParserBucket$SavedState(org.joda.time.format.DateTimeParserBucket)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.restoreState(org.joda.time.format.DateTimeParserBucket)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.computeMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.getDateTimeZone()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.setDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.setOffset(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket.restoreState(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.restoreState(org.joda.time.format.DateTimeParserBucket)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iSavedState</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$MatchingParser.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket.saveField(org.joda.time.DateTimeField, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.DateTimeParserBucket$SavedField(org.joda.time.DateTimeField, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.saveField(org.joda.time.format.DateTimeParserBucket$SavedField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Fraction.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket.saveField(org.joda.time.DateTimeField, java.lang.String, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.DateTimeParserBucket$SavedField(org.joda.time.DateTimeField, java.lang.String, java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.saveField(org.joda.time.format.DateTimeParserBucket$SavedField)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TextField.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket.saveField(org.joda.time.format.DateTimeParserBucket$SavedField)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iSavedFields</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iSavedFieldsCount</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iSavedFieldsShared</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iSavedState</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.saveField(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.saveField(org.joda.time.DateTimeField, java.lang.String, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket.saveState()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.DateTimeParserBucket$SavedState(org.joda.time.format.DateTimeParserBucket)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iSavedState</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$MatchingParser.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket.setDateTimeZone(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iOffset</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iSavedState</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.createBucket(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket.setOffset(int)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iOffset</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iSavedState</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket.sort(java.lang.Comparable[], int)</name>
                <outbound type="class" confirmed="no">java.lang.Comparable</outbound>
                <outbound type="feature" confirmed="no">java.lang.Comparable.compareTo(java.lang.Object)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.util.Arrays.sort(java.lang.Object[], int, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.computeMillis()</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DateTimeParserBucket$SavedField</name>
            <outbound type="class" confirmed="no">java.lang.Comparable</outbound>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.DateTimeParserBucket$SavedState(org.joda.time.format.DateTimeParserBucket)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.iSavedFields</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.restoreState(org.joda.time.format.DateTimeParserBucket)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.DateTimeParserBucket(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.computeMillis()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iSavedFields</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.saveField(org.joda.time.DateTimeField, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.saveField(org.joda.time.DateTimeField, java.lang.String, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.saveField(org.joda.time.format.DateTimeParserBucket$SavedField)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket$SavedField.DateTimeParserBucket$SavedField(org.joda.time.DateTimeField, int)</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.iLocale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.iText</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.iValue</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.saveField(org.joda.time.DateTimeField, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket$SavedField.DateTimeParserBucket$SavedField(org.joda.time.DateTimeField, java.lang.String, java.util.Locale)</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.iLocale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.iText</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.iValue</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.saveField(org.joda.time.DateTimeField, java.lang.String, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket$SavedField.compareReverse(java.lang.Comparable, java.lang.Comparable)</name>
                <outbound type="class" confirmed="no">java.lang.Comparable</outbound>
                <outbound type="feature" confirmed="no">java.lang.Comparable.compareTo(java.lang.Object)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.compareTo(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket$SavedField.compareTo(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Comparable</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDurationField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getRangeDurationField()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.compareReverse(java.lang.Comparable, java.lang.Comparable)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket$SavedField.iField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.DateTimeParserBucket$SavedField(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.DateTimeParserBucket$SavedField(org.joda.time.DateTimeField, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.compareTo(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.set(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket$SavedField.iLocale</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.DateTimeParserBucket$SavedField(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.DateTimeParserBucket$SavedField(org.joda.time.DateTimeField, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.set(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket$SavedField.iText</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.DateTimeParserBucket$SavedField(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.DateTimeParserBucket$SavedField(org.joda.time.DateTimeField, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.set(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket$SavedField.iValue</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.DateTimeParserBucket$SavedField(org.joda.time.DateTimeField, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.DateTimeParserBucket$SavedField(org.joda.time.DateTimeField, java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.set(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket$SavedField.set(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, java.lang.String, java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.iLocale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.iText</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField.iValue</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.computeMillis()</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>org.joda.time.format.DateTimeParserBucket$SavedField[]</name>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.computeMillis()</inbound>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DateTimeParserBucket$SavedState</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.restoreState(java.lang.Object)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket$SavedState.DateTimeParserBucket$SavedState(org.joda.time.format.DateTimeParserBucket)</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParserBucket</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.iOffset</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.iSavedFields</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.iSavedFieldsCount</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.iZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iOffset</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iSavedFields</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iSavedFieldsCount</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.saveState()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket$SavedState.iOffset</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.DateTimeParserBucket$SavedState(org.joda.time.format.DateTimeParserBucket)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.restoreState(org.joda.time.format.DateTimeParserBucket)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket$SavedState.iSavedFields</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.DateTimeParserBucket$SavedState(org.joda.time.format.DateTimeParserBucket)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.restoreState(org.joda.time.format.DateTimeParserBucket)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket$SavedState.iSavedFieldsCount</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.DateTimeParserBucket$SavedState(org.joda.time.format.DateTimeParserBucket)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.restoreState(org.joda.time.format.DateTimeParserBucket)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket$SavedState.iZone</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.DateTimeParserBucket$SavedState(org.joda.time.format.DateTimeParserBucket)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.restoreState(org.joda.time.format.DateTimeParserBucket)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket$SavedState.restoreState(org.joda.time.format.DateTimeParserBucket)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParserBucket</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.iOffset</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.iSavedFields</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.iSavedFieldsCount</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.iZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.this$0</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iOffset</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iSavedFields</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iSavedFieldsCount</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iSavedFieldsShared</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.iZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket.restoreState(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimeParserBucket$SavedState.this$0</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParserBucket</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.DateTimeParserBucket$SavedState(org.joda.time.format.DateTimeParserBucket)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParserBucket$SavedState.restoreState(org.joda.time.format.DateTimeParserBucket)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DateTimePrinter</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.print(long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.io.Writer, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.DateTimeFormat$FPrinter(org.joda.time.format.DateTimePrinter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.estimatePrintedLength()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.getChronology()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.mPrinter</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.print(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.print(long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.print(long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.print(org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.io.Writer, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.io.Writer, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.lang.StringBuffer, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat.forPattern(java.lang.String)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.DateTimeFormatterBuilder$Composite(org.joda.time.Chronology, java.util.ArrayList)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.iPrinters</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.isPrinter()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZonePrinter</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeParser)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimePrinter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser[])</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append0(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendOptional(org.joda.time.format.DateTimeParser)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneName()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneShortName()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.isPrinter(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toPrinter()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateElementParser()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTimeParser()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeElementParser()</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimePrinter.estimatePrintedLength()</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.print(long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.estimatePrintedLength()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.DateTimeFormatterBuilder$Composite(org.joda.time.Chronology, java.util.ArrayList)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimePrinter.getChronology()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.getChronology()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimePrinter.print(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.print(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimePrinter.print(long, org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getName(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getShortName(long, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.print(long, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimePrinter.print(long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.util.TimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.print(long, org.joda.time.DateTimeZone, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimePrinter.print(org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.toString(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.toString(java.lang.String, java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Instant.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.print(org.joda.time.ReadableInstant)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimePrinter.printTo(java.io.Writer, long)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.io.Writer, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimePrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.io.Writer, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimePrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimePrinter.printTo(java.io.Writer, org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.io.Writer, org.joda.time.ReadableInstant)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimePrinter.printTo(java.lang.StringBuffer, long)</name>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.lang.StringBuffer, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimePrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimePrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</name>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.print(long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDateTimeFormatter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$Composite.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DateTimePrinter.printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)</name>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.getMessage()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormat$FPrinter.printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DurationFormat</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormat.DurationFormat()</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormat.iDefault</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.DurationFormatterBuilder()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendDays()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendHours()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendMinutes()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendMonths()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeconds()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeparator(java.lang.String, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSuffix(java.lang.String, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendWeeks()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendYears()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toFormatter()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormat.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormat.INSTANCE</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormat.getInstance()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormat.getInstance(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormat.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormat.getDefault()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormat.iDefault</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormat.getInstance()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormat.INSTANCE</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormat.getInstance(java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormat.INSTANCE</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormat.iDefault</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormat.DurationFormat()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormat.getDefault()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormat.static {}</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormat.DurationFormat()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormat.INSTANCE</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DurationFormatter</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.format.DurationParser</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.format.DurationPrinter</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormat.DurationFormat()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormat.getDefault()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormat.iDefault</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.DurationFormatterBuilder$AlternateSelector(org.joda.time.format.DurationFormatter, java.util.List, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.countFieldsToPrint(org.joda.time.ReadableDuration, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.iPrimaryFormatter</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.DurationFormatterBuilder$Composite(java.util.List)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.countFieldsToPrint(org.joda.time.ReadableDuration, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.iFormatters</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.DurationFormatterBuilder$Separator(java.lang.String, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.DurationFormatterBuilder$Separator(java.lang.String, java.lang.String, org.joda.time.format.DurationFormatter, org.joda.time.format.DurationFormatter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.countFieldsToPrint(org.joda.time.ReadableDuration, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.finish(org.joda.time.format.DurationFormatter, org.joda.time.format.DurationFormatter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.iAfter</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.iBefore</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.merge(java.lang.String, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.append(org.joda.time.format.DurationFormatter)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeparator(java.lang.String, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.createComposite(java.util.List)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toFormatter()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toFormatter(java.util.List)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toParser()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toPrinter()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternate()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtended()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtendedWithWeeks()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateWithWeeks()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.iAlternate</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.iAlternateExtended</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.iAlternateExtendedWihWeeks</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.iAlternateWithWeeks</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.iStandard</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.standard()</inbound>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DurationFormatterBuilder</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormat.DurationFormat()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternate()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtended()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtendedWithWeeks()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateWithWeeks()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.standard()</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.DurationFormatterBuilder()</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.clear()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormat.DurationFormat()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternate()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtended()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtendedWithWeeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateWithWeeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.standard()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.PRINT_ZERO_ALWAYS</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.PRINT_ZERO_IF_SUPPORTED</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.PRINT_ZERO_RARELY</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.append(org.joda.time.format.DurationFormatter)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.List</outbound>
                <outbound type="feature" confirmed="no">java.util.List.add(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.clearPrefix()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iFormatters</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.appendDays()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendField(int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormat.DurationFormat()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternate()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtended()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtendedWithWeeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateWithWeeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.standard()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.appendField(int)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.util.List</outbound>
                <outbound type="feature" confirmed="no">java.util.List.add(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(int, int, int, boolean, int, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iAlternateFormatters</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iFormatters</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iMaxParsedDigits</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iMinPrintedDigits</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iPrefix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iPrintZeroSetting</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iRejectSignedValues</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendDays()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendHours()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendMinutes()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendMonths()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeconds()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendWeeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendYears()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.appendHours()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendField(int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormat.DurationFormat()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternate()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtended()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtendedWithWeeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateWithWeeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.standard()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.appendLiteral(java.lang.String)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.List</outbound>
                <outbound type="feature" confirmed="no">java.util.List.add(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal.DurationFormatterBuilder$Literal(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.clearPrefix()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iAlternateFormatters</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iFormatters</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternate()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtended()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtendedWithWeeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateWithWeeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.standard()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.appendMillis()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendField(int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormat.DurationFormat()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.appendMinutes()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendField(int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormat.DurationFormat()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternate()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtended()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtendedWithWeeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateWithWeeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.standard()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.appendMonths()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendField(int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormat.DurationFormat()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternate()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtended()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.standard()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.appendPrefix(java.lang.String)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix.DurationFormatterBuilder$SingularAffix(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendPrefix(org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtendedWithWeeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateWithWeeks()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.appendPrefix(java.lang.String, java.lang.String)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.DurationFormatterBuilder$PluralAffix(java.lang.String, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendPrefix(org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.appendPrefix(org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.DurationFormatterBuilder$CompositeAffix(org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iPrefix</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendPrefix(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendPrefix(java.lang.String, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.appendSeconds()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendField(int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormat.DurationFormat()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternate()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtended()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtendedWithWeeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateWithWeeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.standard()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.appendSeparator(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeparator(java.lang.String, java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternate()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtended()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtendedWithWeeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateWithWeeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.standard()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.appendSeparator(java.lang.String, java.lang.String)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException()</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.List</outbound>
                <outbound type="feature" confirmed="no">java.util.List.add(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.List.clear()</outbound>
                <outbound type="feature" confirmed="no">java.util.List.get(int)</outbound>
                <outbound type="feature" confirmed="no">java.util.List.set(int, java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.List.size()</outbound>
                <outbound type="feature" confirmed="no">java.util.List.subList(int, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.DurationFormatterBuilder$Separator(java.lang.String, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.merge(java.lang.String, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.clearPrefix()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.createComposite(java.util.List)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iFormatters</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormat.DurationFormat()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeparator(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.appendSuffix(java.lang.String)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix.DurationFormatterBuilder$SingularAffix(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSuffix(org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.standard()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.appendSuffix(java.lang.String, java.lang.String)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.DurationFormatterBuilder$PluralAffix(java.lang.String, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSuffix(org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormat.DurationFormat()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.appendSuffix(org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalStateException.IllegalStateException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.List</outbound>
                <outbound type="feature" confirmed="no">java.util.List.get(int)</outbound>
                <outbound type="feature" confirmed="no">java.util.List.lastIndexOf(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.List.set(int, java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.List.size()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(org.joda.time.format.DurationFormatterBuilder$FieldFormatter, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.clearPrefix()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iAlternateFormatters</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iFormatters</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSuffix(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSuffix(java.lang.String, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.appendWeeks()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendField(int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormat.DurationFormat()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtendedWithWeeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateWithWeeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.standard()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.appendYears()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendField(int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormat.DurationFormat()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternate()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtended()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtendedWithWeeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateWithWeeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.standard()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.clear()</name>
                <outbound type="feature" confirmed="no">java.util.ArrayList.ArrayList()</outbound>
                <outbound type="class" confirmed="no">java.util.List</outbound>
                <outbound type="feature" confirmed="no">java.util.List.clear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iAlternateFormatters</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iFavorFirstFieldForZero</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iFormatters</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iMaxParsedDigits</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iMinPrintedDigits</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iPrefix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iPrintZeroSetting</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iRejectSignedValues</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.DurationFormatterBuilder()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.clearPrefix()</name>
                <outbound type="class" confirmed="no">java.lang.IllegalStateException</outbound>
                <outbound type="feature" confirmed="no">java.lang.IllegalStateException.IllegalStateException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iPrefix</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.append(org.joda.time.format.DurationFormatter)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendLiteral(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeparator(java.lang.String, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSuffix(org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.createComposite(java.util.List)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.util.List</outbound>
                <outbound type="feature" confirmed="no">java.util.List.get(int)</outbound>
                <outbound type="feature" confirmed="no">java.util.List.size()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.DurationFormatterBuilder$Composite(java.util.List)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeparator(java.lang.String, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toFormatter(java.util.List)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.favorFirstFieldForZero()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iFavorFirstFieldForZero</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.favorLastFieldForZero()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iFavorFirstFieldForZero</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.iAlternateFormatters</name>
                <outbound type="class" confirmed="no">java.util.List</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendField(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendLiteral(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSuffix(org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.clear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toFormatter()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.iFavorFirstFieldForZero</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.clear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.favorFirstFieldForZero()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.favorLastFieldForZero()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toFormatter()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.iFormatters</name>
                <outbound type="class" confirmed="no">java.util.List</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.append(org.joda.time.format.DurationFormatter)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendField(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendLiteral(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeparator(java.lang.String, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSuffix(org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.clear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toFormatter()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.iMaxParsedDigits</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendField(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.clear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.maximumParsedDigits(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.iMinPrintedDigits</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendField(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.clear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.minimumPrintedDigits(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.iPrefix</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendField(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendPrefix(org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.clear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.clearPrefix()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.iPrintZeroSetting</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendField(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.clear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.printZeroAlways()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.printZeroIfSupported()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.printZeroRarely()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.iRejectSignedValues</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendField(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.clear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.rejectSignedValues(boolean)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.maximumParsedDigits(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iMaxParsedDigits</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.minimumPrintedDigits(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iMinPrintedDigits</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternate()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtended()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtendedWithWeeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateWithWeeks()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.printZeroAlways()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iPrintZeroSetting</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternate()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtended()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtendedWithWeeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateWithWeeks()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.printZeroIfSupported()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iPrintZeroSetting</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.standard()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.printZeroRarely()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iPrintZeroSetting</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.rejectSignedValues(boolean)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iRejectSignedValues</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.toFormatter()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.util.List</outbound>
                <outbound type="feature" confirmed="no">java.util.List.get(int)</outbound>
                <outbound type="feature" confirmed="no">java.util.List.size()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.DurationFormatterBuilder$AlternateSelector(org.joda.time.format.DurationFormatter, java.util.List, boolean)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iAlternateFormatters</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iFavorFirstFieldForZero</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iFormatters</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toFormatter(java.util.List)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormat.DurationFormat()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toPrinter()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternate()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtended()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtendedWithWeeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateWithWeeks()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.standard()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.toFormatter(java.util.List)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.util.List</outbound>
                <outbound type="feature" confirmed="no">java.util.List.get(int)</outbound>
                <outbound type="feature" confirmed="no">java.util.List.size()</outbound>
                <outbound type="feature" confirmed="no">java.util.List.subList(int, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.finish(org.joda.time.format.DurationFormatter, org.joda.time.format.DurationFormatter)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.createComposite(java.util.List)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toFormatter()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.toParser()</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toFormatter()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationParser</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder.toPrinter()</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toFormatter()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationPrinter</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DurationFormatterBuilder$AlternateSelector</name>
            <outbound type="class" confirmed="yes">org.joda.time.format.AbstractDurationFormatter</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$AlternateSelector.DurationFormatterBuilder$AlternateSelector(org.joda.time.format.DurationFormatter, java.util.List, boolean)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.util.List</outbound>
                <outbound type="feature" confirmed="no">java.util.List.size()</outbound>
                <outbound type="feature" confirmed="no">java.util.List.toArray(java.lang.Object[])</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.AbstractDurationFormatter()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.iAlternatePrinters</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.iFavorFirstFieldForZero</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.iPrimaryFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationPrinter</outbound>
                <outbound type="class" confirmed="no">org.joda.time.format.DurationPrinter[]</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toFormatter()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$AlternateSelector.calculatePrintedLength(org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.chooseFieldToPrint(org.joda.time.ReadableDuration)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.iAlternatePrinters</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.iPrimaryFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationPrinter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationPrinter.calculatePrintedLength(org.joda.time.ReadableDuration)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationPrinter.countFieldsToPrint(org.joda.time.ReadableDuration, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$AlternateSelector.chooseFieldToPrint(org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getDurationType()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.iAlternatePrinters</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.iFavorFirstFieldForZero</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(org.joda.time.format.DurationFormatterBuilder$FieldFormatter, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.getPrintZeroSetting()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.isSupported(org.joda.time.DurationType)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationPrinter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.countFieldsToPrint(org.joda.time.ReadableDuration, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$AlternateSelector.countFieldsToPrint(org.joda.time.ReadableDuration, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.chooseFieldToPrint(org.joda.time.ReadableDuration)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.iPrimaryFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationPrinter.countFieldsToPrint(org.joda.time.ReadableDuration, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$AlternateSelector.iAlternatePrinters</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationPrinter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.DurationFormatterBuilder$AlternateSelector(org.joda.time.format.DurationFormatter, java.util.List, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.chooseFieldToPrint(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$AlternateSelector.iFavorFirstFieldForZero</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.DurationFormatterBuilder$AlternateSelector(org.joda.time.format.DurationFormatter, java.util.List, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.chooseFieldToPrint(org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$AlternateSelector.iPrimaryFormatter</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.DurationFormatterBuilder$AlternateSelector(org.joda.time.format.DurationFormatter, java.util.List, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.countFieldsToPrint(org.joda.time.ReadableDuration, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$AlternateSelector.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.iPrimaryFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationParser.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$AlternateSelector.printTo(java.io.Writer, org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.chooseFieldToPrint(org.joda.time.ReadableDuration)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.iAlternatePrinters</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.iPrimaryFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationPrinter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationPrinter.countFieldsToPrint(org.joda.time.ReadableDuration, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationPrinter.printTo(java.io.Writer, org.joda.time.ReadableDuration)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$AlternateSelector.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.chooseFieldToPrint(org.joda.time.ReadableDuration)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.iAlternatePrinters</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.iPrimaryFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationPrinter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationPrinter.countFieldsToPrint(org.joda.time.ReadableDuration, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationPrinter.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DurationFormatterBuilder$Composite</name>
            <outbound type="class" confirmed="yes">org.joda.time.format.AbstractDurationFormatter</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$Composite.DurationFormatterBuilder$Composite(java.util.List)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.util.List</outbound>
                <outbound type="feature" confirmed="no">java.util.List.size()</outbound>
                <outbound type="feature" confirmed="no">java.util.List.toArray(java.lang.Object[])</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.AbstractDurationFormatter()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.iFormatters</outbound>
                <outbound type="class" confirmed="no">org.joda.time.format.DurationFormatter[]</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.createComposite(java.util.List)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$Composite.calculatePrintedLength(org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.iFormatters</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationPrinter.calculatePrintedLength(org.joda.time.ReadableDuration)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$Composite.countFieldsToPrint(org.joda.time.ReadableDuration, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.iFormatters</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationPrinter.countFieldsToPrint(org.joda.time.ReadableDuration)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$Composite.iFormatters</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.DurationFormatterBuilder$Composite(java.util.List)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.countFieldsToPrint(org.joda.time.ReadableDuration, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$Composite.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.UnsupportedOperationException.UnsupportedOperationException()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.iFormatters</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationParser.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$Composite.printTo(java.io.Writer, org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.iFormatters</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationPrinter.printTo(java.io.Writer, org.joda.time.ReadableDuration)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$Composite.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.iFormatters</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationPrinter.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DurationFormatterBuilder$CompositeAffix</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$CompositeAffix.DurationFormatterBuilder$CompositeAffix(org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.iLeft</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.iRight</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(org.joda.time.format.DurationFormatterBuilder$FieldFormatter, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendPrefix(org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$CompositeAffix.calculatePrintedLength(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.iLeft</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.iRight</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix.calculatePrintedLength(int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$CompositeAffix.iLeft</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.DurationFormatterBuilder$CompositeAffix(org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.calculatePrintedLength(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.parse(java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.printTo(java.io.Writer, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.printTo(java.lang.StringBuffer, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.scan(java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$CompositeAffix.iRight</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.DurationFormatterBuilder$CompositeAffix(org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.calculatePrintedLength(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.parse(java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.printTo(java.io.Writer, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.printTo(java.lang.StringBuffer, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.scan(java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$CompositeAffix.parse(java.lang.String, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.iLeft</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.iRight</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix.parse(java.lang.String, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$CompositeAffix.printTo(java.io.Writer, int)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.iLeft</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.iRight</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix.printTo(java.io.Writer, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$CompositeAffix.printTo(java.lang.StringBuffer, int)</name>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.iLeft</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.iRight</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix.printTo(java.lang.StringBuffer, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$CompositeAffix.scan(java.lang.String, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.iLeft</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.iRight</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix.scan(java.lang.String, int)</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.DurationFormatterBuilder$CompositeAffix(org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.calculatePrintedLength(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.iLeft</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.iRight</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.parse(java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.printTo(java.io.Writer, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.printTo(java.lang.StringBuffer, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.scan(java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(int, int, int, boolean, int, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(org.joda.time.format.DurationFormatterBuilder$FieldFormatter, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(org.joda.time.format.DurationFormatterBuilder$FieldFormatter, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iPrefix</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iSuffix</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendField(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendPrefix(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendPrefix(java.lang.String, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendPrefix(org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSuffix(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSuffix(java.lang.String, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSuffix(org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.clear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.clearPrefix()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.iPrefix</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix.calculatePrintedLength(int)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.calculatePrintedLength(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix.parse(java.lang.String, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.parse(java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix.printTo(java.io.Writer, int)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.printTo(java.io.Writer, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix.printTo(java.lang.StringBuffer, int)</name>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.printTo(java.lang.StringBuffer, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix.scan(java.lang.String, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.scan(java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DurationFormatterBuilder$FieldFormatter</name>
            <outbound type="class" confirmed="yes">org.joda.time.format.AbstractDurationFormatter</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.chooseFieldToPrint(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.countFieldsToPrint(org.joda.time.ReadableDuration, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSuffix(org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toFormatter()</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(int, int, int, boolean, int, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.AbstractDurationFormatter()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iFieldType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iMaxParsedDigits</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iMinPrintedDigits</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iPrefix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iPrintZeroSetting</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iRejectSignedValues</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iSuffix</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendField(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(org.joda.time.format.DurationFormatterBuilder$FieldFormatter, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.AbstractDurationFormatter()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iFieldType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iMaxParsedDigits</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iMinPrintedDigits</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iPrefix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iPrintZeroSetting</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iRejectSignedValues</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iSuffix</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.chooseFieldToPrint(org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(org.joda.time.format.DurationFormatterBuilder$FieldFormatter, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.AbstractDurationFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$CompositeAffix.DurationFormatterBuilder$CompositeAffix(org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iFieldType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iMaxParsedDigits</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iMinPrintedDigits</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iPrefix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iPrintZeroSetting</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iRejectSignedValues</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iSuffix</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSuffix(org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$FieldFormatter.calculatePrintedLength(org.joda.time.ReadableDuration)</name>
                <outbound type="feature" confirmed="no">java.lang.Math.max(int, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix.calculatePrintedLength(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.getFieldValue(org.joda.time.ReadableDuration)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iMinPrintedDigits</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iPrefix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iSuffix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.calculateDigitCount(int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$FieldFormatter.countFieldsToPrint(org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.getFieldValue(org.joda.time.ReadableDuration)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iPrintZeroSetting</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.countFieldsToPrint(org.joda.time.ReadableDuration, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$FieldFormatter.countFieldsToPrint(org.joda.time.ReadableDuration, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.countFieldsToPrint(org.joda.time.ReadableDuration)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$FieldFormatter.getFieldValue(org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isSupported()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.days()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.hours()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.millis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.minutes()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.months()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.seconds()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.weeks()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.years()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getDays()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getDurationType()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getHours()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getMinutes()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getMonths()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getSeconds()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getWeeks()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getYears()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iFieldType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iPrintZeroSetting</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.countFieldsToPrint(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$FieldFormatter.getPrintZeroSetting()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iPrintZeroSetting</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.chooseFieldToPrint(org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iFieldType</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(int, int, int, boolean, int, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(org.joda.time.format.DurationFormatterBuilder$FieldFormatter, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(org.joda.time.format.DurationFormatterBuilder$FieldFormatter, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.getFieldValue(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.isSupported(org.joda.time.DurationType)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.setFieldValue(org.joda.time.ReadWritableDuration, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iMaxParsedDigits</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(int, int, int, boolean, int, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(org.joda.time.format.DurationFormatterBuilder$FieldFormatter, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(org.joda.time.format.DurationFormatterBuilder$FieldFormatter, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iMinPrintedDigits</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(int, int, int, boolean, int, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(org.joda.time.format.DurationFormatterBuilder$FieldFormatter, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(org.joda.time.format.DurationFormatterBuilder$FieldFormatter, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iPrefix</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(int, int, int, boolean, int, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(org.joda.time.format.DurationFormatterBuilder$FieldFormatter, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(org.joda.time.format.DurationFormatterBuilder$FieldFormatter, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iPrintZeroSetting</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(int, int, int, boolean, int, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(org.joda.time.format.DurationFormatterBuilder$FieldFormatter, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(org.joda.time.format.DurationFormatterBuilder$FieldFormatter, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.countFieldsToPrint(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.getFieldValue(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.getPrintZeroSetting()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iRejectSignedValues</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(int, int, int, boolean, int, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(org.joda.time.format.DurationFormatterBuilder$FieldFormatter, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(org.joda.time.format.DurationFormatterBuilder$FieldFormatter, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iSuffix</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(int, int, int, boolean, int, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(org.joda.time.format.DurationFormatterBuilder$FieldFormatter, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.DurationFormatterBuilder$FieldFormatter(org.joda.time.format.DurationFormatterBuilder$FieldFormatter, org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$FieldFormatter.isSupported(org.joda.time.DurationType)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationField.isSupported()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.days()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.hours()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.millis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.minutes()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.months()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.seconds()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.weeks()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DurationType.years()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iFieldType</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.chooseFieldToPrint(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$FieldFormatter.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</name>
                <outbound type="feature" confirmed="no">java.lang.Integer.parseInt(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Math.min(int, int)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.charAt(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.substring(int, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableDuration.getDurationType()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix.parse(java.lang.String, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix.scan(java.lang.String, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iMaxParsedDigits</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iPrefix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iPrintZeroSetting</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iRejectSignedValues</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iSuffix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.isSupported(org.joda.time.DurationType)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.setFieldValue(org.joda.time.ReadWritableDuration, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$FieldFormatter.printTo(java.io.Writer, org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix.printTo(java.io.Writer, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.getFieldValue(org.joda.time.ReadableDuration)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iMinPrintedDigits</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iPrefix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iSuffix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writePaddedInteger(java.io.Writer, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writeUnpaddedInteger(java.io.Writer, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$FieldFormatter.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix.printTo(java.lang.StringBuffer, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.getFieldValue(org.joda.time.ReadableDuration)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iMinPrintedDigits</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iPrefix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iSuffix</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.appendPaddedInteger(java.lang.StringBuffer, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.appendUnpaddedInteger(java.lang.StringBuffer, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$FieldFormatter.setFieldValue(org.joda.time.ReadWritableDuration, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadWritableDuration.setDays(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadWritableDuration.setHours(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadWritableDuration.setMillis(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadWritableDuration.setMinutes(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadWritableDuration.setMonths(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadWritableDuration.setSeconds(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadWritableDuration.setWeeks(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadWritableDuration.setYears(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.iFieldType</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DurationFormatterBuilder$Literal</name>
            <outbound type="class" confirmed="yes">org.joda.time.format.AbstractDurationFormatter</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$Literal.DurationFormatterBuilder$Literal(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.AbstractDurationFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal.iText</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendLiteral(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$Literal.calculatePrintedLength(org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal.iText</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$Literal.countFieldsToPrint(org.joda.time.ReadableDuration, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$Literal.iText</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal.DurationFormatterBuilder$Literal(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$Literal.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.regionMatches(boolean, int, java.lang.String, int, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal.iText</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$Literal.printTo(java.io.Writer, org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="feature" confirmed="no">java.io.Writer.write(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal.iText</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$Literal.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Literal.iText</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DurationFormatterBuilder$PluralAffix</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$PluralAffix.DurationFormatterBuilder$PluralAffix(java.lang.String, java.lang.String)</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.iPluralText</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.iSingularText</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendPrefix(java.lang.String, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSuffix(java.lang.String, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$PluralAffix.calculatePrintedLength(int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.iPluralText</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.iSingularText</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$PluralAffix.iPluralText</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.DurationFormatterBuilder$PluralAffix(java.lang.String, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.calculatePrintedLength(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.parse(java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.printTo(java.io.Writer, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.printTo(java.lang.StringBuffer, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.scan(java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$PluralAffix.iSingularText</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.DurationFormatterBuilder$PluralAffix(java.lang.String, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.calculatePrintedLength(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.parse(java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.printTo(java.io.Writer, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.printTo(java.lang.StringBuffer, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.scan(java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$PluralAffix.parse(java.lang.String, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.regionMatches(boolean, int, java.lang.String, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.iPluralText</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.iSingularText</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$PluralAffix.printTo(java.io.Writer, int)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="feature" confirmed="no">java.io.Writer.write(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.iPluralText</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.iSingularText</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$PluralAffix.printTo(java.lang.StringBuffer, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.iPluralText</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.iSingularText</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$PluralAffix.scan(java.lang.String, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.regionMatches(boolean, int, java.lang.String, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.iPluralText</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$PluralAffix.iSingularText</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DurationFormatterBuilder$Separator</name>
            <outbound type="class" confirmed="yes">org.joda.time.format.AbstractDurationFormatter</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeparator(java.lang.String, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toFormatter(java.util.List)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$Separator.DurationFormatterBuilder$Separator(java.lang.String, java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.DurationFormatterBuilder$Separator(java.lang.String, java.lang.String, org.joda.time.format.DurationFormatter, org.joda.time.format.DurationFormatter)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeparator(java.lang.String, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$Separator.DurationFormatterBuilder$Separator(java.lang.String, java.lang.String, org.joda.time.format.DurationFormatter, org.joda.time.format.DurationFormatter)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.AbstractDurationFormatter()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.iAfter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.iBefore</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.iFinalText</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.iText</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.DurationFormatterBuilder$Separator(java.lang.String, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.finish(org.joda.time.format.DurationFormatter, org.joda.time.format.DurationFormatter)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.merge(java.lang.String, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$Separator.calculatePrintedLength(org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.iAfter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.iBefore</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.iFinalText</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.iText</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationPrinter.calculatePrintedLength(org.joda.time.ReadableDuration)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationPrinter.countFieldsToPrint(org.joda.time.ReadableDuration, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$Separator.countFieldsToPrint(org.joda.time.ReadableDuration, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.iAfter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.iBefore</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationPrinter.countFieldsToPrint(org.joda.time.ReadableDuration, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$Separator.finish(org.joda.time.format.DurationFormatter, org.joda.time.format.DurationFormatter)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.DurationFormatterBuilder$Separator(java.lang.String, java.lang.String, org.joda.time.format.DurationFormatter, org.joda.time.format.DurationFormatter)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.iFinalText</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.iText</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toFormatter(java.util.List)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$Separator.iAfter</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.DurationFormatterBuilder$Separator(java.lang.String, java.lang.String, org.joda.time.format.DurationFormatter, org.joda.time.format.DurationFormatter)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.countFieldsToPrint(org.joda.time.ReadableDuration, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.merge(java.lang.String, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$Separator.iBefore</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.DurationFormatterBuilder$Separator(java.lang.String, java.lang.String, org.joda.time.format.DurationFormatter, org.joda.time.format.DurationFormatter)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.countFieldsToPrint(org.joda.time.ReadableDuration, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.merge(java.lang.String, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$Separator.iFinalText</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.DurationFormatterBuilder$Separator(java.lang.String, java.lang.String, org.joda.time.format.DurationFormatter, org.joda.time.format.DurationFormatter)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.finish(org.joda.time.format.DurationFormatter, org.joda.time.format.DurationFormatter)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.merge(java.lang.String, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$Separator.iText</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.DurationFormatterBuilder$Separator(java.lang.String, java.lang.String, org.joda.time.format.DurationFormatter, org.joda.time.format.DurationFormatter)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.finish(org.joda.time.format.DurationFormatter, org.joda.time.format.DurationFormatter)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.merge(java.lang.String, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$Separator.merge(java.lang.String, java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.DurationFormatterBuilder$Separator(java.lang.String, java.lang.String, org.joda.time.format.DurationFormatter, org.joda.time.format.DurationFormatter)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.iAfter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.iBefore</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.iFinalText</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.iText</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeparator(java.lang.String, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$Separator.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.regionMatches(boolean, int, java.lang.String, int, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.iAfter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.iBefore</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.iFinalText</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.iText</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationParser.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$Separator.printTo(java.io.Writer, org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="feature" confirmed="no">java.io.Writer.write(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.iAfter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.iBefore</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.iFinalText</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.iText</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationPrinter.countFieldsToPrint(org.joda.time.ReadableDuration, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationPrinter.printTo(java.io.Writer, org.joda.time.ReadableDuration)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$Separator.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.iAfter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.iBefore</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.iFinalText</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.iText</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationPrinter.countFieldsToPrint(org.joda.time.ReadableDuration, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationPrinter.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DurationFormatterBuilder$SingularAffix</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$DurationFieldAffix</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$SingularAffix.DurationFormatterBuilder$SingularAffix(java.lang.String)</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix.iText</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendPrefix(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSuffix(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$SingularAffix.calculatePrintedLength(int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix.iText</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$SingularAffix.iText</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix.DurationFormatterBuilder$SingularAffix(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix.calculatePrintedLength(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix.parse(java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix.printTo(java.io.Writer, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix.printTo(java.lang.StringBuffer, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix.scan(java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$SingularAffix.parse(java.lang.String, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.regionMatches(boolean, int, java.lang.String, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix.iText</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$SingularAffix.printTo(java.io.Writer, int)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="feature" confirmed="no">java.io.Writer.write(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix.iText</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$SingularAffix.printTo(java.lang.StringBuffer, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix.iText</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationFormatterBuilder$SingularAffix.scan(java.lang.String, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.regionMatches(boolean, int, java.lang.String, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$SingularAffix.iText</outbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>org.joda.time.format.DurationFormatter[]</name>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.DurationFormatterBuilder$Composite(java.util.List)</inbound>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DurationParser</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.parseMutableDuration(org.joda.time.DurationType, java.lang.String)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toParser()</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationParser.parseDuration(org.joda.time.DurationType, java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Duration</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationParser.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableDuration</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.parseMutableDuration(org.joda.time.DurationType, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.parseInto(org.joda.time.ReadWritableDuration, java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationParser.parseMutableDuration(org.joda.time.DurationType, java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationType</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.MutableDuration</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.DurationPrinter</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.countFieldsToPrint(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.print(org.joda.time.ReadableDuration)</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.DurationFormatterBuilder$AlternateSelector(org.joda.time.format.DurationFormatter, java.util.List, boolean)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.chooseFieldToPrint(org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.iAlternatePrinters</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toPrinter()</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationPrinter.calculatePrintedLength(org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.print(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationPrinter.countFieldsToPrint(org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.countFieldsToPrint(org.joda.time.ReadableDuration, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationPrinter.countFieldsToPrint(org.joda.time.ReadableDuration, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.countFieldsToPrint(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.countFieldsToPrint(org.joda.time.ReadableDuration, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.countFieldsToPrint(org.joda.time.ReadableDuration, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationPrinter.print(org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationPrinter.printTo(java.io.Writer, org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.DurationPrinter.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</name>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableDuration</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.AbstractDurationFormatter.print(org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Composite.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$Separator.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
            </feature>
        </class>
        <class confirmed="no">
            <name>org.joda.time.format.DurationPrinter[]</name>
            <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$AlternateSelector.DurationFormatterBuilder$AlternateSelector(org.joda.time.format.DurationFormatter, java.util.List, boolean)</inbound>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.FormatUtils</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.FormatUtils.FormatUtils()</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.FormatUtils.LOG_10</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.appendPaddedInteger(java.lang.StringBuffer, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.appendPaddedInteger(java.lang.StringBuffer, long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.calculateDigitCount(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writePaddedInteger(java.io.Writer, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writePaddedInteger(java.io.Writer, long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.FormatUtils.appendPaddedInteger(java.lang.StringBuffer, int, int)</name>
                <outbound type="feature" confirmed="no">java.lang.Integer.toString(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Math.log(double)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.LOG_10</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.appendPaddedInteger(java.lang.StringBuffer, long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.FormatUtils.appendPaddedInteger(java.lang.StringBuffer, long, int)</name>
                <outbound type="feature" confirmed="no">java.lang.Long.toString(long)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Math.log(double)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.LOG_10</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.appendPaddedInteger(java.lang.StringBuffer, int, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.FormatUtils.appendUnpaddedInteger(java.lang.StringBuffer, int)</name>
                <outbound type="feature" confirmed="no">java.lang.Integer.toString(int)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber.printTo(java.lang.StringBuffer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.printTo(java.lang.StringBuffer, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.appendUnpaddedInteger(java.lang.StringBuffer, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.FormatUtils.appendUnpaddedInteger(java.lang.StringBuffer, long)</name>
                <outbound type="feature" confirmed="no">java.lang.Long.toString(long)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.appendUnpaddedInteger(java.lang.StringBuffer, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.FormatUtils.calculateDigitCount(int)</name>
                <outbound type="feature" confirmed="no">java.lang.Math.log(double)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.LOG_10</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.calculatePrintedLength(org.joda.time.ReadableDuration)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.FormatUtils.parseTwoDigits(java.lang.String, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.charAt(int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.FormatUtils.static {}</name>
                <outbound type="feature" confirmed="no">java.lang.Math.log(double)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.LOG_10</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.FormatUtils.writePaddedInteger(java.io.Writer, int, int)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="feature" confirmed="no">java.io.Writer.write(int)</outbound>
                <outbound type="feature" confirmed="no">java.io.Writer.write(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Integer.toString(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Math.log(double)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.LOG_10</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffsetFormatter.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writePaddedInteger(java.io.Writer, long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.FormatUtils.writePaddedInteger(java.io.Writer, long, int)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="feature" confirmed="no">java.io.Writer.write(int)</outbound>
                <outbound type="feature" confirmed="no">java.io.Writer.write(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Long.toString(long)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Math.log(double)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.LOG_10</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writePaddedInteger(java.io.Writer, int, int)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.FormatUtils.writeUnpaddedInteger(java.io.Writer, int)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="feature" confirmed="no">java.io.Writer.write(int)</outbound>
                <outbound type="feature" confirmed="no">java.io.Writer.write(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Integer.toString(int)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber.printTo(java.io.Writer, long, org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder$FieldFormatter.printTo(java.io.Writer, org.joda.time.ReadableDuration)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writeUnpaddedInteger(java.io.Writer, long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.FormatUtils.writeUnpaddedInteger(java.io.Writer, long)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.Writer</outbound>
                <outbound type="feature" confirmed="no">java.io.Writer.write(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Long.toString(long)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.FormatUtils.writeUnpaddedInteger(java.io.Writer, int)</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.ISODateTimeFormat</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.Instant.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.getMessage()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getInstantMillis(java.lang.Object, org.joda.time.Chronology)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getInstantMillis(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseTime(java.lang.String)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.ISODateTimeFormat(org.joda.time.Chronology)</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance(org.joda.time.Chronology)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.basicDate()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfMonth(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMonthOfYear(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendYear(int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.bd</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicDateTime()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.basicDateTime()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeFormatter)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(char)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicDate()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicTime()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.bdt</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.basicTime()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendHourOfDay(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMinuteOfHour(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendSecondOfMinute(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneOffset(java.lang.String, boolean, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.bt</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicDateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicWeekDateTime()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.basicWeekDate()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfWeek(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(char)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendWeekOfWeekyear(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendWeekyear(int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.bwd</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicWeekDateTime()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.basicWeekDateTime()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeFormatter)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(char)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicTime()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicWeekDate()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.bwdt</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.bd</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicDate()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.bdt</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicDateTime()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.bt</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicTime()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.bwd</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicWeekDate()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.bwdt</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicWeekDateTime()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.cCache</name>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.date()</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearMonthDay()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinuteSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinuteSecondFraction()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTime()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.dateElementParser()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeFormatter)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser[])</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendOptional(org.joda.time.format.DateTimeParser)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toParser()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dayOfMonthElement()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dayOfWeekElement()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dayOfYearElement()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dpe</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.monthElement()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekElement()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearElement()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearElement()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTimeParser()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.dateHour()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeFormatter)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(char)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.date()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dh</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hour()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.dateHourMinute()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeFormatter)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(char)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.date()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dhm</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinute()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.dateHourMinuteSecond()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeFormatter)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(char)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.date()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dhms</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinuteSecond()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.dateHourMinuteSecondFraction()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeFormatter)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(char)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.date()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dhmsf</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinuteSecondFraction()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.dateParser()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeFormatter)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeParser)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(char)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendOptional(org.joda.time.format.DateTimeParser)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toParser()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateElementParser()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dp</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.offsetElement()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.dateTime()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeFormatter)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(char)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.date()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dt</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.time()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Instant.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.getMessage()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.dateTimeParser()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeFormatter)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeParser)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser[])</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(char)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendOptional(org.joda.time.format.DateTimeParser)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toParser()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateElementParser()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dtp</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.offsetElement()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeElementParser()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getInstantMillis(java.lang.Object, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getInstantMillis(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.dayOfMonthElement()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfMonth(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(char)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dme</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateElementParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearMonthDay()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.dayOfWeekElement()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfWeek(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(char)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dwe</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateElementParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearWeekDay()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.dayOfYearElement()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendDayOfYear(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(char)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dye</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateElementParser()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.dh</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHour()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.dhm</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinute()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.dhms</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinuteSecond()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.dhmsf</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinuteSecondFraction()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.dme</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dayOfMonthElement()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.dp</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateParser()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.dpe</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateElementParser()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.dt</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTime()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.dtp</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTimeParser()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.dwe</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dayOfWeekElement()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.dye</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dayOfYearElement()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.fractionElement()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfSecond(int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(char)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.fse</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinuteSecondFraction()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.fse</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.fractionElement()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.getInstance()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance(org.joda.time.Chronology)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.getInstance(org.joda.time.Chronology)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.get(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.put(java.lang.Object, java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.ISODateTimeFormat(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.cCache</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractInterval.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.GJChronology.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.chrono.LimitChronology$LimitException.getMessage()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getInstantMillis(java.lang.Object, org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.getInstantMillis(java.lang.Object, org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstanceUTC()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseTime(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.getInstance(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstance(org.joda.time.DateTimeZone)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance(org.joda.time.Chronology)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.getInstanceUTC()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance(org.joda.time.Chronology)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.Instant.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.hde</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourElement()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.hm</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinute()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.hms</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinuteSecond()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.hmsf</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinuteSecondFraction()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.hour()</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourElement()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHour()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.hourElement()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendHourOfDay(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hde</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinuteSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinuteSecondFraction()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeElementParser()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.hourMinute()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeFormatter)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hm</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourElement()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.minuteElement()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinute()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.hourMinuteSecond()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeFormatter)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hms</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourElement()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.minuteElement()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.secondElement()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinuteSecond()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.hourMinuteSecondFraction()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeFormatter)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.fractionElement()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hmsf</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourElement()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.minuteElement()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.secondElement()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinuteSecondFraction()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.time()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseTime(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.iChrono</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.ISODateTimeFormat(org.joda.time.Chronology)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicDate()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicDateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicWeekDate()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.basicWeekDateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateElementParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinuteSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateHourMinuteSecondFraction()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTimeParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dayOfMonthElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dayOfWeekElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dayOfYearElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.fractionElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinuteSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinuteSecondFraction()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.minuteElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.monthElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.offsetElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.secondElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.time()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeElementParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekDateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearWeekDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearElement()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearMonthDay()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.mhe</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.minuteElement()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.minuteElement()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(char)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMinuteOfHour(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.mhe</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinuteSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinuteSecondFraction()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeElementParser()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.monthElement()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(char)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendMonthOfYear(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.mye</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateElementParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearMonthDay()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.mye</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.monthElement()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.offsetElement()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneOffset(java.lang.String, boolean, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.ze</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTimeParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.time()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeParser()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.secondElement()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(char)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendSecondOfMinute(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.sme</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinuteSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinuteSecondFraction()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeElementParser()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.sme</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.secondElement()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.static {}</name>
                <outbound type="feature" confirmed="no">java.util.HashMap.HashMap(int)</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.cCache</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.t</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.time()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.time()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeFormatter)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinuteSecondFraction()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.offsetElement()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.t</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekDateTime()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.timeElementParser()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeFormatter)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeParser)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimePrinter, org.joda.time.format.DateTimeParser[])</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfHour(int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfMinute(int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendFractionOfSecond(int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(char)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendOptional(org.joda.time.format.DateTimeParser)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toParser()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimePrinter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourElement()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.minuteElement()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.secondElement()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.tpe</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateTimeParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeParser()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.timeParser()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeParser)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(char)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendOptional(org.joda.time.format.DateTimeParser)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toParser()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.offsetElement()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeElementParser()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.tp</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.tp</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeParser()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.tpe</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeParser</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.timeElementParser()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.wdt</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekDateTime()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.we</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearElement()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.weekDate()</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearWeekDay()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekDateTime()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.weekDateTime()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeFormatter)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(char)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.time()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.wdt</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekDate()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.weekElement()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendWeekOfWeekyear(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.wwe</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateElementParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearWeekDay()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.weekyear()</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearElement()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.weekyearElement()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendWeekyear(int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.we</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateElementParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearWeekDay()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.weekyearWeek()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeFormatter)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekElement()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearElement()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.ww</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.weekyearWeekDay()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeFormatter)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dayOfWeekElement()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekElement()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearElement()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.wwd</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekDate()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.ww</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearWeek()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.wwd</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekyearWeekDay()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.wwe</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.weekElement()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.ye</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearElement()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.year()</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearElement()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.yearElement()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.appendYear(int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.ye</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dateElementParser()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.year()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearMonthDay()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.yearMonth()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeFormatter)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.monthElement()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearElement()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.ym</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.yearMonthDay()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.append(org.joda.time.format.DateTimeFormatter)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.dayOfMonthElement()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.iChrono</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.monthElement()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearElement()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.ymd</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.date()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.ym</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearMonth()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.ymd</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.yearMonthDay()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODateTimeFormat.ze</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.offsetElement()</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.format.ISODurationFormat</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODurationFormat.INSTANCE</name>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.getInstance()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODurationFormat.ISODurationFormat()</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODurationFormat.alternate()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.DurationFormatterBuilder()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendDays()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendHours()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendLiteral(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendMinutes()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendMonths()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeconds()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeparator(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendYears()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.minimumPrintedDigits(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.printZeroAlways()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.iAlternate</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODurationFormat.alternateExtended()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.DurationFormatterBuilder()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendDays()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendHours()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendLiteral(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendMinutes()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendMonths()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeconds()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeparator(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendYears()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.minimumPrintedDigits(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.printZeroAlways()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.iAlternateExtended</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODurationFormat.alternateExtendedWithWeeks()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.DurationFormatterBuilder()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendDays()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendHours()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendLiteral(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendMinutes()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendPrefix(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeconds()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeparator(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendWeeks()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendYears()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.minimumPrintedDigits(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.printZeroAlways()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.iAlternateExtendedWihWeeks</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODurationFormat.alternateWithWeeks()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.DurationFormatterBuilder()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendDays()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendHours()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendLiteral(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendMinutes()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendPrefix(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeconds()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeparator(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendWeeks()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendYears()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.minimumPrintedDigits(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.printZeroAlways()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.iAlternateWithWeeks</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODurationFormat.getInstance()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.INSTANCE</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODurationFormat.iAlternate</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternate()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODurationFormat.iAlternateExtended</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtended()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODurationFormat.iAlternateExtendedWihWeeks</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateExtendedWithWeeks()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODurationFormat.iAlternateWithWeeks</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.alternateWithWeeks()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODurationFormat.iStandard</name>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.standard()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODurationFormat.standard()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatter</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DurationFormatterBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.DurationFormatterBuilder()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendDays()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendHours()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendLiteral(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendMinutes()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendMonths()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeconds()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSeparator(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendSuffix(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendWeeks()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.appendYears()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.printZeroIfSupported()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DurationFormatterBuilder.toFormatter()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.iStandard</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.AbstractDuration.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableDuration, java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.convert.StringConverter.setInto(org.joda.time.ReadWritableInterval, java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.format.ISODurationFormat.static {}</name>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.INSTANCE</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODurationFormat.ISODurationFormat()</outbound>
            </feature>
        </class>
    </package>
    <package confirmed="yes">
        <name>org.joda.time.property</name>
        <class confirmed="yes">
            <name>org.joda.time.property.AbstractReadableInstantFieldProperty</name>
            <outbound type="class" confirmed="no">java.io.Serializable</outbound>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="class" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.property.DateTimeFieldProperty</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.property.AbstractReadableInstantFieldProperty.AbstractReadableInstantFieldProperty()</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.DateOnlyFieldProperty(org.joda.time.DateOnly, org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.DateTimeFieldProperty(org.joda.time.DateTime, org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.TimeOnlyFieldProperty(org.joda.time.TimeOnly, org.joda.time.DateTimeField)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.AbstractReadableInstantFieldProperty.compareTo(org.joda.time.ReadableInstant)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.get(org.joda.time.DateTimeField)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.get()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.AbstractReadableInstantFieldProperty.get()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getInstant()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.compareTo(org.joda.time.ReadableInstant)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.AbstractReadableInstantFieldProperty.getAsShortText()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getAsShortText(java.util.Locale)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.AbstractReadableInstantFieldProperty.getAsShortText(java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getAsShortText(long, java.util.Locale)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getInstant()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getAsShortText()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.AbstractReadableInstantFieldProperty.getAsText()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getAsText(long, java.util.Locale)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getInstant()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.AbstractReadableInstantFieldProperty.getAsText(java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getAsText(long, java.util.Locale)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getInstant()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.AbstractReadableInstantFieldProperty.getDifference(org.joda.time.ReadableInstant)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDifference(long, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getInstant()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.AbstractReadableInstantFieldProperty.getDifferenceAsLong(org.joda.time.ReadableInstant)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDifferenceAsLong(long, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getInstant()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.AbstractReadableInstantFieldProperty.getDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getDurationField()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.AbstractReadableInstantFieldProperty.getField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.compareTo(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.get()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getAsShortText(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getAsText()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getAsText(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getDifference(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getDifferenceAsLong(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getLeapAmount()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getLeapDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getMaximumShortTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getMaximumTextLength(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getMaximumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getMaximumValueOverall()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getMinimumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getMinimumValueOverall()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getName()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getRangeDurationField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.isLeap()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.remainder()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.AbstractReadableInstantFieldProperty.getInstant()</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.get()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getAsShortText(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getAsText()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getAsText(java.util.Locale)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getDifference(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getDifferenceAsLong(org.joda.time.ReadableInstant)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getLeapAmount()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getMaximumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getMinimumValue()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.isLeap()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.remainder()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.AbstractReadableInstantFieldProperty.getLeapAmount()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getLeapAmount(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getInstant()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.AbstractReadableInstantFieldProperty.getLeapDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getLeapDurationField()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.AbstractReadableInstantFieldProperty.getMaximumShortTextLength(java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMaximumShortTextLength(java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.AbstractReadableInstantFieldProperty.getMaximumTextLength(java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMaximumTextLength(java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.AbstractReadableInstantFieldProperty.getMaximumValue()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMaximumValue(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getInstant()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.AbstractReadableInstantFieldProperty.getMaximumValueOverall()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMaximumValue()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.AbstractReadableInstantFieldProperty.getMinimumValue()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMinimumValue(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getInstant()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.AbstractReadableInstantFieldProperty.getMinimumValueOverall()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getMinimumValue()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.AbstractReadableInstantFieldProperty.getName()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getName()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getField()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.AbstractReadableInstantFieldProperty.getRangeDurationField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.getRangeDurationField()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DurationField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getField()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.AbstractReadableInstantFieldProperty.isLeap()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.isLeap(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getInstant()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.AbstractReadableInstantFieldProperty.remainder()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.remainder(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getInstant()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.AbstractReadableInstantFieldProperty.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.AbstractReadableInstantFieldProperty.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.getName()</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.property.DateOnlyFieldProperty</name>
            <outbound type="class" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.centuryOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.dayOfMonth()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.dayOfWeek()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.dayOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.era()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.monthOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.weekOfWeekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.weekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.year()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.yearOfCentury()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.yearOfEra()</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateOnlyFieldProperty.DateOnlyFieldProperty(org.joda.time.DateOnly, org.joda.time.DateTimeField)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateOnly</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.AbstractReadableInstantFieldProperty()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.iInstant</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.centuryOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.dayOfMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.dayOfWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.dayOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.era()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.monthOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.weekOfWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.weekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.year()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.yearOfCentury()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateOnly.yearOfEra()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateOnlyFieldProperty.addToCopy(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateOnly</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateOnly.withMillis(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateOnlyFieldProperty.addToCopy(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateOnly</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateOnly.withMillis(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateOnlyFieldProperty.addWrappedToCopy(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateOnly</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateOnly.withMillis(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.addWrapped(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateOnlyFieldProperty.getDateTime()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateOnly</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateOnlyFieldProperty.getField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateOnlyFieldProperty.getInstant()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateOnly</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateOnlyFieldProperty.iField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.DateOnlyFieldProperty(org.joda.time.DateOnly, org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.addToCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.addToCopy(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.addWrappedToCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.getField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundCeilingCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundFloorCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundHalfCeilingCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundHalfEvenCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundHalfFloorCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.setCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.setCopy(java.lang.String, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateOnlyFieldProperty.iInstant</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateOnly</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.DateOnlyFieldProperty(org.joda.time.DateOnly, org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.addToCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.addToCopy(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.addWrappedToCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.getDateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.getInstant()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundCeilingCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundFloorCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundHalfCeilingCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundHalfEvenCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.roundHalfFloorCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.setCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.setCopy(java.lang.String, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateOnlyFieldProperty.roundCeilingCopy()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateOnly</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateOnly.withMillis(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundCeiling(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateOnlyFieldProperty.roundFloorCopy()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateOnly</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateOnly.withMillis(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundFloor(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateOnlyFieldProperty.roundHalfCeilingCopy()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateOnly</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateOnly.withMillis(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundHalfCeiling(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateOnlyFieldProperty.roundHalfEvenCopy()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateOnly</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateOnly.withMillis(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundHalfEven(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateOnlyFieldProperty.roundHalfFloorCopy()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateOnly</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateOnly.withMillis(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundHalfFloor(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateOnlyFieldProperty.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateOnlyFieldProperty.setCopy(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateOnly</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateOnly.withMillis(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateOnlyFieldProperty.setCopy(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateOnly</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.setCopy(java.lang.String, java.util.Locale)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateOnlyFieldProperty.setCopy(java.lang.String, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateOnly</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateOnly.withMillis(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, java.lang.String, java.util.Locale)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.iInstant</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateOnlyFieldProperty.setCopy(java.lang.String)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.property.DateTimeFieldProperty</name>
            <outbound type="class" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.centuryOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.dayOfMonth()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.dayOfWeek()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.dayOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.era()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.hourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.millisOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.millisOfSecond()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.minuteOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.minuteOfHour()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.monthOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.secondOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.secondOfMinute()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.weekOfWeekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.weekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.year()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.yearOfCentury()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTime.yearOfEra()</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateTimeFieldProperty.DateTimeFieldProperty(org.joda.time.DateTime, org.joda.time.DateTimeField)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.AbstractReadableInstantFieldProperty()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.iInstant</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.centuryOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.dayOfMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.dayOfWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.dayOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.era()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.hourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.millisOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.millisOfSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.minuteOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.minuteOfHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.monthOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.secondOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.secondOfMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.weekOfWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.weekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.year()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.yearOfCentury()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTime.yearOfEra()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateTimeFieldProperty.addToCopy(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTime.withMillis(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateTimeFieldProperty.addToCopy(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTime.withMillis(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateTimeFieldProperty.addWrappedToCopy(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTime.withMillis(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.addWrapped(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateTimeFieldProperty.getField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateTimeFieldProperty.getInstant()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateTimeFieldProperty.iField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.DateTimeFieldProperty(org.joda.time.DateTime, org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.addToCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.addToCopy(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.addWrappedToCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.getField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundCeilingCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundFloorCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundHalfCeilingCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundHalfEvenCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundHalfFloorCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.setCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.setCopy(java.lang.String, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateTimeFieldProperty.iInstant</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.DateTimeFieldProperty(org.joda.time.DateTime, org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.addToCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.addToCopy(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.addWrappedToCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.getInstant()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundCeilingCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundFloorCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundHalfCeilingCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundHalfEvenCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.roundHalfFloorCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.setCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.setCopy(java.lang.String, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateTimeFieldProperty.roundCeilingCopy()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTime.withMillis(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundCeiling(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateTimeFieldProperty.roundFloorCopy()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTime.withMillis(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundFloor(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateTimeFieldProperty.roundHalfCeilingCopy()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTime.withMillis(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundHalfCeiling(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateTimeFieldProperty.roundHalfEvenCopy()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTime.withMillis(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundHalfEven(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateTimeFieldProperty.roundHalfFloorCopy()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTime.withMillis(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundHalfFloor(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateTimeFieldProperty.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateTimeFieldProperty.setCopy(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTime.withMillis(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateTimeFieldProperty.setCopy(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.setCopy(java.lang.String, java.util.Locale)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.DateTimeFieldProperty.setCopy(java.lang.String, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTime</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTime.withMillis(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, java.lang.String, java.util.Locale)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.iInstant</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.DateTimeFieldProperty.setCopy(java.lang.String)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.property.ReadWritableInstantFieldProperty</name>
            <outbound type="class" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.centuryOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.dayOfMonth()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.dayOfWeek()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.dayOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.era()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.monthOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.weekOfWeekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.weekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.year()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.yearOfCentury()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.yearOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.centuryOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.dayOfMonth()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.dayOfWeek()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.dayOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.era()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.hourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.millisOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.millisOfSecond()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.minuteOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.minuteOfHour()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.monthOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.secondOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.secondOfMinute()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.weekOfWeekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.weekyear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.year()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.yearOfCentury()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.yearOfEra()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.clockhourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.clockhourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.halfdayOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.hourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.hourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.millisOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.millisOfSecond()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.minuteOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.minuteOfHour()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.secondOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.secondOfMinute()</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.AbstractReadableInstantFieldProperty()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.iInstant</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.centuryOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.dayOfMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.dayOfWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.dayOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.era()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.monthOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.weekOfWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.weekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.year()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.yearOfCentury()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateOnly.yearOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.centuryOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.dayOfMonth()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.dayOfWeek()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.dayOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.era()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.hourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.millisOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.millisOfSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.minuteOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.minuteOfHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.monthOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.secondOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.secondOfMinute()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.weekOfWeekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.weekyear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.year()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.yearOfCentury()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.yearOfEra()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.clockhourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.clockhourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.halfdayOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.hourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.hourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.millisOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.millisOfSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.minuteOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.minuteOfHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.secondOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.MutableTimeOnly.secondOfMinute()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.ReadWritableInstantFieldProperty.add(int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadWritableInstant.setMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.getField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.ReadWritableInstantFieldProperty.add(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadWritableInstant.setMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.getField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.ReadWritableInstantFieldProperty.addWrapped(int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.addWrapped(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadWritableInstant.setMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.getField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.ReadWritableInstantFieldProperty.getField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.iField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.add(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.add(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.addWrapped(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundCeiling()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundFloor()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundHalfCeiling()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundHalfEven()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundHalfFloor()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.set(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.set(java.lang.String, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.ReadWritableInstantFieldProperty.getInstant()</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.ReadWritableInstantFieldProperty.iField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.getField()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.ReadWritableInstantFieldProperty.iInstant</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.ReadWritableInstantFieldProperty(org.joda.time.ReadWritableInstant, org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.add(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.add(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.addWrapped(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.getInstant()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundCeiling()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundFloor()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundHalfCeiling()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundHalfEven()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.roundHalfFloor()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.set(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.set(java.lang.String, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.ReadWritableInstantFieldProperty.roundCeiling()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundCeiling(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadWritableInstant.setMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.getField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.ReadWritableInstantFieldProperty.roundFloor()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundFloor(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadWritableInstant.setMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.getField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.ReadWritableInstantFieldProperty.roundHalfCeiling()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundHalfCeiling(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadWritableInstant.setMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.getField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.ReadWritableInstantFieldProperty.roundHalfEven()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundHalfEven(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadWritableInstant.setMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.getField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.ReadWritableInstantFieldProperty.roundHalfFloor()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundHalfFloor(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadWritableInstant.setMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.getField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.ReadWritableInstantFieldProperty.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.ReadWritableInstantFieldProperty.set(int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadWritableInstant.setMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.getField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.ReadWritableInstantFieldProperty.set(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.set(java.lang.String, java.util.Locale)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.ReadWritableInstantFieldProperty.set(java.lang.String, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, java.lang.String, java.util.Locale)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadWritableInstant.setMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.ReadableInstant.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.getField()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.iInstant</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.ReadWritableInstantFieldProperty.set(java.lang.String)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.property.TimeOnlyFieldProperty</name>
            <outbound type="class" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.clockhourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.clockhourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.halfdayOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.hourOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.hourOfHalfday()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.millisOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.millisOfSecond()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.minuteOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.minuteOfHour()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.secondOfDay()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.secondOfMinute()</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.property.TimeOnlyFieldProperty.TimeOnlyFieldProperty(org.joda.time.TimeOnly, org.joda.time.DateTimeField)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.TimeOnly</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.AbstractReadableInstantFieldProperty.AbstractReadableInstantFieldProperty()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.iInstant</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.clockhourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.clockhourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.halfdayOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.hourOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.hourOfHalfday()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.millisOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.millisOfSecond()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.minuteOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.minuteOfHour()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.secondOfDay()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.TimeOnly.secondOfMinute()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.TimeOnlyFieldProperty.addToCopy(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.TimeOnly</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.TimeOnly.withMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.TimeOnlyFieldProperty.addToCopy(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.TimeOnly</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.TimeOnly.withMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.TimeOnlyFieldProperty.addWrappedToCopy(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.addWrapped(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.TimeOnly</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.TimeOnly.withMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.TimeOnlyFieldProperty.getDateTime()</name>
                <outbound type="class" confirmed="yes">org.joda.time.TimeOnly</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.TimeOnlyFieldProperty.getField()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.iField</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.TimeOnlyFieldProperty.getInstant()</name>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.TimeOnly</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.TimeOnlyFieldProperty.iField</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.TimeOnlyFieldProperty(org.joda.time.TimeOnly, org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.addToCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.addToCopy(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.addWrappedToCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.getField()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundCeilingCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundFloorCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundHalfCeilingCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundHalfEvenCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundHalfFloorCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.setCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.setCopy(java.lang.String, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.TimeOnlyFieldProperty.iInstant</name>
                <outbound type="class" confirmed="yes">org.joda.time.TimeOnly</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.TimeOnlyFieldProperty(org.joda.time.TimeOnly, org.joda.time.DateTimeField)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.addToCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.addToCopy(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.addWrappedToCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.getDateTime()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.getInstant()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundCeilingCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundFloorCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundHalfCeilingCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundHalfEvenCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.roundHalfFloorCopy()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.setCopy(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.setCopy(java.lang.String, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.TimeOnlyFieldProperty.roundCeilingCopy()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundCeiling(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.TimeOnly</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.TimeOnly.withMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.TimeOnlyFieldProperty.roundFloorCopy()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundFloor(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.TimeOnly</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.TimeOnly.withMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.TimeOnlyFieldProperty.roundHalfCeilingCopy()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundHalfCeiling(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.TimeOnly</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.TimeOnly.withMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.TimeOnlyFieldProperty.roundHalfEvenCopy()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundHalfEven(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.TimeOnly</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.TimeOnly.withMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.TimeOnlyFieldProperty.roundHalfFloorCopy()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.roundHalfFloor(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.TimeOnly</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.TimeOnly.withMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.TimeOnlyFieldProperty.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.TimeOnlyFieldProperty.setCopy(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.TimeOnly</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.TimeOnly.withMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.iInstant</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.TimeOnlyFieldProperty.setCopy(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.TimeOnly</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.setCopy(java.lang.String, java.util.Locale)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.property.TimeOnlyFieldProperty.setCopy(java.lang.String, java.util.Locale)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractPartialInstant.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, java.lang.String, java.util.Locale)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.TimeOnly</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.TimeOnly.withMillis(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.iField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.iInstant</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.property.TimeOnlyFieldProperty.setCopy(java.lang.String)</inbound>
            </feature>
        </class>
    </package>
    <package confirmed="yes">
        <name>org.joda.time.tz</name>
        <class confirmed="yes">
            <name>org.joda.time.tz.CachedDateTimeZone</name>
            <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.DataInput, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeTo(java.io.DataOutput)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.tz.CachedDateTimeZone.CachedDateTimeZone(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.DateTimeZone(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getID()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.cInfoCacheMask</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.iInfoCache</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.iZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.forZone(org.joda.time.DateTimeZone)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.CachedDateTimeZone.cInfoCacheMask</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.CachedDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.getInfo(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.readObject(java.io.ObjectInputStream)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.CachedDateTimeZone.createInfo(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.nextTransition(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.CachedDateTimeZone$Info(org.joda.time.DateTimeZone, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.iNextInfo</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.iZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.getInfo(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.CachedDateTimeZone.equals(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.equals(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.iZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.CachedDateTimeZone.forZone(org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.CachedDateTimeZone(org.joda.time.DateTimeZone)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.DataInput, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.CachedDateTimeZone.getInfo(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.iPeriodStart</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.cInfoCacheMask</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.createInfo(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.iInfoCache</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.getNameKey(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.getOffset(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.getStandardOffset(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.CachedDateTimeZone.getNameKey(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.getNameKey(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.getInfo(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.CachedDateTimeZone.getOffset(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.getOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.getInfo(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.CachedDateTimeZone.getStandardOffset(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.getStandardOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.getInfo(long)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.CachedDateTimeZone.getUncachedZone()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.iZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeTo(java.io.DataOutput)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.CachedDateTimeZone.hashCode()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.hashCode()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.iZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.CachedDateTimeZone.iInfoCache</name>
                <outbound type="class" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.CachedDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.getInfo(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.readObject(java.io.ObjectInputStream)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.CachedDateTimeZone.iZone</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.CachedDateTimeZone(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.createInfo(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.getUncachedZone()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.hashCode()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.isFixed()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.nextTransition(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.previousTransition(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.CachedDateTimeZone.isFixed()</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.isFixed()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.iZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.CachedDateTimeZone.nextTransition(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.nextTransition(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.iZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.CachedDateTimeZone.previousTransition(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.previousTransition(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.iZone</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.CachedDateTimeZone.readObject(java.io.ObjectInputStream)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.ObjectInputStream</outbound>
                <outbound type="feature" confirmed="no">java.io.ObjectInputStream.defaultReadObject()</outbound>
                <outbound type="class" confirmed="no">java.lang.ClassNotFoundException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.cInfoCacheMask</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.iInfoCache</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.CachedDateTimeZone.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.CachedDateTimeZone.static {}</name>
                <outbound type="class" confirmed="no">java.lang.Integer</outbound>
                <outbound type="feature" confirmed="no">java.lang.Integer.getInteger(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Integer.intValue()</outbound>
                <outbound type="class" confirmed="no">java.lang.SecurityException</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.cInfoCacheMask</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.tz.CachedDateTimeZone$Info</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.CachedDateTimeZone(org.joda.time.DateTimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.createInfo(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.getInfo(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.getNameKey(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.getOffset(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.getStandardOffset(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.iInfoCache</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.readObject(java.io.ObjectInputStream)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.tz.CachedDateTimeZone$Info.CachedDateTimeZone$Info(org.joda.time.DateTimeZone, long)</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.iOffset</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.iPeriodStart</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.iStandardOffset</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.iZoneRef</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.createInfo(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.CachedDateTimeZone$Info.getNameKey(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getNameKey(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.iNameKey</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.iNextInfo</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.iPeriodStart</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.iZoneRef</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.getNameKey(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.CachedDateTimeZone$Info.getOffset(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.iNextInfo</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.iOffset</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.iPeriodStart</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.iZoneRef</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.getOffset(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.CachedDateTimeZone$Info.getStandardOffset(long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getStandardOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.iNextInfo</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.iPeriodStart</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.iStandardOffset</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.iZoneRef</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.getStandardOffset(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.CachedDateTimeZone$Info.iNameKey</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.getNameKey(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.CachedDateTimeZone$Info.iNextInfo</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.getNameKey(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.getOffset(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.getStandardOffset(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.createInfo(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.CachedDateTimeZone$Info.iOffset</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.CachedDateTimeZone$Info(org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.getOffset(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.CachedDateTimeZone$Info.iPeriodStart</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.CachedDateTimeZone$Info(org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.getNameKey(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.getOffset(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.getStandardOffset(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.getInfo(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.CachedDateTimeZone$Info.iStandardOffset</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.CachedDateTimeZone$Info(org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.getStandardOffset(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.CachedDateTimeZone$Info.iZoneRef</name>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.CachedDateTimeZone$Info(org.joda.time.DateTimeZone, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.getNameKey(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.getOffset(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone$Info.getStandardOffset(long)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.tz.DateTimeZoneBuilder</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.addCutover(org.joda.time.tz.DateTimeZoneBuilder, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String, int, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.addToBuilder(org.joda.time.tz.DateTimeZoneBuilder, java.util.Map)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.addToBuilder(org.joda.time.tz.ZoneInfoCompiler$Zone, org.joda.time.tz.DateTimeZoneBuilder, java.util.Map)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.buildDateTimeZone(java.util.Map)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder.DateTimeZoneBuilder()</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="no">java.util.ArrayList</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.ArrayList(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.iRuleSets</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.buildDateTimeZone(java.util.Map)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder.addCutover(int, char, int, int, int, boolean, int)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.util.ArrayList</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.add(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.get(int)</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.size()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.DateTimeZoneBuilder$OfYear(char, int, int, int, boolean, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.DateTimeZoneBuilder$RuleSet()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.setUpperLimit(int, org.joda.time.tz.DateTimeZoneBuilder$OfYear)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.iRuleSets</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.getLastRuleSet()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.addCutover(org.joda.time.tz.DateTimeZoneBuilder, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder.addRecurringSavings(java.lang.String, int, int, int, char, int, int, int, boolean, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.DateTimeZoneBuilder$OfYear(char, int, int, int, boolean, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.DateTimeZoneBuilder$Recurrence(org.joda.time.tz.DateTimeZoneBuilder$OfYear, java.lang.String, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.DateTimeZoneBuilder$Rule(org.joda.time.tz.DateTimeZoneBuilder$Recurrence, int, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.addRule(org.joda.time.tz.DateTimeZoneBuilder$Rule)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.getLastRuleSet()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String, int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder.addTransition(java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$Transition)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.util.ArrayList</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.add(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.get(int)</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.remove(int)</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.size()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.getWallOffset()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.isTransitionFrom(org.joda.time.tz.DateTimeZoneBuilder$Transition)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder.buildFixedZone(java.lang.String, java.lang.String, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.equals(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.FixedDateTimeZone.FixedDateTimeZone(java.lang.String, java.lang.String, int, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder.getLastRuleSet()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.util.ArrayList</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.get(int)</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.size()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addCutover(int, char, int, int, int, boolean, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.iRuleSets</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addRecurringSavings(java.lang.String, int, int, int, char, int, int, int, boolean, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.setFixedSavings(java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.setStandardOffset(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder.iRuleSets</name>
                <outbound type="class" confirmed="no">java.util.ArrayList</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.DateTimeZoneBuilder()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addCutover(int, char, int, int, int, boolean, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.getLastRuleSet()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.DataInput, java.lang.String)</name>
                <outbound type="class" confirmed="no">java.io.DataInput</outbound>
                <outbound type="feature" confirmed="no">java.io.DataInput.readUTF()</outbound>
                <outbound type="feature" confirmed="no">java.io.DataInput.readUnsignedByte()</outbound>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="feature" confirmed="no">java.io.IOException.IOException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.equals(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.CachedDateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.forZone(org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.readFrom(java.io.DataInput, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readMillis(java.io.DataInput)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.FixedDateTimeZone.FixedDateTimeZone(java.lang.String, java.lang.String, int, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.InputStream, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.InputStream, java.lang.String)</name>
                <outbound type="class" confirmed="no">java.io.DataInput</outbound>
                <outbound type="feature" confirmed="no">java.io.DataInputStream.DataInputStream(java.io.InputStream)</outbound>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.InputStream</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.DataInput, java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneData(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder.readMillis(java.io.DataInput)</name>
                <outbound type="class" confirmed="no">java.io.DataInput</outbound>
                <outbound type="feature" confirmed="no">java.io.DataInput.readLong()</outbound>
                <outbound type="feature" confirmed="no">java.io.DataInput.readUnsignedByte()</outbound>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.readFrom(java.io.DataInput, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.readFrom(java.io.DataInput)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.readFrom(java.io.DataInput, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.readFrom(java.io.DataInput)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.DataInput, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder.setFixedSavings(java.lang.String, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.setFixedSavings(java.lang.String, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.getLastRuleSet()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.addToBuilder(org.joda.time.tz.ZoneInfoCompiler$Zone, org.joda.time.tz.DateTimeZoneBuilder, java.util.Map)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder.setStandardOffset(int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.setStandardOffset(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.getLastRuleSet()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.addToBuilder(org.joda.time.tz.ZoneInfoCompiler$Zone, org.joda.time.tz.DateTimeZoneBuilder, java.util.Map)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(java.lang.String)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException()</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.ArrayList</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.ArrayList()</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.get(int)</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.size()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.CachedDateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.forZone(org.joda.time.DateTimeZone)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.DateTimeZoneBuilder$PrecalculatedZone(java.lang.String, java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$DSTZone)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.isCachable()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.DateTimeZoneBuilder$RuleSet(org.joda.time.tz.DateTimeZoneBuilder$RuleSet)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.buildTailZone(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.firstTransition(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.getUpperLimit(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.nextTransition(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.getNameKey()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.getSaveMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.getStandardOffset()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.getWallOffset()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addTransition(java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$Transition)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.buildFixedZone(java.lang.String, java.lang.String, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.iRuleSets</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeTo(java.io.DataOutput)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.buildDateTimeZone(java.util.Map)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder.writeMillis(java.io.DataOutput, long)</name>
                <outbound type="class" confirmed="no">java.io.DataOutput</outbound>
                <outbound type="feature" confirmed="no">java.io.DataOutput.writeByte(int)</outbound>
                <outbound type="feature" confirmed="no">java.io.DataOutput.writeInt(int)</outbound>
                <outbound type="feature" confirmed="no">java.io.DataOutput.writeLong(long)</outbound>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.writeTo(java.io.DataOutput)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.writeTo(java.io.DataOutput)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.writeTo(java.io.DataOutput)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.writeTo(java.io.DataOutput)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeTo(java.io.DataOutput)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder.writeTo(java.io.DataOutput)</name>
                <outbound type="class" confirmed="no">java.io.DataOutput</outbound>
                <outbound type="feature" confirmed="no">java.io.DataOutput.writeByte(int)</outbound>
                <outbound type="feature" confirmed="no">java.io.DataOutput.writeUTF(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getNameKey(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getStandardOffset(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.CachedDateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.CachedDateTimeZone.getUncachedZone()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.writeTo(java.io.DataOutput)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeMillis(java.io.DataOutput, long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.FixedDateTimeZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeTo(java.io.OutputStream)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder.writeTo(java.io.OutputStream)</name>
                <outbound type="class" confirmed="no">java.io.DataOutput</outbound>
                <outbound type="feature" confirmed="no">java.io.DataOutputStream.DataOutputStream(java.io.OutputStream)</outbound>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.OutputStream</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeTo(java.io.DataOutput)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.tz.DateTimeZoneBuilder$DSTZone</name>
            <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.DateTimeZoneBuilder$PrecalculatedZone(java.lang.String, java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$DSTZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.DateTimeZoneBuilder$PrecalculatedZone(java.lang.String, long[], int[], int[], java.lang.String[], org.joda.time.tz.DateTimeZoneBuilder$DSTZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.equals(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.getNameKey(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.getOffset(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.getStandardOffset(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iTailZone</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.isCachable()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.nextTransition(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.previousTransition(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.readFrom(java.io.DataInput, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.writeTo(java.io.DataOutput)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.buildTailZone(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(java.lang.String)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$DSTZone.DateTimeZoneBuilder$DSTZone(java.lang.String, int, org.joda.time.tz.DateTimeZoneBuilder$Recurrence, org.joda.time.tz.DateTimeZoneBuilder$Recurrence)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.DateTimeZone(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.iEndRecurrence</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.iStandardOffset</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.iStartRecurrence</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.readFrom(java.io.DataInput, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.buildTailZone(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$DSTZone.equals(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.equals(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getID()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.iEndRecurrence</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.iStandardOffset</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.iStartRecurrence</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.equals(java.lang.Object)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.equals(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$DSTZone.findMatchingRecurrence(long)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.iEndRecurrence</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.iStandardOffset</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.iStartRecurrence</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.getSaveMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.next(long, int, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.getNameKey(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.getOffset(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$DSTZone.getNameKey(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.findMatchingRecurrence(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.getNameKey()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.getNameKey(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$DSTZone.getOffset(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.findMatchingRecurrence(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.iStandardOffset</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.getSaveMillis()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.getOffset(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$DSTZone.getStandardOffset(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.iStandardOffset</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.getStandardOffset(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$DSTZone.iEndRecurrence</name>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.DateTimeZoneBuilder$DSTZone(java.lang.String, int, org.joda.time.tz.DateTimeZoneBuilder$Recurrence, org.joda.time.tz.DateTimeZoneBuilder$Recurrence)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.findMatchingRecurrence(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.nextTransition(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.previousTransition(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.writeTo(java.io.DataOutput)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$DSTZone.iStandardOffset</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.DateTimeZoneBuilder$DSTZone(java.lang.String, int, org.joda.time.tz.DateTimeZoneBuilder$Recurrence, org.joda.time.tz.DateTimeZoneBuilder$Recurrence)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.findMatchingRecurrence(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.getOffset(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.getStandardOffset(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.nextTransition(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.previousTransition(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.writeTo(java.io.DataOutput)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$DSTZone.iStartRecurrence</name>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.DateTimeZoneBuilder$DSTZone(java.lang.String, int, org.joda.time.tz.DateTimeZoneBuilder$Recurrence, org.joda.time.tz.DateTimeZoneBuilder$Recurrence)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.findMatchingRecurrence(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.nextTransition(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.previousTransition(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.writeTo(java.io.DataOutput)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$DSTZone.isFixed()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$DSTZone.nextTransition(long)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.iEndRecurrence</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.iStandardOffset</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.iStartRecurrence</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.getSaveMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.next(long, int, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.nextTransition(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$DSTZone.previousTransition(long)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.iEndRecurrence</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.iStandardOffset</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.iStartRecurrence</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.getSaveMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.previous(long, int, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.previousTransition(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$DSTZone.readFrom(java.io.DataInput, java.lang.String)</name>
                <outbound type="class" confirmed="no">java.io.DataInput</outbound>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.DateTimeZoneBuilder$DSTZone(java.lang.String, int, org.joda.time.tz.DateTimeZoneBuilder$Recurrence, org.joda.time.tz.DateTimeZoneBuilder$Recurrence)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.readFrom(java.io.DataInput)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readMillis(java.io.DataInput)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.readFrom(java.io.DataInput, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$DSTZone.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$DSTZone.writeTo(java.io.DataOutput)</name>
                <outbound type="class" confirmed="no">java.io.DataOutput</outbound>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.iEndRecurrence</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.iStandardOffset</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.iStartRecurrence</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.writeTo(java.io.DataOutput)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeMillis(java.io.DataOutput, long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.writeTo(java.io.DataOutput)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.tz.DateTimeZoneBuilder$OfYear</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.DateTimeZoneBuilder$Recurrence(org.joda.time.tz.DateTimeZoneBuilder$OfYear, java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.equals(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.getOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.iOfYear</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.next(long, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.previous(long, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.readFrom(java.io.DataInput)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.writeTo(java.io.DataOutput)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.getOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.DateTimeZoneBuilder$RuleSet(org.joda.time.tz.DateTimeZoneBuilder$RuleSet)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.getUpperLimit(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iUpperOfYear</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.nextTransition(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.setUpperLimit(int, org.joda.time.tz.DateTimeZoneBuilder$OfYear)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addCutover(int, char, int, int, int, boolean, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addRecurringSavings(java.lang.String, int, int, int, char, int, int, int, boolean, int)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$OfYear.DateTimeZoneBuilder$OfYear(char, int, int, int, boolean, int)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iAdvance</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iDayOfMonth</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iDayOfWeek</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iMillisOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iMode</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iMonthOfYear</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.readFrom(java.io.DataInput)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addCutover(int, char, int, int, int, boolean, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addRecurringSavings(java.lang.String, int, int, int, char, int, int, int, boolean, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$OfYear.equals(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iAdvance</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iDayOfMonth</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iDayOfWeek</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iMillisOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iMode</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iMonthOfYear</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.equals(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$OfYear.iAdvance</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.DateTimeZoneBuilder$OfYear(char, int, int, int, boolean, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfWeek(org.joda.time.Chronology, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.writeTo(java.io.DataOutput)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$OfYear.iDayOfMonth</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.DateTimeZoneBuilder$OfYear(char, int, int, int, boolean, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonth(org.joda.time.Chronology, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonthNext(org.joda.time.Chronology, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonthPrevious(org.joda.time.Chronology, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.writeTo(java.io.DataOutput)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$OfYear.iDayOfWeek</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.DateTimeZoneBuilder$OfYear(char, int, int, int, boolean, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.next(long, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.previous(long, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfWeek(org.joda.time.Chronology, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setInstant(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.writeTo(java.io.DataOutput)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$OfYear.iMillisOfDay</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.DateTimeZoneBuilder$OfYear(char, int, int, int, boolean, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.next(long, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.previous(long, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setInstant(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.writeTo(java.io.DataOutput)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$OfYear.iMode</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.DateTimeZoneBuilder$OfYear(char, int, int, int, boolean, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.next(long, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.previous(long, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setInstant(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.writeTo(java.io.DataOutput)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$OfYear.iMonthOfYear</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.DateTimeZoneBuilder$OfYear(char, int, int, int, boolean, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.next(long, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.previous(long, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonthNext(org.joda.time.Chronology, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonthPrevious(org.joda.time.Chronology, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setInstant(int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.writeTo(java.io.DataOutput)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$OfYear.next(long, int, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millisOfDay()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.monthOfYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.year()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iDayOfWeek</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iMillisOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iMode</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iMonthOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonthNext(org.joda.time.Chronology, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfWeek(org.joda.time.Chronology, long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.next(long, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$OfYear.previous(long, int, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millisOfDay()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.monthOfYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.year()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iDayOfWeek</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iMillisOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iMode</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iMonthOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonthPrevious(org.joda.time.Chronology, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfWeek(org.joda.time.Chronology, long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.previous(long, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$OfYear.readFrom(java.io.DataInput)</name>
                <outbound type="class" confirmed="no">java.io.DataInput</outbound>
                <outbound type="feature" confirmed="no">java.io.DataInput.readBoolean()</outbound>
                <outbound type="feature" confirmed="no">java.io.DataInput.readByte()</outbound>
                <outbound type="feature" confirmed="no">java.io.DataInput.readUnsignedByte()</outbound>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.DateTimeZoneBuilder$OfYear(char, int, int, int, boolean, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readMillis(java.io.DataInput)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.readFrom(java.io.DataInput)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonth(org.joda.time.Chronology, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfMonth()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.monthOfYear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iDayOfMonth</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonthNext(org.joda.time.Chronology, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonthPrevious(org.joda.time.Chronology, long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setInstant(int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonthNext(org.joda.time.Chronology, long)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.year()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.isLeap(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iDayOfMonth</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iMonthOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonth(org.joda.time.Chronology, long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.next(long, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonthPrevious(org.joda.time.Chronology, long)</name>
                <outbound type="class" confirmed="no">java.lang.IllegalArgumentException</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.year()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.isLeap(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iDayOfMonth</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iMonthOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonth(org.joda.time.Chronology, long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.previous(long, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfWeek(org.joda.time.Chronology, long)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.dayOfWeek()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.add(long, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iAdvance</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iDayOfWeek</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.next(long, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.previous(long, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setInstant(int, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$OfYear.setInstant(int, int, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.millisOfDay()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.monthOfYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.year()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iDayOfWeek</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iMillisOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iMode</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iMonthOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonth(org.joda.time.Chronology, long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfWeek(org.joda.time.Chronology, long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.getUpperLimit(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.nextTransition(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$OfYear.writeTo(java.io.DataOutput)</name>
                <outbound type="class" confirmed="no">java.io.DataOutput</outbound>
                <outbound type="feature" confirmed="no">java.io.DataOutput.writeBoolean(boolean)</outbound>
                <outbound type="feature" confirmed="no">java.io.DataOutput.writeByte(int)</outbound>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iAdvance</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iDayOfMonth</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iDayOfWeek</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iMillisOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iMode</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.iMonthOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeMillis(java.io.DataOutput, long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.writeTo(java.io.DataOutput)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone</name>
            <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.DataInput, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeTo(java.io.DataOutput)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.DateTimeZoneBuilder$PrecalculatedZone(java.lang.String, java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$DSTZone)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException()</outbound>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.ArrayList</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.get(int)</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.size()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.DateTimeZone(java.lang.String)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iNameKeys</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iStandardOffsets</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iTailZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iTransitions</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iWallOffsets</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.getNameKey()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.getStandardOffset()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.getWallOffset()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.isTransitionFrom(org.joda.time.tz.DateTimeZoneBuilder$Transition)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.DateTimeZoneBuilder$PrecalculatedZone(java.lang.String, long[], int[], int[], java.lang.String[], org.joda.time.tz.DateTimeZoneBuilder$DSTZone)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.DateTimeZone(java.lang.String)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iNameKeys</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iStandardOffsets</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iTailZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iTransitions</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iWallOffsets</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.readFrom(java.io.DataInput, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.equals(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.equals(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.Arrays.equals(int[], int[])</outbound>
                <outbound type="feature" confirmed="no">java.util.Arrays.equals(java.lang.Object[], java.lang.Object[])</outbound>
                <outbound type="feature" confirmed="no">java.util.Arrays.equals(long[], long[])</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getID()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.equals(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iNameKeys</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iStandardOffsets</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iTailZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iTransitions</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iWallOffsets</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.getNameKey(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.util.Arrays.binarySearch(long[], long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.getNameKey(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iNameKeys</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iTailZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iTransitions</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.getOffset(long)</name>
                <outbound type="feature" confirmed="no">java.util.Arrays.binarySearch(long[], long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.getOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iTailZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iTransitions</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iWallOffsets</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.getStandardOffset(long)</name>
                <outbound type="feature" confirmed="no">java.util.Arrays.binarySearch(long[], long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.getStandardOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iStandardOffsets</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iTailZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iTransitions</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iNameKeys</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.DateTimeZoneBuilder$PrecalculatedZone(java.lang.String, java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$DSTZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.DateTimeZoneBuilder$PrecalculatedZone(java.lang.String, long[], int[], int[], java.lang.String[], org.joda.time.tz.DateTimeZoneBuilder$DSTZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.getNameKey(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.writeTo(java.io.DataOutput)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iStandardOffsets</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.DateTimeZoneBuilder$PrecalculatedZone(java.lang.String, java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$DSTZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.DateTimeZoneBuilder$PrecalculatedZone(java.lang.String, long[], int[], int[], java.lang.String[], org.joda.time.tz.DateTimeZoneBuilder$DSTZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.getStandardOffset(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.writeTo(java.io.DataOutput)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iTailZone</name>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.DateTimeZoneBuilder$PrecalculatedZone(java.lang.String, java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$DSTZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.DateTimeZoneBuilder$PrecalculatedZone(java.lang.String, long[], int[], int[], java.lang.String[], org.joda.time.tz.DateTimeZoneBuilder$DSTZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.getNameKey(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.getOffset(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.getStandardOffset(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.isCachable()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.nextTransition(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.previousTransition(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.writeTo(java.io.DataOutput)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iTransitions</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.DateTimeZoneBuilder$PrecalculatedZone(java.lang.String, java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$DSTZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.DateTimeZoneBuilder$PrecalculatedZone(java.lang.String, long[], int[], int[], java.lang.String[], org.joda.time.tz.DateTimeZoneBuilder$DSTZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.getNameKey(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.getOffset(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.getStandardOffset(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.isCachable()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.nextTransition(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.previousTransition(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.writeTo(java.io.DataOutput)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iWallOffsets</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.DateTimeZoneBuilder$PrecalculatedZone(java.lang.String, java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$DSTZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.DateTimeZoneBuilder$PrecalculatedZone(java.lang.String, long[], int[], int[], java.lang.String[], org.joda.time.tz.DateTimeZoneBuilder$DSTZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.getOffset(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.writeTo(java.io.DataOutput)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.isCachable()</name>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iTailZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iTransitions</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.isFixed()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.nextTransition(long)</name>
                <outbound type="feature" confirmed="no">java.util.Arrays.binarySearch(long[], long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.nextTransition(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iTailZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iTransitions</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.previousTransition(long)</name>
                <outbound type="feature" confirmed="no">java.util.Arrays.binarySearch(long[], long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.previousTransition(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iTailZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iTransitions</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.readFrom(java.io.DataInput, java.lang.String)</name>
                <outbound type="class" confirmed="no">java.io.DataInput</outbound>
                <outbound type="feature" confirmed="no">java.io.DataInput.readBoolean()</outbound>
                <outbound type="feature" confirmed="no">java.io.DataInput.readInt()</outbound>
                <outbound type="feature" confirmed="no">java.io.DataInput.readUTF()</outbound>
                <outbound type="feature" confirmed="no">java.io.DataInput.readUnsignedByte()</outbound>
                <outbound type="feature" confirmed="no">java.io.DataInput.readUnsignedShort()</outbound>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="feature" confirmed="no">java.io.IOException.IOException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.ArrayIndexOutOfBoundsException</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.readFrom(java.io.DataInput, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.DateTimeZoneBuilder$PrecalculatedZone(java.lang.String, long[], int[], int[], java.lang.String[], org.joda.time.tz.DateTimeZoneBuilder$DSTZone)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readMillis(java.io.DataInput)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.DataInput, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.serialVersionUID</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.writeTo(java.io.DataOutput)</name>
                <outbound type="class" confirmed="no">java.io.DataOutput</outbound>
                <outbound type="feature" confirmed="no">java.io.DataOutput.writeBoolean(boolean)</outbound>
                <outbound type="feature" confirmed="no">java.io.DataOutput.writeByte(int)</outbound>
                <outbound type="feature" confirmed="no">java.io.DataOutput.writeInt(int)</outbound>
                <outbound type="feature" confirmed="no">java.io.DataOutput.writeShort(int)</outbound>
                <outbound type="feature" confirmed="no">java.io.DataOutput.writeUTF(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.equals(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.lang.UnsupportedOperationException.UnsupportedOperationException(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.util.HashSet.HashSet()</outbound>
                <outbound type="class" confirmed="no">java.util.Iterator</outbound>
                <outbound type="feature" confirmed="no">java.util.Iterator.hasNext()</outbound>
                <outbound type="feature" confirmed="no">java.util.Iterator.next()</outbound>
                <outbound type="feature" confirmed="no">java.util.Set.add(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.Set.iterator()</outbound>
                <outbound type="feature" confirmed="no">java.util.Set.size()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.writeTo(java.io.DataOutput)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iNameKeys</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iStandardOffsets</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iTailZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iTransitions</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.iWallOffsets</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeMillis(java.io.DataOutput, long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeTo(java.io.DataOutput)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.tz.DateTimeZoneBuilder$Recurrence</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.DateTimeZoneBuilder$DSTZone(java.lang.String, int, org.joda.time.tz.DateTimeZoneBuilder$Recurrence, org.joda.time.tz.DateTimeZoneBuilder$Recurrence)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.equals(java.lang.Object)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.findMatchingRecurrence(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.getNameKey(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.getOffset(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.iEndRecurrence</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.iStartRecurrence</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.nextTransition(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.previousTransition(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.readFrom(java.io.DataInput, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.writeTo(java.io.DataOutput)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.DateTimeZoneBuilder$Rule(org.joda.time.tz.DateTimeZoneBuilder$Recurrence, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.getNameKey()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.getOfYear()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.getSaveMillis()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.iRecurrence</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.next(long, int, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.buildTailZone(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addRecurringSavings(java.lang.String, int, int, int, char, int, int, int, boolean, int)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Recurrence.DateTimeZoneBuilder$Recurrence(org.joda.time.tz.DateTimeZoneBuilder$OfYear, java.lang.String, int)</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.iNameKey</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.iOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.iSaveMillis</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.readFrom(java.io.DataInput)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addRecurringSavings(java.lang.String, int, int, int, char, int, int, int, boolean, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Recurrence.equals(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.equals(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.equals(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.iNameKey</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.iOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.iSaveMillis</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.equals(java.lang.Object)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Recurrence.getNameKey()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.iNameKey</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.getNameKey(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.getNameKey()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Recurrence.getOfYear()</name>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.iOfYear</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.getOfYear()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Recurrence.getSaveMillis()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.iSaveMillis</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.findMatchingRecurrence(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.getOffset(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.nextTransition(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.previousTransition(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.getSaveMillis()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Recurrence.iNameKey</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.DateTimeZoneBuilder$Recurrence(org.joda.time.tz.DateTimeZoneBuilder$OfYear, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.getNameKey()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.writeTo(java.io.DataOutput)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Recurrence.iOfYear</name>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.DateTimeZoneBuilder$Recurrence(org.joda.time.tz.DateTimeZoneBuilder$OfYear, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.getOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.next(long, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.previous(long, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.writeTo(java.io.DataOutput)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Recurrence.iSaveMillis</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.DateTimeZoneBuilder$Recurrence(org.joda.time.tz.DateTimeZoneBuilder$OfYear, java.lang.String, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.getSaveMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.writeTo(java.io.DataOutput)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Recurrence.next(long, int, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.next(long, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.iOfYear</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.findMatchingRecurrence(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.nextTransition(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.next(long, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Recurrence.previous(long, int, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.previous(long, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.iOfYear</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.previousTransition(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Recurrence.readFrom(java.io.DataInput)</name>
                <outbound type="class" confirmed="no">java.io.DataInput</outbound>
                <outbound type="feature" confirmed="no">java.io.DataInput.readUTF()</outbound>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.readFrom(java.io.DataInput)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.DateTimeZoneBuilder$Recurrence(org.joda.time.tz.DateTimeZoneBuilder$OfYear, java.lang.String, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readMillis(java.io.DataInput)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.readFrom(java.io.DataInput, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Recurrence.writeTo(java.io.DataOutput)</name>
                <outbound type="class" confirmed="no">java.io.DataOutput</outbound>
                <outbound type="feature" confirmed="no">java.io.DataOutput.writeUTF(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.writeTo(java.io.DataOutput)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.iNameKey</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.iOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.iSaveMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeMillis(java.io.DataOutput, long)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.writeTo(java.io.DataOutput)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.tz.DateTimeZoneBuilder$Rule</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.addRule(org.joda.time.tz.DateTimeZoneBuilder$Rule)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.buildTailZone(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.firstTransition(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.nextTransition(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.DateTimeZoneBuilder$Transition(long, org.joda.time.tz.DateTimeZoneBuilder$Rule, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addRecurringSavings(java.lang.String, int, int, int, char, int, int, int, boolean, int)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Rule.DateTimeZoneBuilder$Rule(org.joda.time.tz.DateTimeZoneBuilder$Recurrence, int, int)</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.iFromYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.iRecurrence</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.iToYear</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addRecurringSavings(java.lang.String, int, int, int, char, int, int, int, boolean, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Rule.getFromYear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.iFromYear</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Rule.getNameKey()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.getNameKey()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.iRecurrence</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.DateTimeZoneBuilder$Transition(long, org.joda.time.tz.DateTimeZoneBuilder$Rule, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Rule.getOfYear()</name>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.getOfYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.iRecurrence</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Rule.getSaveMillis()</name>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.getSaveMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.iRecurrence</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.firstTransition(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.DateTimeZoneBuilder$Transition(long, org.joda.time.tz.DateTimeZoneBuilder$Rule, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Rule.getToYear()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.iToYear</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.buildTailZone(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Rule.iFromYear</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.DateTimeZoneBuilder$Rule(org.joda.time.tz.DateTimeZoneBuilder$Recurrence, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.getFromYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.next(long, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Rule.iRecurrence</name>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.DateTimeZoneBuilder$Rule(org.joda.time.tz.DateTimeZoneBuilder$Recurrence, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.getNameKey()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.getOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.getSaveMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.next(long, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.buildTailZone(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Rule.iToYear</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.DateTimeZoneBuilder$Rule(org.joda.time.tz.DateTimeZoneBuilder$Recurrence, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.getToYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.next(long, int, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Rule.next(long, int, int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.year()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence.next(long, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.iFromYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.iRecurrence</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.iToYear</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.nextTransition(long, int)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.tz.DateTimeZoneBuilder$RuleSet</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addCutover(int, char, int, int, int, boolean, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addRecurringSavings(java.lang.String, int, int, int, char, int, int, int, boolean, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.getLastRuleSet()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.setFixedSavings(java.lang.String, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.setStandardOffset(int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(java.lang.String)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$RuleSet.DateTimeZoneBuilder$RuleSet()</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="no">java.util.ArrayList</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.ArrayList(int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iRules</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iUpperYear</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addCutover(int, char, int, int, int, boolean, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$RuleSet.DateTimeZoneBuilder$RuleSet(org.joda.time.tz.DateTimeZoneBuilder$RuleSet)</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.ArrayList</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.ArrayList(java.util.Collection)</outbound>
                <outbound type="class" confirmed="no">java.util.Collection</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iInitialNameKey</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iInitialSaveMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iRules</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iStandardOffset</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iUpperOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iUpperYear</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$RuleSet.YEAR_LIMIT</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.nextTransition(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.static {}</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$RuleSet.addRule(org.joda.time.tz.DateTimeZoneBuilder$Rule)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.util.ArrayList</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.add(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.contains(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iRules</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addRecurringSavings(java.lang.String, int, int, int, char, int, int, int, boolean, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$RuleSet.buildTailZone(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.ArrayList</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.get(int)</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.size()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$DSTZone.DateTimeZoneBuilder$DSTZone(java.lang.String, int, org.joda.time.tz.DateTimeZoneBuilder$Recurrence, org.joda.time.tz.DateTimeZoneBuilder$Recurrence)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Recurrence</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.getToYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.iRecurrence</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iRules</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iStandardOffset</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$RuleSet.firstTransition(long)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.util.AbstractList.iterator()</outbound>
                <outbound type="class" confirmed="no">java.util.ArrayList</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.ArrayList(java.util.Collection)</outbound>
                <outbound type="class" confirmed="no">java.util.Collection</outbound>
                <outbound type="class" confirmed="no">java.util.Iterator</outbound>
                <outbound type="feature" confirmed="no">java.util.Iterator.hasNext()</outbound>
                <outbound type="feature" confirmed="no">java.util.Iterator.next()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.getSaveMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iInitialNameKey</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iInitialSaveMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iRules</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iStandardOffset</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.nextTransition(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.DateTimeZoneBuilder$Transition(long, java.lang.String, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.DateTimeZoneBuilder$Transition(long, org.joda.time.tz.DateTimeZoneBuilder$Rule, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.DateTimeZoneBuilder$Transition(long, org.joda.time.tz.DateTimeZoneBuilder$Transition)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.getMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.getNameKey()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.getSaveMillis()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$RuleSet.getStandardOffset()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iStandardOffset</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$RuleSet.getUpperLimit(int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setInstant(int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iStandardOffset</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iUpperOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iUpperYear</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iInitialNameKey</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.DateTimeZoneBuilder$RuleSet(org.joda.time.tz.DateTimeZoneBuilder$RuleSet)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.firstTransition(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.setFixedSavings(java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iInitialSaveMillis</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.DateTimeZoneBuilder$RuleSet(org.joda.time.tz.DateTimeZoneBuilder$RuleSet)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.firstTransition(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.setFixedSavings(java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iRules</name>
                <outbound type="class" confirmed="no">java.util.ArrayList</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.DateTimeZoneBuilder$RuleSet()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.DateTimeZoneBuilder$RuleSet(org.joda.time.tz.DateTimeZoneBuilder$RuleSet)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.addRule(org.joda.time.tz.DateTimeZoneBuilder$Rule)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.buildTailZone(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.firstTransition(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.nextTransition(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iStandardOffset</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.DateTimeZoneBuilder$RuleSet(org.joda.time.tz.DateTimeZoneBuilder$RuleSet)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.buildTailZone(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.firstTransition(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.getStandardOffset()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.getUpperLimit(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.nextTransition(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.setStandardOffset(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iUpperOfYear</name>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.DateTimeZoneBuilder$RuleSet(org.joda.time.tz.DateTimeZoneBuilder$RuleSet)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.getUpperLimit(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.nextTransition(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.setUpperLimit(int, org.joda.time.tz.DateTimeZoneBuilder$OfYear)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iUpperYear</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.DateTimeZoneBuilder$RuleSet()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.DateTimeZoneBuilder$RuleSet(org.joda.time.tz.DateTimeZoneBuilder$RuleSet)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.getUpperLimit(int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.nextTransition(long, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.setUpperLimit(int, org.joda.time.tz.DateTimeZoneBuilder$OfYear)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$RuleSet.nextTransition(long, int)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.util.AbstractList.iterator()</outbound>
                <outbound type="class" confirmed="no">java.util.ArrayList</outbound>
                <outbound type="class" confirmed="no">java.util.Iterator</outbound>
                <outbound type="feature" confirmed="no">java.util.Iterator.hasNext()</outbound>
                <outbound type="feature" confirmed="no">java.util.Iterator.next()</outbound>
                <outbound type="feature" confirmed="no">java.util.Iterator.remove()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.Chronology.year()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear.setInstant(int, int, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.next(long, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.YEAR_LIMIT</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iRules</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iStandardOffset</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iUpperOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iUpperYear</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.DateTimeZoneBuilder$Transition(long, org.joda.time.tz.DateTimeZoneBuilder$Rule, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.firstTransition(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$RuleSet.setFixedSavings(java.lang.String, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iInitialNameKey</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iInitialSaveMillis</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.setFixedSavings(java.lang.String, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$RuleSet.setStandardOffset(int)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iStandardOffset</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.setStandardOffset(int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$RuleSet.setUpperLimit(int, org.joda.time.tz.DateTimeZoneBuilder$OfYear)</name>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$OfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iUpperOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.iUpperYear</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addCutover(int, char, int, int, int, boolean, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$RuleSet.static {}</name>
                <outbound type="feature" confirmed="no">java.lang.System.currentTimeMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.year()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.YEAR_LIMIT</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.tz.DateTimeZoneBuilder$Transition</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.DateTimeZoneBuilder$PrecalculatedZone(java.lang.String, java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$DSTZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.firstTransition(long)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.nextTransition(long, int)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addTransition(java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$Transition)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(java.lang.String)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Transition.DateTimeZoneBuilder$Transition(long, java.lang.String, int, int)</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.iMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.iNameKey</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.iStandardOffset</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.iWallOffset</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.firstTransition(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Transition.DateTimeZoneBuilder$Transition(long, org.joda.time.tz.DateTimeZoneBuilder$Rule, int)</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.getNameKey()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Rule.getSaveMillis()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.iMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.iNameKey</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.iStandardOffset</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.iWallOffset</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.firstTransition(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.nextTransition(long, int)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Transition.DateTimeZoneBuilder$Transition(long, org.joda.time.tz.DateTimeZoneBuilder$Transition)</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.iMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.iNameKey</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.iStandardOffset</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.iWallOffset</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.firstTransition(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Transition.getMillis()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.iMillis</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.DateTimeZoneBuilder$PrecalculatedZone(java.lang.String, java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$DSTZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.firstTransition(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addTransition(java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$Transition)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Transition.getNameKey()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.iNameKey</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.DateTimeZoneBuilder$PrecalculatedZone(java.lang.String, java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$DSTZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.firstTransition(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Transition.getSaveMillis()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.iStandardOffset</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.iWallOffset</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$RuleSet.firstTransition(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Transition.getStandardOffset()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.iStandardOffset</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.DateTimeZoneBuilder$PrecalculatedZone(java.lang.String, java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$DSTZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Transition.getWallOffset()</name>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.iWallOffset</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.DateTimeZoneBuilder$PrecalculatedZone(java.lang.String, java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$DSTZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addTransition(java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$Transition)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Transition.iMillis</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.DateTimeZoneBuilder$Transition(long, java.lang.String, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.DateTimeZoneBuilder$Transition(long, org.joda.time.tz.DateTimeZoneBuilder$Rule, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.DateTimeZoneBuilder$Transition(long, org.joda.time.tz.DateTimeZoneBuilder$Transition)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.getMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.isTransitionFrom(org.joda.time.tz.DateTimeZoneBuilder$Transition)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Transition.iNameKey</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.DateTimeZoneBuilder$Transition(long, java.lang.String, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.DateTimeZoneBuilder$Transition(long, org.joda.time.tz.DateTimeZoneBuilder$Rule, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.DateTimeZoneBuilder$Transition(long, org.joda.time.tz.DateTimeZoneBuilder$Transition)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.getNameKey()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.isTransitionFrom(org.joda.time.tz.DateTimeZoneBuilder$Transition)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Transition.iStandardOffset</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.DateTimeZoneBuilder$Transition(long, java.lang.String, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.DateTimeZoneBuilder$Transition(long, org.joda.time.tz.DateTimeZoneBuilder$Rule, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.DateTimeZoneBuilder$Transition(long, org.joda.time.tz.DateTimeZoneBuilder$Transition)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.getSaveMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.getStandardOffset()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Transition.iWallOffset</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.DateTimeZoneBuilder$Transition(long, java.lang.String, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.DateTimeZoneBuilder$Transition(long, org.joda.time.tz.DateTimeZoneBuilder$Rule, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.DateTimeZoneBuilder$Transition(long, org.joda.time.tz.DateTimeZoneBuilder$Transition)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.getSaveMillis()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.getWallOffset()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.isTransitionFrom(org.joda.time.tz.DateTimeZoneBuilder$Transition)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZoneBuilder$Transition.isTransitionFrom(org.joda.time.tz.DateTimeZoneBuilder$Transition)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.equals(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.iMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.iNameKey</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$Transition.iWallOffset</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.DateTimeZoneBuilder$PrecalculatedZone(java.lang.String, java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$DSTZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addTransition(java.util.ArrayList, org.joda.time.tz.DateTimeZoneBuilder$Transition)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.tz.DateTimeZonePermission</name>
            <outbound type="class" confirmed="no">java.security.BasicPermission</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZonePermission.DateTimeZonePermission(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.security.BasicPermission.BasicPermission(java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setDefault(org.joda.time.DateTimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setNameProvider(org.joda.time.tz.NameProvider)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setProvider(org.joda.time.tz.Provider)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZonePermission.DateTimeZonePermission(java.lang.String, java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.security.BasicPermission.BasicPermission(java.lang.String, java.lang.String)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DateTimeZonePermission.serialVersionUID</name>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.tz.DefaultNameProvider</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.tz.NameProvider</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DefaultNameProvider.DefaultNameProvider()</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="no">java.util.HashMap</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DefaultNameProvider.createCache()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DefaultNameProvider.iByLocaleCache</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultNameProvider()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DefaultNameProvider.createCache()</name>
                <outbound type="class" confirmed="no">java.util.HashMap</outbound>
                <outbound type="feature" confirmed="no">java.util.HashMap.HashMap(int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DefaultNameProvider.DefaultNameProvider()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DefaultNameProvider.getNameSet(java.util.Locale, java.lang.String, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DefaultNameProvider.getName(java.util.Locale, java.lang.String, java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DefaultNameProvider.getNameSet(java.util.Locale, java.lang.String, java.lang.String)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DefaultNameProvider.getNameSet(java.util.Locale, java.lang.String, java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.equals(java.lang.Object)</outbound>
                <outbound type="class" confirmed="no">java.lang.String[]</outbound>
                <outbound type="feature" confirmed="no">java.text.DateFormatSymbols.DateFormatSymbols(java.util.Locale)</outbound>
                <outbound type="feature" confirmed="no">java.text.DateFormatSymbols.getZoneStrings()</outbound>
                <outbound type="class" confirmed="no">java.util.HashMap</outbound>
                <outbound type="feature" confirmed="no">java.util.HashMap.get(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.HashMap.put(java.lang.Object, java.lang.Object)</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DefaultNameProvider.createCache()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DefaultNameProvider.iByLocaleCache</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DefaultNameProvider.getName(java.util.Locale, java.lang.String, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DefaultNameProvider.getShortName(java.util.Locale, java.lang.String, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DefaultNameProvider.getShortName(java.util.Locale, java.lang.String, java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DefaultNameProvider.getNameSet(java.util.Locale, java.lang.String, java.lang.String)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.DefaultNameProvider.iByLocaleCache</name>
                <outbound type="class" confirmed="no">java.util.HashMap</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DefaultNameProvider.DefaultNameProvider()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DefaultNameProvider.getNameSet(java.util.Locale, java.lang.String, java.lang.String)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.tz.FixedDateTimeZone</name>
            <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeTo(java.io.DataOutput)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.tz.FixedDateTimeZone.FixedDateTimeZone(java.lang.String, java.lang.String, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.DateTimeZone(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.FixedDateTimeZone.iNameKey</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.FixedDateTimeZone.iStandardOffset</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.FixedDateTimeZone.iWallOffset</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.util.TimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.static {}</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.buildFixedZone(java.lang.String, java.lang.String, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.DataInput, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.FixedDateTimeZone.equals(java.lang.Object)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.equals(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getID()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.FixedDateTimeZone.iStandardOffset</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.FixedDateTimeZone.iWallOffset</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.FixedDateTimeZone.getNameKey(long)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.FixedDateTimeZone.iNameKey</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.FixedDateTimeZone.getOffset(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.FixedDateTimeZone.iWallOffset</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.FixedDateTimeZone.getOffsetFromLocal(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.FixedDateTimeZone.iWallOffset</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.FixedDateTimeZone.getStandardOffset(long)</name>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.FixedDateTimeZone.iStandardOffset</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.FixedDateTimeZone.iNameKey</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.FixedDateTimeZone.FixedDateTimeZone(java.lang.String, java.lang.String, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.FixedDateTimeZone.getNameKey(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.FixedDateTimeZone.iStandardOffset</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.FixedDateTimeZone.FixedDateTimeZone(java.lang.String, java.lang.String, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.FixedDateTimeZone.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.FixedDateTimeZone.getStandardOffset(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.FixedDateTimeZone.iWallOffset</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.FixedDateTimeZone.FixedDateTimeZone(java.lang.String, java.lang.String, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.FixedDateTimeZone.equals(java.lang.Object)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.FixedDateTimeZone.getOffset(long)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.FixedDateTimeZone.getOffsetFromLocal(long)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.FixedDateTimeZone.isFixed()</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.FixedDateTimeZone.nextTransition(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.FixedDateTimeZone.previousTransition(long)</name>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.FixedDateTimeZone.serialVersionUID</name>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.tz.NameProvider</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.cNameProvider</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultNameProvider()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getName(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getNameProvider()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getShortName(long, java.util.Locale)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setNameProvider(org.joda.time.tz.NameProvider)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setNameProvider0(org.joda.time.tz.NameProvider)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.static {}</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.tz.DefaultNameProvider</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.tz.NameProvider.getName(java.util.Locale, java.lang.String, java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getName(long, java.util.Locale)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.NameProvider.getShortName(java.util.Locale, java.lang.String, java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getShortName(long, java.util.Locale)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.tz.Provider</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.cProvider</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultProvider()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.util.TimeZone)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getProvider()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setProvider(org.joda.time.tz.Provider)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setProvider0(org.joda.time.tz.Provider)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.static {}</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.tz.UTCProvider</inbound>
            <inbound type="class" confirmed="yes">org.joda.time.tz.ZoneInfoProvider</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.tz.Provider.getAvailableIDs()</name>
                <outbound type="class" confirmed="no">java.util.Set</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setProvider0(org.joda.time.tz.Provider)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.Provider.getDateTimeZone(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getInstance(java.util.TimeZone)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.setProvider0(org.joda.time.tz.Provider)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.tz.UTCProvider</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.tz.Provider</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.tz.UTCProvider.UTCProvider()</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultProvider()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.UTCProvider.getAvailableIDs()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.util.Collections.singleton(java.lang.Object)</outbound>
                <outbound type="class" confirmed="no">java.util.Set</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.UTCProvider.getDateTimeZone(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.equalsIgnoreCase(java.lang.String)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.tz.ZoneInfoCompiler</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler.ZoneInfoCompiler()</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.ArrayList()</outbound>
                <outbound type="feature" confirmed="no">java.util.HashMap.HashMap()</outbound>
                <outbound type="class" confirmed="no">java.util.List</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.iLinks</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.iRuleSets</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.iZones</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.main(java.lang.String[])</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler.cLenientISO</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.getLenientISOChronology()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler.cStartOfYear</name>
                <outbound type="class" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.getStartOfYear()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</name>
                <outbound type="class" confirmed="no">java.io.BufferedReader</outbound>
                <outbound type="feature" confirmed="no">java.io.BufferedReader.BufferedReader(java.io.Reader)</outbound>
                <outbound type="feature" confirmed="no">java.io.BufferedReader.close()</outbound>
                <outbound type="class" confirmed="no">java.io.DataOutputStream</outbound>
                <outbound type="feature" confirmed="no">java.io.DataOutputStream.DataOutputStream(java.io.OutputStream)</outbound>
                <outbound type="class" confirmed="no">java.io.File</outbound>
                <outbound type="feature" confirmed="no">java.io.File.File(java.io.File, java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.io.File.exists()</outbound>
                <outbound type="feature" confirmed="no">java.io.File.getParentFile()</outbound>
                <outbound type="feature" confirmed="no">java.io.File.isDirectory()</outbound>
                <outbound type="feature" confirmed="no">java.io.File.mkdirs()</outbound>
                <outbound type="feature" confirmed="no">java.io.FileInputStream.FileInputStream(java.io.File)</outbound>
                <outbound type="feature" confirmed="no">java.io.FileOutputStream.FileOutputStream(java.io.File)</outbound>
                <outbound type="feature" confirmed="no">java.io.FileReader.FileReader(java.io.File)</outbound>
                <outbound type="feature" confirmed="no">java.io.FilterOutputStream.close()</outbound>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="feature" confirmed="no">java.io.IOException.IOException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.io.InputStream</outbound>
                <outbound type="feature" confirmed="no">java.io.InputStream.close()</outbound>
                <outbound type="class" confirmed="no">java.io.OutputStream</outbound>
                <outbound type="feature" confirmed="no">java.io.OutputStream.close()</outbound>
                <outbound type="class" confirmed="no">java.io.PrintStream</outbound>
                <outbound type="feature" confirmed="no">java.io.PrintStream.println(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.io.Reader</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.CASE_INSENSITIVE_ORDER</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="feature" confirmed="no">java.lang.System.out</outbound>
                <outbound type="class" confirmed="no">java.util.Comparator</outbound>
                <outbound type="class" confirmed="no">java.util.List</outbound>
                <outbound type="feature" confirmed="no">java.util.List.get(int)</outbound>
                <outbound type="feature" confirmed="no">java.util.List.size()</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.get(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.put(java.lang.Object, java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.putAll(java.util.Map)</outbound>
                <outbound type="feature" confirmed="no">java.util.TreeMap.TreeMap()</outbound>
                <outbound type="feature" confirmed="no">java.util.TreeMap.TreeMap(java.util.Comparator)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.equals(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getID()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.DateTimeZoneBuilder()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.InputStream, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.writeTo(java.io.OutputStream)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.addToBuilder(org.joda.time.tz.DateTimeZoneBuilder, java.util.Map)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.iName</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.iLinks</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.iRuleSets</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.iZones</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.main(java.lang.String[])</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler.getLenientISOChronology()</name>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.LenientChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.LenientChronology.getInstance(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.cLenientISO</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseTime(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler.getStartOfYear()</name>
                <outbound type="class" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.cStartOfYear</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.ZoneInfoCompiler$Zone(java.lang.String, java.util.StringTokenizer)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler.iLinks</name>
                <outbound type="class" confirmed="no">java.util.List</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.ZoneInfoCompiler()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler.iRuleSets</name>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.ZoneInfoCompiler()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler.iZones</name>
                <outbound type="class" confirmed="no">java.util.List</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.ZoneInfoCompiler()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler.main(java.lang.String[])</name>
                <outbound type="class" confirmed="no">java.io.File</outbound>
                <outbound type="feature" confirmed="no">java.io.File.File(java.io.File, java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.io.File.File(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Exception</outbound>
                <outbound type="class" confirmed="no">java.lang.IndexOutOfBoundsException</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.equals(java.lang.Object)</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.ZoneInfoCompiler()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.printUsage()</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</name>
                <outbound type="class" confirmed="no">java.io.BufferedReader</outbound>
                <outbound type="feature" confirmed="no">java.io.BufferedReader.readLine()</outbound>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.PrintStream</outbound>
                <outbound type="feature" confirmed="no">java.io.PrintStream.println(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Character.isWhitespace(char)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.charAt(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.equalsIgnoreCase(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.indexOf(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.substring(int, int)</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="feature" confirmed="no">java.lang.System.out</outbound>
                <outbound type="class" confirmed="no">java.util.List</outbound>
                <outbound type="feature" confirmed="no">java.util.List.add(java.lang.Object)</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.get(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.put(java.lang.Object, java.lang.Object)</outbound>
                <outbound type="class" confirmed="no">java.util.StringTokenizer</outbound>
                <outbound type="feature" confirmed="no">java.util.StringTokenizer.StringTokenizer(java.lang.String, java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.util.StringTokenizer.hasMoreTokens()</outbound>
                <outbound type="feature" confirmed="no">java.util.StringTokenizer.nextToken()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.ZoneInfoCompiler$Rule(java.util.StringTokenizer)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.iName</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.ZoneInfoCompiler$RuleSet(org.joda.time.tz.ZoneInfoCompiler$Rule)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.addRule(org.joda.time.tz.ZoneInfoCompiler$Rule)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.ZoneInfoCompiler$Zone(java.util.StringTokenizer)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.chain(java.util.StringTokenizer)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.iLinks</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.iRuleSets</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.iZones</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler.parseDayOfWeek(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="no">java.util.Locale.ENGLISH</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, java.lang.String, java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.dayOfWeek()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear(java.util.StringTokenizer)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler.parseMonth(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Locale</outbound>
                <outbound type="feature" confirmed="no">java.util.Locale.ENGLISH</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.get(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, java.lang.String, java.util.Locale)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.monthOfYear()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear(java.util.StringTokenizer)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler.parseOptional(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.equals(java.lang.Object)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.ZoneInfoCompiler$Rule(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.ZoneInfoCompiler$Zone(java.lang.String, java.util.StringTokenizer)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler.parseTime(java.lang.String)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.startsWith(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.AbstractDateTime.getMillis()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.MutableDateTime.MutableDateTime(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.ReadWritableInstant</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.DateTimeFormatter</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.DateTimeParser.parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.format.ISODateTimeFormat</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.getInstance(org.joda.time.Chronology)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.format.ISODateTimeFormat.hourMinuteSecondFraction()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.getLenientISOChronology()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.ZoneInfoCompiler$Rule(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.ZoneInfoCompiler$Zone(java.lang.String, java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.addToBuilder(org.joda.time.tz.ZoneInfoCompiler$Zone, org.joda.time.tz.DateTimeZoneBuilder, java.util.Map)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler.parseYear(java.lang.String, int)</name>
                <outbound type="feature" confirmed="no">java.lang.Integer.parseInt(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.equals(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.toLowerCase()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.ZoneInfoCompiler$Rule(java.util.StringTokenizer)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler.parseZoneChar(char)</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear(java.util.StringTokenizer)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler.printUsage()</name>
                <outbound type="class" confirmed="no">java.io.PrintStream</outbound>
                <outbound type="feature" confirmed="no">java.io.PrintStream.println(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.System.out</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.main(java.lang.String[])</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler.readZoneInfoMap(java.io.DataInputStream, java.util.Map)</name>
                <outbound type="class" confirmed="no">java.io.DataInputStream</outbound>
                <outbound type="feature" confirmed="no">java.io.DataInputStream.readUTF()</outbound>
                <outbound type="feature" confirmed="no">java.io.DataInputStream.readUnsignedShort()</outbound>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="feature" confirmed="no">java.io.IOException.IOException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.ArrayIndexOutOfBoundsException</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.intern()</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.put(java.lang.Object, java.lang.Object)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneInfoMap(java.io.InputStream)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler.test(java.lang.String, org.joda.time.DateTimeZone)</name>
                <outbound type="class" confirmed="no">java.io.PrintStream</outbound>
                <outbound type="feature" confirmed="no">java.io.PrintStream.println(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Long</outbound>
                <outbound type="feature" confirmed="no">java.lang.Long.Long(long)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Long.longValue()</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.equals(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="feature" confirmed="no">java.lang.System.out</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.ArrayList()</outbound>
                <outbound type="feature" confirmed="no">java.util.List.add(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.List.get(int)</outbound>
                <outbound type="feature" confirmed="no">java.util.List.size()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.Chronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTime.DateTime(long, org.joda.time.Chronology)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeField</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeField.set(long, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getID()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getNameKey(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getStandardOffset(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.nextTransition(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.previousTransition(long)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.AssembledChronology.year()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.chrono.ISOChronology</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.chrono.ISOChronology.getInstanceUTC()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(java.io.DataOutputStream, java.util.Map)</name>
                <outbound type="class" confirmed="no">java.io.DataOutputStream</outbound>
                <outbound type="feature" confirmed="no">java.io.DataOutputStream.writeShort(int)</outbound>
                <outbound type="feature" confirmed="no">java.io.DataOutputStream.writeUTF(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="feature" confirmed="no">java.lang.InternalError.InternalError(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.Short</outbound>
                <outbound type="feature" confirmed="no">java.lang.Short.Short(short)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Short.shortValue()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Collection</outbound>
                <outbound type="feature" confirmed="no">java.util.Collection.iterator()</outbound>
                <outbound type="feature" confirmed="no">java.util.HashMap.HashMap(int)</outbound>
                <outbound type="class" confirmed="no">java.util.Iterator</outbound>
                <outbound type="feature" confirmed="no">java.util.Iterator.hasNext()</outbound>
                <outbound type="feature" confirmed="no">java.util.Iterator.next()</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="class" confirmed="no">java.util.Map$Entry</outbound>
                <outbound type="feature" confirmed="no">java.util.Map$Entry.getKey()</outbound>
                <outbound type="feature" confirmed="no">java.util.Map$Entry.getValue()</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.containsKey(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.entrySet()</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.get(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.put(java.lang.Object, java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.size()</outbound>
                <outbound type="class" confirmed="no">java.util.Set</outbound>
                <outbound type="feature" confirmed="no">java.util.Set.iterator()</outbound>
                <outbound type="feature" confirmed="no">java.util.TreeMap.TreeMap()</outbound>
                <outbound type="feature" confirmed="no">java.util.TreeMap.put(java.lang.Object, java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.TreeMap.size()</outbound>
                <outbound type="feature" confirmed="no">java.util.TreeMap.values()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getID()</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.ZoneInfoCompiler$Rule(java.util.StringTokenizer)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.iDateTimeOfYear</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.ZoneInfoCompiler$Zone(java.lang.String, java.util.StringTokenizer)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.addToBuilder(org.joda.time.tz.ZoneInfoCompiler$Zone, org.joda.time.tz.DateTimeZoneBuilder, java.util.Map)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.iUntilDateTimeOfYear</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.toString()</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.cStartOfYear</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.getStartOfYear()</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear()</name>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iAdvanceDayOfWeek</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iDayOfMonth</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iDayOfWeek</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iMillisOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iMonthOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iZoneChar</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.getStartOfYear()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear(java.util.StringTokenizer)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Integer.parseInt(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.NumberFormatException</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.charAt(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.indexOf(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.length()</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.startsWith(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.substring(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.substring(int, int)</outbound>
                <outbound type="class" confirmed="no">java.util.StringTokenizer</outbound>
                <outbound type="feature" confirmed="no">java.util.StringTokenizer.hasMoreTokens()</outbound>
                <outbound type="feature" confirmed="no">java.util.StringTokenizer.nextToken()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iAdvanceDayOfWeek</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iDayOfMonth</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iDayOfWeek</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iMillisOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iMonthOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iZoneChar</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDayOfWeek(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseMonth(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseTime(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseZoneChar(char)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.ZoneInfoCompiler$Rule(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.ZoneInfoCompiler$Zone(java.lang.String, java.util.StringTokenizer)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.addCutover(org.joda.time.tz.DateTimeZoneBuilder, int)</name>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addCutover(int, char, int, int, int, boolean, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iAdvanceDayOfWeek</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iDayOfMonth</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iDayOfWeek</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iMillisOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iMonthOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iZoneChar</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.addToBuilder(org.joda.time.tz.ZoneInfoCompiler$Zone, org.joda.time.tz.DateTimeZoneBuilder, java.util.Map)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String, int, int, int)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.addRecurringSavings(java.lang.String, int, int, int, char, int, int, int, boolean, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iAdvanceDayOfWeek</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iDayOfMonth</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iDayOfWeek</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iMillisOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iMonthOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iZoneChar</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iAdvanceDayOfWeek</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.addCutover(org.joda.time.tz.DateTimeZoneBuilder, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iDayOfMonth</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.addCutover(org.joda.time.tz.DateTimeZoneBuilder, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iDayOfWeek</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.addCutover(org.joda.time.tz.DateTimeZoneBuilder, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iMillisOfDay</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.addCutover(org.joda.time.tz.DateTimeZoneBuilder, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iMonthOfYear</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.addCutover(org.joda.time.tz.DateTimeZoneBuilder, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iZoneChar</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.addCutover(org.joda.time.tz.DateTimeZoneBuilder, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String, int, int, int)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.toString()</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(boolean)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iAdvanceDayOfWeek</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iDayOfMonth</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iDayOfWeek</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iMillisOfDay</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iMonthOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.iZoneChar</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.tz.ZoneInfoCompiler$Rule</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.ZoneInfoCompiler$RuleSet(org.joda.time.tz.ZoneInfoCompiler$Rule)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.addRule(org.joda.time.tz.ZoneInfoCompiler$Rule)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$Rule.ZoneInfoCompiler$Rule(java.util.StringTokenizer)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException()</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.intern()</outbound>
                <outbound type="class" confirmed="no">java.util.StringTokenizer</outbound>
                <outbound type="feature" confirmed="no">java.util.StringTokenizer.nextToken()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear(java.util.StringTokenizer)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.iDateTimeOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.iFromYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.iLetterS</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.iName</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.iSaveMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.iToYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.iType</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseOptional(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseTime(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseYear(java.lang.String, int)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$Rule.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String, int, int, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.formatName(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.iDateTimeOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.iFromYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.iSaveMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.iToYear</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$Rule.formatName(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.concat(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.indexOf(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.indexOf(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.intern()</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.substring(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.substring(int, int)</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.iLetterS</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.iSaveMillis</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$Rule.iDateTimeOfYear</name>
                <outbound type="class" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.ZoneInfoCompiler$Rule(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$Rule.iFromYear</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.ZoneInfoCompiler$Rule(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$Rule.iLetterS</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.ZoneInfoCompiler$Rule(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.formatName(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$Rule.iName</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.ZoneInfoCompiler$Rule(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.addRule(org.joda.time.tz.ZoneInfoCompiler$Rule)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$Rule.iSaveMillis</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.ZoneInfoCompiler$Rule(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.formatName(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$Rule.iToYear</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.ZoneInfoCompiler$Rule(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$Rule.iType</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.ZoneInfoCompiler$Rule(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$Rule.toString()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.iDateTimeOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.iFromYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.iLetterS</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.iName</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.iSaveMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.iToYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.iType</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.tz.ZoneInfoCompiler$RuleSet</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.addToBuilder(org.joda.time.tz.ZoneInfoCompiler$Zone, org.joda.time.tz.DateTimeZoneBuilder, java.util.Map)</inbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$RuleSet.ZoneInfoCompiler$RuleSet(org.joda.time.tz.ZoneInfoCompiler$Rule)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="feature" confirmed="no">java.util.ArrayList.ArrayList()</outbound>
                <outbound type="class" confirmed="no">java.util.List</outbound>
                <outbound type="feature" confirmed="no">java.util.List.add(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.iRules</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$RuleSet.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.List</outbound>
                <outbound type="feature" confirmed="no">java.util.List.get(int)</outbound>
                <outbound type="feature" confirmed="no">java.util.List.size()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.iRules</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.addToBuilder(org.joda.time.tz.ZoneInfoCompiler$Zone, org.joda.time.tz.DateTimeZoneBuilder, java.util.Map)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$RuleSet.addRule(org.joda.time.tz.ZoneInfoCompiler$Rule)</name>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.equals(java.lang.Object)</outbound>
                <outbound type="class" confirmed="no">java.util.List</outbound>
                <outbound type="feature" confirmed="no">java.util.List.add(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.List.get(int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Rule.iName</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.iRules</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$RuleSet.iRules</name>
                <outbound type="class" confirmed="no">java.util.List</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.ZoneInfoCompiler$RuleSet(org.joda.time.tz.ZoneInfoCompiler$Rule)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.addRule(org.joda.time.tz.ZoneInfoCompiler$Rule)</inbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.tz.ZoneInfoCompiler$Zone</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$Zone.ZoneInfoCompiler$Zone(java.lang.String, java.util.StringTokenizer)</name>
                <outbound type="feature" confirmed="no">java.lang.Integer.parseInt(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.intern()</outbound>
                <outbound type="class" confirmed="no">java.util.StringTokenizer</outbound>
                <outbound type="feature" confirmed="no">java.util.StringTokenizer.hasMoreTokens()</outbound>
                <outbound type="feature" confirmed="no">java.util.StringTokenizer.nextToken()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.ZoneInfoCompiler$DateTimeOfYear(java.util.StringTokenizer)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.iFormat</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.iName</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.iOffsetMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.iRules</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.iUntilDateTimeOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.iUntilYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.getStartOfYear()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseOptional(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseTime(java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.ZoneInfoCompiler$Zone(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.chain(java.util.StringTokenizer)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$Zone.ZoneInfoCompiler$Zone(java.util.StringTokenizer)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.StringTokenizer</outbound>
                <outbound type="feature" confirmed="no">java.util.StringTokenizer.nextToken()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.ZoneInfoCompiler$Zone(java.lang.String, java.util.StringTokenizer)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$Zone.addToBuilder(org.joda.time.tz.DateTimeZoneBuilder, java.util.Map)</name>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.addToBuilder(org.joda.time.tz.ZoneInfoCompiler$Zone, org.joda.time.tz.DateTimeZoneBuilder, java.util.Map)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.buildDateTimeZone(java.util.Map)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$Zone.addToBuilder(org.joda.time.tz.ZoneInfoCompiler$Zone, org.joda.time.tz.DateTimeZoneBuilder, java.util.Map)</name>
                <outbound type="class" confirmed="no">java.lang.Exception</outbound>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.get(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.setFixedSavings(java.lang.String, int)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.setStandardOffset(int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear.addCutover(org.joda.time.tz.DateTimeZoneBuilder, int)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$RuleSet.addRecurring(org.joda.time.tz.DateTimeZoneBuilder, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.iFormat</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.iNext</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.iOffsetMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.iRules</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.iUntilDateTimeOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.iUntilYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseTime(java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.addToBuilder(org.joda.time.tz.DateTimeZoneBuilder, java.util.Map)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$Zone.buildDateTimeZone(java.util.Map)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.DateTimeZoneBuilder()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.addToBuilder(org.joda.time.tz.DateTimeZoneBuilder, java.util.Map)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.iName</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$Zone.chain(java.util.StringTokenizer)</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.util.StringTokenizer</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.ZoneInfoCompiler$Zone(java.lang.String, java.util.StringTokenizer)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.iName</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.iNext</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.parseDataFile(java.io.BufferedReader)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$Zone.iFormat</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.ZoneInfoCompiler$Zone(java.lang.String, java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.addToBuilder(org.joda.time.tz.ZoneInfoCompiler$Zone, org.joda.time.tz.DateTimeZoneBuilder, java.util.Map)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$Zone.iName</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.ZoneInfoCompiler$Zone(java.lang.String, java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.buildDateTimeZone(java.util.Map)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.chain(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.toString()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.compile(java.io.File, java.io.File[])</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$Zone.iNext</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.addToBuilder(org.joda.time.tz.ZoneInfoCompiler$Zone, org.joda.time.tz.DateTimeZoneBuilder, java.util.Map)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.chain(java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$Zone.iOffsetMillis</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.ZoneInfoCompiler$Zone(java.lang.String, java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.addToBuilder(org.joda.time.tz.ZoneInfoCompiler$Zone, org.joda.time.tz.DateTimeZoneBuilder, java.util.Map)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$Zone.iRules</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.ZoneInfoCompiler$Zone(java.lang.String, java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.addToBuilder(org.joda.time.tz.ZoneInfoCompiler$Zone, org.joda.time.tz.DateTimeZoneBuilder, java.util.Map)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$Zone.iUntilDateTimeOfYear</name>
                <outbound type="class" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.ZoneInfoCompiler$Zone(java.lang.String, java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.addToBuilder(org.joda.time.tz.ZoneInfoCompiler$Zone, org.joda.time.tz.DateTimeZoneBuilder, java.util.Map)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$Zone.iUntilYear</name>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.ZoneInfoCompiler$Zone(java.lang.String, java.util.StringTokenizer)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.addToBuilder(org.joda.time.tz.ZoneInfoCompiler$Zone, org.joda.time.tz.DateTimeZoneBuilder, java.util.Map)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.toString()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoCompiler$Zone.toString()</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$DateTimeOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.iFormat</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.iName</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.iNext</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.iOffsetMillis</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.iRules</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.iUntilDateTimeOfYear</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler$Zone.iUntilYear</outbound>
            </feature>
        </class>
        <class confirmed="yes">
            <name>org.joda.time.tz.ZoneInfoProvider</name>
            <outbound type="class" confirmed="no">java.lang.Object</outbound>
            <outbound type="class" confirmed="yes">org.joda.time.tz.Provider</outbound>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.io.File)</name>
                <outbound type="class" confirmed="no">java.io.File</outbound>
                <outbound type="feature" confirmed="no">java.io.File.exists()</outbound>
                <outbound type="feature" confirmed="no">java.io.File.isDirectory()</outbound>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="feature" confirmed="no">java.io.IOException.IOException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.io.InputStream</outbound>
                <outbound type="class" confirmed="no">java.lang.ClassLoader</outbound>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.iFileDir</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.iLoader</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.iResourcePath</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.iZoneInfoMap</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneInfoMap(java.io.InputStream)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.openResource(java.lang.String)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.lang.ClassLoader</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader, boolean)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.getDefaultProvider()</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.lang.ClassLoader</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader, boolean)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader, boolean)</name>
                <outbound type="class" confirmed="no">java.io.File</outbound>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.InputStream</outbound>
                <outbound type="class" confirmed="no">java.lang.Class</outbound>
                <outbound type="feature" confirmed="no">java.lang.Class.getClassLoader()</outbound>
                <outbound type="class" confirmed="no">java.lang.ClassLoader</outbound>
                <outbound type="feature" confirmed="no">java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.Object()</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.getClass()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.endsWith(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer()</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(char)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.iFileDir</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.iLoader</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.iResourcePath</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.iZoneInfoMap</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneInfoMap(java.io.InputStream)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.openResource(java.lang.String)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoProvider.getAvailableIDs()</name>
                <outbound type="feature" confirmed="no">java.util.Collections.unmodifiableSet(java.util.Set)</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.keySet()</outbound>
                <outbound type="class" confirmed="no">java.util.Set</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.iZoneInfoMap</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoProvider.getDateTimeZone(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.equals(java.lang.Object)</outbound>
                <outbound type="class" confirmed="no">java.lang.ref.SoftReference</outbound>
                <outbound type="feature" confirmed="no">java.lang.ref.SoftReference.get()</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.get(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.iZoneInfoMap</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneData(java.lang.String)</outbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoProvider.iFileDir</name>
                <outbound type="class" confirmed="no">java.io.File</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.io.File)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.openResource(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoProvider.iLoader</name>
                <outbound type="class" confirmed="no">java.lang.ClassLoader</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.io.File)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.openResource(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoProvider.iResourcePath</name>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.io.File)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.openResource(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoProvider.iZoneInfoMap</name>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.io.File)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.getAvailableIDs()</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.getDateTimeZone(java.lang.String)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneData(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoProvider.loadZoneData(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.InputStream</outbound>
                <outbound type="feature" confirmed="no">java.io.InputStream.close()</outbound>
                <outbound type="class" confirmed="no">java.lang.Exception</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.ref.SoftReference.SoftReference(java.lang.Object)</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.put(java.lang.Object, java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.remove(java.lang.Object)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.DateTimeZoneBuilder.readFrom(java.io.InputStream, java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.iZoneInfoMap</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.openResource(java.lang.String)</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.uncaughtException(java.lang.Exception)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.getDateTimeZone(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoProvider.loadZoneInfoMap(java.io.InputStream)</name>
                <outbound type="class" confirmed="no">java.io.DataInputStream</outbound>
                <outbound type="feature" confirmed="no">java.io.DataInputStream.DataInputStream(java.io.InputStream)</outbound>
                <outbound type="feature" confirmed="no">java.io.FilterInputStream.close()</outbound>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="class" confirmed="no">java.io.InputStream</outbound>
                <outbound type="class" confirmed="no">java.lang.Object</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.CASE_INSENSITIVE_ORDER</outbound>
                <outbound type="feature" confirmed="no">java.lang.ref.SoftReference.SoftReference(java.lang.Object)</outbound>
                <outbound type="class" confirmed="no">java.util.Comparator</outbound>
                <outbound type="class" confirmed="no">java.util.Map</outbound>
                <outbound type="feature" confirmed="no">java.util.Map.put(java.lang.Object, java.lang.Object)</outbound>
                <outbound type="feature" confirmed="no">java.util.TreeMap.TreeMap(java.util.Comparator)</outbound>
                <outbound type="class" confirmed="yes">org.joda.time.DateTimeZone</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.DateTimeZone.UTC</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoCompiler.readZoneInfoMap(java.io.DataInputStream, java.util.Map)</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.io.File)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader, boolean)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoProvider.openResource(java.lang.String)</name>
                <outbound type="class" confirmed="no">java.io.File</outbound>
                <outbound type="feature" confirmed="no">java.io.File.File(java.io.File, java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.io.FileInputStream.FileInputStream(java.io.File)</outbound>
                <outbound type="class" confirmed="no">java.io.IOException</outbound>
                <outbound type="feature" confirmed="no">java.io.IOException.IOException(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.io.InputStream</outbound>
                <outbound type="class" confirmed="no">java.lang.ClassLoader</outbound>
                <outbound type="feature" confirmed="no">java.lang.ClassLoader.getResourceAsStream(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.ClassLoader.getSystemResourceAsStream(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.Object.toString()</outbound>
                <outbound type="class" confirmed="no">java.lang.String</outbound>
                <outbound type="feature" confirmed="no">java.lang.String.concat(java.lang.String)</outbound>
                <outbound type="class" confirmed="no">java.lang.StringBuffer</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.StringBuffer(int)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.append(java.lang.String)</outbound>
                <outbound type="feature" confirmed="no">java.lang.StringBuffer.toString()</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.iFileDir</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.iLoader</outbound>
                <outbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.iResourcePath</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.io.File)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(java.lang.String, java.lang.ClassLoader, boolean)</inbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneData(java.lang.String)</inbound>
            </feature>
            <feature confirmed="yes">
                <name>org.joda.time.tz.ZoneInfoProvider.uncaughtException(java.lang.Exception)</name>
                <outbound type="class" confirmed="no">java.lang.Exception</outbound>
                <outbound type="class" confirmed="no">java.lang.Thread</outbound>
                <outbound type="feature" confirmed="no">java.lang.Thread.currentThread()</outbound>
                <outbound type="feature" confirmed="no">java.lang.Thread.getThreadGroup()</outbound>
                <outbound type="class" confirmed="no">java.lang.ThreadGroup</outbound>
                <outbound type="feature" confirmed="no">java.lang.ThreadGroup.uncaughtException(java.lang.Thread, java.lang.Throwable)</outbound>
                <outbound type="class" confirmed="no">java.lang.Throwable</outbound>
                <inbound type="feature" confirmed="yes">org.joda.time.tz.ZoneInfoProvider.loadZoneData(java.lang.String)</inbound>
            </feature>
        </class>
    </package>
</dependencies>
